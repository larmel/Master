#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass report
\begin_preamble
\usepackage{float}
\floatname{algorithm}{Listing}
\let\origdoublepage\cleardoublepage
\newcommand{\clearemptydoublepage}{%
  \clearpage
  {\pagestyle{empty}\origdoublepage}%
}
\let\cleardoublepage\clearemptydoublepage
\DeclareFixedFont{\ttb}{T1}{txtt}{bx}{n}{9} % for bold
\DeclareFixedFont{\ttm}{T1}{txtt}{m}{n}{9}  % for normal
\definecolor{deepblue}{rgb}{0,0,0.5}
\definecolor{deepred}{rgb}{0.6,0,0}
\definecolor{deepgreen}{rgb}{0.25,0.5,0.35}
\definecolor{javared}{rgb}{0.6,0,0} % for strings
\end_preamble
\options openright
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman lmodern
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 12
\spacing single
\use_hyperref false
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks true
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize a4paper
\use_geometry true
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 3cm
\topmargin 4cm
\rightmargin 3cm
\bottommargin 4cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 2
\paperpagestyle headings
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Quotation
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pagenumbering{roman}
\end_layout

\end_inset


\end_layout

\begin_layout Section*
Problem Description
\end_layout

\begin_layout Standard
Variations in execution context has been shown to affect performance of
 programs on recent CPUs.
 Previous work has looked at offsetting the stack and changing link order
 -- biasing performance measurements towards certain configurations.
 Variables such as the placement of stack, heap and text segments in memory,
 combined with memory access instructions, can impact program performance
 quite significantly.
 
\end_layout

\begin_layout Standard
The goal of this project is to model some of these effects for common use
 cases, and methods for avoiding them, in order to avoid bias and achieving
 peak performance.
 These effects might be highly platform dependent, so to limit the scope
 we will focus on a particular architecture, the Intel Core i7 
\begin_inset Quotes eld
\end_inset

Ivy Bridge
\begin_inset Quotes erd
\end_inset

.
 Case studies will include small isolated programs, and ideally also 
\begin_inset Quotes eld
\end_inset

real
\begin_inset Quotes erd
\end_inset

 applications such as FFT algorithms.
\end_layout

\begin_layout Standard
\begin_inset Newpage cleardoublepage
\end_inset


\end_layout

\begin_layout Abstract
Performance analysis of software is subject to measurement bias.
 Seemingly innocuous properties of the environment, such as the contents
 of system environment variables, can impact the performance of computer
 programs.
 Features and restrictions of the underlying hardware introduces performance
 cliffs; on one machine a piece of code might fit within a single cache
 line, while on another the alignment in memory fragments it in two.
 Effects like these have been shown to be significant, but unpredictable
 and difficult to deal with.
\end_layout

\begin_layout Abstract
In this thesis, we will study bias effects that can be experienced by changing
 the Unix environment variables or altering the program link order.
 Both of these factors lead to different virtual memory layouts for code
 and data, which in turn interacts with various hardware features.
 Through experimentation and careful measurement using hardware performance
 counters, we identify several potential sources of bias on the Intel Core
 i7 
\begin_inset Quotes eld
\end_inset

Ivy Bridge
\begin_inset Quotes erd
\end_inset

 architecture.
 Limitations imposed by the Loop Stream Detector hardware optimization is
 revealed, along with effects from 4K address aliasing.
 We show that bias is in fact not completely unpredictable, and discuss
 measures for avoiding it.
\end_layout

\begin_layout Abstract
Our case studies show that even highly optimized Fourier transform and linear
 algebra libraries are prone to bias.
 We find that stack alignment significantly affects the performance of FFTW,
 and that in some cases more than 30 % performance gain can be made by avoiding
 address aliasing in ATLAS matrix-vector multiplication.
\end_layout

\begin_layout Standard
\begin_inset Newpage cleardoublepage
\end_inset


\end_layout

\begin_layout Standard

\lang norsk
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\end_inset


\end_layout

\begin_layout Abstract

\lang norsk
Ytelsesvurdering av programvare er påvirket av mange forskjellige, og tilsynelat
ende uviktige, egenskaper ved maskinen man gjør målinger på.
 For eksempel kan innholdet i miljøvariabler, eller rekkefølgen man linker
 programfiler på, være signifikant.
 Variasjoner som følge av slike eksterne egenskaper klassifiseres som 
\emph on
bias
\emph default
.
 Den egentlige årsaken viser seg ofte å være endringer i organiseringen
 av minne.
 Restriksjoner ved den underliggende maskinvaren introduserer 
\begin_inset Quotes eld
\end_inset

hopp
\begin_inset Quotes erd
\end_inset

 i ytelse; på en maskin kan en kodesnutt få plass i én linje i hurtigminnet,
 mens på en annen kan den bli fragmentert i flere.
 Slike effekter kan være signifikante, men er også funnet å være vanskelige
 å forutse eller motvirke.
\end_layout

\begin_layout Abstract

\lang norsk
Denne oppgaven dreier seg om å studere underliggende årsaker til ytelsesforskjel
ler som kan forekomme av å endre minneaddresser for programkode og data.
 Hovedfokus vil være på Intel Core i7 
\begin_inset Quotes eld
\end_inset

Ivy Bridge
\begin_inset Quotes erd
\end_inset

-arkitekturen.
 Gjennom eksperimenter og nøyaktig måling ved bruk av 
\begin_inset Quotes eld
\end_inset

performance counters
\begin_inset Quotes erd
\end_inset

, kan vi identifisere konkrete arkitekturspesifikke egenskaper ved prosessoren
 som fører til bias.
 Begrensninger i 
\begin_inset Quotes eld
\end_inset

Loop Stream Detector
\begin_inset Quotes erd
\end_inset

, samt en effekt kjent som 
\begin_inset Quotes eld
\end_inset

4K aliasing
\begin_inset Quotes erd
\end_inset

 studeres i detalj.
 
\end_layout

\begin_layout Abstract

\lang norsk
Undersøkelser av programvare for Fourier-transformasjoner og lineær algebra
 viser at særlig alias-effekter ofte kan gi signifikante ytelsesforskjeller
 i praksis.
 Både FFTW og ATLAS viser seg å være sårbare mot bias.
 For eksempel kan riktig plassering av data i minne gi over 30 % forbedring
 av allerede høyt optimaliserte rutiner for matrise-vektor-multiplikasjon.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage cleardoublepage
\end_inset


\end_layout

\begin_layout Section*
Acknowledgements
\end_layout

\begin_layout Standard
I would like to thank my supervisor Anne C.
 Elster for her support during this past year.
 A special thanks to my co-supervisor Rune E.
 Jensen, whose continuous assistance and expertise on performance counters
 helped me navigate through this challenging topic.
\end_layout

\begin_layout Standard
The HPC-lab at NTNU provided the hardware and resources necessary to complete
 this work, for which I am grateful.
 I would also like to thank the other master students there, for providing
 a great work environment and invaluable feedback.
\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Chapter
Introduction
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pagenumbering{arabic}
\end_layout

\end_inset

Performance of computer programs is not just a function of the collection
 of machine instructions executed.
 Various external properties, such as the operating system, or even room
 temperature, can have have an impact on how fast programs execute: Modern
 microchips can be sensitive to temperature, possibly operating on higher
 clock rates in cold environments.
 Characteristics of the operating system can decide things like the placement
 of code and data in memory, which in turn interacts with various hardware
 mechanisms.
 Corner cases in hardware introduces potential 
\emph on
performance cliffs
\emph default
; If for example a memory access happens to cross a page boundary, the cost
 of an additional TLB miss can be significant.
 The set of conditions under which a program executes is called the 
\emph on
execution context
\emph default
, which includes virtual memory layout in particular.
 Variations within contexts can lead to programs being 
\emph on
biased
\emph default
 towards certain configurations.
 Measuring performance of the same program on two machines with identical
 hardware can sometimes yield very different results, an effect known as
 
\emph on
measurement bias
\emph default
.
\end_layout

\begin_layout Standard
Previous work has studied parameters such as the size of Unix environment
 variables and program link order.
 Both are found to potentially have a significant effect on performance,
 even in standardized benchmarks.
 Unfortunately, the effects also appear to be unpredictable, and therefore
 difficult to deal with.
 This poses a problem for researchers and performance analysts, who will
 need to account for effects of measurement bias with more rigorous methodologie
s and statistical methods.
 
\end_layout

\begin_layout Standard
In this thesis, we will try to unveil the actual causes of bias that can
 be experienced by altering memory layout.
 Both the size of environment variables and link ordering ultimately has
 an effect on memory layout of running processes.
 We will 
\emph on
not
\emph default
 look at things like cache efficiency, which often can be the reason for
 bad performance under certain memory contexts.
 Instead, we look at effects from less known optimizations in the out-of-order
 execution engine and instructions fetch pipeline.
 Because bias effects are intrinsically connected to various hardware features,
 we will focus on the Intel® Core™ i7 
\begin_inset Quotes eld
\end_inset

Ivy Bridge
\begin_inset Quotes erd
\end_inset

 architecture specifically.
 The goal is to identify specific hardware features that causes measurement
 bias, and model how they interact with software programs.
 With a better understanding of intricate properties of the CPU, we will
 be able to not only predict, but also explicitly optimize for beneficial
 memory layouts.
 
\end_layout

\begin_layout Section
Motivation
\end_layout

\begin_layout Standard
In the paper appropriately named 
\begin_inset Quotes eld
\end_inset

Producing Wrong Data Without Doing Anything Obviously Wrong
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "Mytkowicz:2009:WrongData"

\end_inset

, the authors show how simple changes to the execution environment can have
 an impact on performance.
 One of the parameters they studied was the size of Unix environment variables.
 Environment variables contain various information about the system, for
 instance the name of the currently logged in user, home- and current directory
 path.
 It seems unlikely that the contents of these variables should have any
 significance on program performance, yet previous work show that the effects
 can be enormous.
 
\end_layout

\begin_layout Standard
\noindent
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "43col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},language=C"
inline false
status open

\begin_layout Plain Layout

static int i, j, k;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main() {
\end_layout

\begin_layout Plain Layout

    int g = 0, inc = 1;
\end_layout

\begin_layout Plain Layout

    for (;g<65536;g++) {
\end_layout

\begin_layout Plain Layout

        i += inc;
\end_layout

\begin_layout Plain Layout

        j += inc;
\end_layout

\begin_layout Plain Layout

        k += inc;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "47col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\noindent
\align left
\begin_inset Graphics
	filename Img/loop/motivation.eps

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:motivation"

\end_inset

A simple C program with significant performance variations under different
 Unix environment sizes
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
This paper is particularly interesting because of an intriguing little C
 program, which is reproduced here in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:motivation"

\end_inset

.
 The authors observed that this program was noticeably affected by changes
 to the environment variables, performing much worse (in terms of cycle
 count) for some environment sizes.
 Interestingly, we are able to reproduce very similar results for our newer
 Ivy Bridge architecture.
 Plotting the number of cycles executed for different environment sizes,
 we see that the cycle count suddenly increases by more than 20 %.
 The length of your name -- by extension you user login -- could in principle
 be the tipping point between good and bad performance when running this
 program.
 
\end_layout

\begin_layout Standard
What is the 
\begin_inset Quotes eld
\end_inset

correct
\begin_inset Quotes erd
\end_inset

 number of cycles here? One could say that in most cases, it should be around
 700,000, although on average it is somewhat higher.
 On a machine with just the right environment size, one might declare that
 the cycle count is about 850,000.
 This illustrates how external properties can bias performance towards certain
 environments.
 Previous work focuses mostly on how to mitigate effects of bias, and avoid
 drawing the wrong conclusions based on misleading measurements.
 Our goal is to gain a better understanding of exactly what mechanisms of
 the processor causes these effects.
 With more accurate models of how bias occur, we will be able to actively
 avoid these 
\begin_inset Quotes eld
\end_inset

spikes
\begin_inset Quotes erd
\end_inset

 in performance, and gain a real speedup on average.
\end_layout

\begin_layout Section
Outline
\end_layout

\begin_layout Standard
The remaining parts of this thesis structured as follows
\end_layout

\begin_layout Description
Chapter
\begin_inset space ~
\end_inset

2 presents some of the previous work done on measurement bias, showing its
 severity as well as proposed solutions to mitigate or compensate for it.
 A brief overview to the Ivy Bridge microarchitecture and use of hardware
 performance monitoring is given as background material.
 We also introduce important concepts in virtual memory layout on 64 bit
 Linux systems, explaining the memory execution context.
\end_layout

\begin_layout Description
Chapter
\begin_inset space ~
\end_inset

3 discusses the experimental setup and methodology used throughout the remainder
 of the thesis.
 
\end_layout

\begin_layout Description
Chapter
\begin_inset space ~
\end_inset

4 investigates several potential causes of bias, showing how certain hardware
 features are sensitive to changes in virtual memory layout.
 Specifically, we show how 4K address aliasing and the Loop Stream Detector
 can explain effects observed by increasing environment size or changing
 link order.
\end_layout

\begin_layout Description
Chapter
\begin_inset space ~
\end_inset

5 applies knowledge of bias effects from the previous chapter, looking at
 how they apply to real world applications.
 We take an in-depth look at FFTW, showing how even this highly optimized
 Fourier transform library can be affected by memory layout.
 We also show how to get significant performance gains for BLAS matrix-vector
 routines, by actively avoiding address aliasing of heap-allocated memory.
\end_layout

\begin_layout Description
Chapter
\begin_inset space ~
\end_inset

6 summarizes results from previous chapters, and provides directions for
 future work.
 
\end_layout

\begin_layout Chapter
Background and Related Work
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "chap:Background"

\end_inset

We begin by presenting some of the previous work done on measurement bias
 in performance analysis.
 A brief overview of the Intel Core 
\begin_inset Quotes eld
\end_inset

Ivy Bridge
\begin_inset Quotes erd
\end_inset

 architecture is included, introducing performance counters, and highlighting
 some of the features and hardware optimizations that can cause performance
 cliffs.
 An introduction to virtual memory, linking and loading on 64 bit Linux
 architectures is provided as background material -- explaining important
 factors of the program execution environment.
 
\end_layout

\begin_layout Section
Observer Effect and Measurement Bias
\end_layout

\begin_layout Standard
Several papers dealing with bias in performance analysis have been published.
 Mytkowitcz et.
 al.
 provide an excellent introduction to measurement bias, together with the
 closely related phenomenon of observer effect, in the paper 
\begin_inset Quotes eld
\end_inset

Observer Effect and Measurement Bias in Performance Analysis
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "Mytkowicz:2008:OE&MB"

\end_inset

, and 
\begin_inset Quotes eld
\end_inset

We have it easy, but do we have it right?
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "Mytkowicz:2008:Easy"

\end_inset

.
 The authors draw parallels to the social and natural sciences, scientific
 fields where considerable care is taken to avoid observer effect and bias
 in experimental setups.
 They argue that the methodology currently employed in analysis of software
 is lacking.
 Because observer effect and bias in experiments is often ignored (or improperly
 accounted for), performance analysis suffers from 
\begin_inset Quotes eld
\end_inset

poor-quality data
\begin_inset Quotes erd
\end_inset

.
 In literature surveys, they find that very few authors considers these
 effects when evaluating results.
 
\end_layout

\begin_layout Subsubsection*
Observer effect 
\end_layout

\begin_layout Standard
Observer effect occurs when the act of observing something changes its character
istics.
 In performance analysis, we are interested in observing a variety of properties
; A useful property for evaluating a database application might be the number
 of transactions per second, while the cycle count or number of cache misses
 might be more relevant when implementing a hash function.
 Many low level metrics, such as the number of CPU cycles used, can be acquired
 (or observed) using hardware performance counters.
 In other cases, we need to add instrumentation to the program being measured,
 for example in the form of incrementing counter variables for every function
 call.
 Mytkowitcz et al.
 
\begin_inset CommandInset citation
LatexCommand cite
key "Mytkowicz:2008:OE&MB"

\end_inset

 show that both strict use of hardware counters, as well as adding software
 instrumentation, is vulnerable to observer effects.
 Despite using techniques with minimal intrusion and overhead to the original
 program, observer effects can sometimes significantly skew performance
 measurements.
\end_layout

\begin_layout Subsubsection*
Measurement bias
\end_layout

\begin_layout Standard
The performance characteristics of software changes not only from observations,
 but also from external properties of the experimental setup.
 Two, seemingly innocuous, properties of the execution environment are discussed
:
\end_layout

\begin_layout Itemize
Link order of object files: The order of which the .o files are provided
 to the linker.
 Usually more than one valid permutations exist, and different orderings
 produce functionally identical programs.
 
\end_layout

\begin_layout Itemize
Shell state, specifically environment variables.
 The content of environment variables on a given system depends on many
 factors, such as the user currently logged in (stored as 
\begin_inset Quotes eld
\end_inset

USER
\begin_inset Quotes erd
\end_inset

 in Linux), or which programs are currently installed, adding directories
 to the 
\begin_inset Quotes eld
\end_inset

PATH
\begin_inset Quotes erd
\end_inset

 variable.
\end_layout

\begin_layout Standard
The authors study how program performance for different compiler optimization
 levels is affected by adding characters to environment variables or changing
 program link order.
 Their results show that standardized SPEC benchmarks are sensitive to both
 of these properties.
 Different conclusions about O2's efficiency versus O3 can be drawn depending
 on the environment.
\end_layout

\begin_layout Standard
There are many other properties one could consider as possible sources of
 bias.
 With link ordering causing performance variations, one must also consider
 the different 
\emph on
versions
\emph default
 of compilers or linkers used.
 Different compiler versions might generate different code -- resulting
 in variations in memory layout of code and data.
 In general, the exact implementation of any software system that interacts
 with program execution must be considered, including compiler toolchain
 and operating system used.
 
\end_layout

\begin_layout Subsection
Causes of Measurement Bias
\end_layout

\begin_layout Standard
In a following paper by Mytkowicz et al.
 
\begin_inset CommandInset citation
LatexCommand cite
key "Mytkowicz:2009:WrongData"

\end_inset

, the effects previously presented are reiterated, along with a more detailed
 analysis of measurement bias.
 In addition to pointing out sensitivity in large benchmark programs from
 the SPEC suite, the authors also present a small, isolated C program with
 very high sensitivity to change in environment size.
 We discuss this particular program in the introduction chapter, showing
 that similar bias effects appear on newer architectures as well.
\end_layout

\begin_layout Standard
For both changing environment variables and link order, the authors point
 to changes to the virtual memory layout being the real cause of performance
 variations.
\end_layout

\begin_layout Itemize
Changing environment variables has an effect on where the stack is placed
 in memory at runtime.
 A copy of the environment is loaded into virtual address space before the
 call stack starts, thus increasing the environment size offsets the initial
 stack address.
 The authors suggests that altering the addresses of stack-allocated variables
 at runtime can have an impact on things like alignment in cache.
\end_layout

\begin_layout Itemize
Changing link order can change the virtual addresses of instructions.
 Using hardware simulators, the authors show that performance also depends
 on code alignment in memory.
 For instance, when a hot loop fits entirely in a single cache line, the
 number of accesses to instruction cache can be reduced.
 The authors speculate that the 
\begin_inset Quotes eld
\end_inset

Loop Stream Detector
\begin_inset Quotes erd
\end_inset

 might cause bias on the Intel® Core™ 2, a hardware optimization that is
 supposed to speed up instruction fetching of hot loops.
\end_layout

\begin_layout Standard
Despite demystifying the causes of bias to some degree, this paper provides
 no satisfactory explanation of exactly how or what hardware mechanisms
 causes bias.
 
\end_layout

\begin_layout Subsection
Dealing with Bias
\end_layout

\begin_layout Standard
Previous work conclude that measurement bias is 
\emph on
unpredictable
\emph default
, and difficult to avoid in experimental setups.
 In literature surveys, Mytkowicz et al.
 find that almost no papers account for measurement bias 
\begin_inset CommandInset citation
LatexCommand cite
key "Mytkowicz:2008:OE&MB,Mytkowicz:2009:WrongData"

\end_inset

.
 This is problematic, because conclusions reached from running biased experiment
s can easily be misleading, or even outright wrong.
 Measures have to be made to ensure the results obtained by performance
 analysis are valid.
 The authors provide some guidelines for how to conduct sound experiments:
\end_layout

\begin_layout Itemize
Diversify benchmarks, using statistical methods over a set of diverse benchmarks
 will help cancel out bias.
 Their study of the SPEC suite shows that currently widely used benchmark
 suites are not diverse enough to cancel out bias.
\end_layout

\begin_layout Itemize
Randomize experimental setup, performing multiple measurements under different
 configurations of variables that are known to cause bias.
 
\end_layout

\begin_layout Section
Exploiting Bias for Optimization
\end_layout

\begin_layout Standard
So far we have pointed out the problems bias causes for performance analysis.
 A different perspective on these effects is to look at it as a potential
 for optimization.
 
\end_layout

\begin_layout Subsection
Blind Optimization
\end_layout

\begin_layout Standard
An optimizing compiler needs to have some sort of abstract model of the
 target processor or machine, in order to emit an 
\begin_inset Quotes eld
\end_inset

optimal
\begin_inset Quotes erd
\end_inset

 set of instructions.
 As CPUs become more and more sophisticated, creating a good model for optimizat
ion is difficult.
 Additionally, with bias effects deemed 
\emph on
unpredictable
\emph default
, creating an accurate model becomes impossible.
 In 
\begin_inset Quotes eld
\end_inset

Blind Optimization for Exploiting Hardware Features
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "Knights:2009:BlindOpt"

\end_inset

, the authors takes a different approach to optimization, disregarding the
 model altogether.
 Using automatically generated 
\emph on
program variants
\emph default
, finding an optimal program can be reduced to a searching problem within
 a 
\emph on
variant space
\emph default
.
 
\end_layout

\begin_layout Standard
The authors considers instruction alignment of functions and global variables
 as the variant space.
 New program variants are generated by inserting alignment directives in
 the assembly, changing the memory address of each function or variable
 independently.
 A subset of program variants are generated, and evaluated by measuring
 execution time.
 Using blind optimization, the authors are able to achieve up to 12.6 % speedup
 on some SPEC benchmarks, compared to compiler optimized code.
 
\end_layout

\begin_layout Standard
A related concept to blind optimization is 
\emph on
feedback directed optimization
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "Smith:2000:FeedbackDirectedOptimization"

\end_inset

.
 The idea behind this technique is for compilers to use empirical data to
 determine the optimal optimization parameters to apply.
 Parameters are determined through multiple iterations of compiling and
 profiling.
 This is useful for instance in determining the number of loop iterations
 to unroll, different register allocations, and code layout.
 
\end_layout

\begin_layout Subsection
Assembly-Level Optimizations
\end_layout

\begin_layout Standard
Recognizing that current hardware models are lacking, Hundt et al.
 
\begin_inset CommandInset citation
LatexCommand cite
key "Hundt:2011:MAO"

\end_inset

 presents MAO, an 
\begin_inset Quotes eld
\end_inset

Extensible Micro-Architectural Optimizer
\begin_inset Quotes erd
\end_inset

.
 This is an assembly-to-assembly translator, containing architecture-specific
 rules to optimize machine code emitted by the compiler for x86 and x86-64
 architectures.
 Many rules attempt to fix 
\begin_inset Quotes eld
\end_inset

sloppy
\begin_inset Quotes erd
\end_inset

 code generated by GCC (or other compilers), for instance redundant test
 instructions.
 The following example can be shortened by removing the last instruction,
 as condition flags are set implicitly by the 
\family typewriter
sub
\family default
 instruction.
 
\end_layout

\begin_layout Quote
\begin_inset listings
lstparams "basicstyle={\ttfamily},language={[x86masm]Assembler}"
inline false
status open

\begin_layout Plain Layout

sub   16, %rax
\end_layout

\begin_layout Plain Layout

test  %rax, %rax
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Many more of these rules are encoded in MAO, resulting in reduced code size
 and use of more efficient instructions.
 
\end_layout

\begin_layout Standard
In addition to optimizing for the ISA, the code is also tuned for specific
 properties of Intel microarchitectures.
 As an example, MAO considers instruction address alignment for hot loops,
 inserting additional alignment directives if necessary.
 By aligning frequently executed code segments to 16 byte boundaries, the
 instructions are more likely to fit in decode 
\begin_inset Quotes eld
\end_inset

chunks
\begin_inset Quotes erd
\end_inset

, which are 16 B on the Intel Core 2.
 In previous work on measurement bias by Mytkowitcz et al, the Loop Stream
 Detector is suggested as a potential cause of bias.
 The authors identifies that this hardware optimization depends on 16 byte
 instruction alignment on the Core 2 architecture.
 MAO uses this knowledge to align code to fit in as few decode chunks as
 possible, allowing the LSD to kick in and avoid instruction fetch for some
 hot loops.
 Another interesting architecture specific optimization considers available
 execution ports in the Core 2 when scheduling instructions.
 
\end_layout

\begin_layout Standard
Inspired by the blind optimization technique introduced by Knights et al.
 
\begin_inset CommandInset citation
LatexCommand cite
key "Knights:2009:BlindOpt"

\end_inset

, MAO also attempts to insert 
\family typewriter
nop
\family default
 instructions at random.
 This has the effect of moving surrounding code around, possibly hitting
 some optimal configuration not modeled or caught by any of the other optimizati
ons.
 
\end_layout

\begin_layout Standard
This paper is particularly interesting, because it shows that modeling complex
 hardware mechanisms is in fact feasible.
 By encoding highly architecture-specific knowledge on things like optimal
 instruction alignment, the authors are able to improve on compiler-optimized
 code.
 
\end_layout

\begin_layout Section
Hardware and Performance Monitoring
\end_layout

\begin_layout Standard
Bias effects generally depend on specific processor features, and 
\begin_inset Quotes eld
\end_inset

performance cliffs
\begin_inset Quotes erd
\end_inset

 caused by them.
 A rudimentary understanding of the underlying hardware is necessary in
 order to understand why performance varies during different execution contexts.
 We limit our study to the Intel Core 
\begin_inset Quotes eld
\end_inset

Ivy Bridge
\begin_inset Quotes erd
\end_inset

, currently the most recent Intel architecture.
 Of course, a comprehensive introduction to the inner working of any processor
 is way beyond the scope of this thesis.
 Instead, we will provide a brief overview of some architectural features,
 and in particular those that might cause bias due to differences in virtual
 memory layout.
 For a general introduction to concepts in computer architecture, refer
 to 
\begin_inset CommandInset citation
LatexCommand cite
key "Patterson:2011:ComputerOrganization"

\end_inset

.
\end_layout

\begin_layout Standard
To gain accurate measurements and diagnostics, we will use hardware performance
 counters.
 Intel architectures have extensive monitoring capabilities, and we give
 a brief overview of how this can be utilized.
\end_layout

\begin_layout Subsection
\begin_inset Quotes eld
\end_inset

Ivy Bridge
\begin_inset Quotes erd
\end_inset

 Microarchitecture
\end_layout

\begin_layout Standard
The name 
\begin_inset Quotes eld
\end_inset

Ivy Bridge
\begin_inset Quotes erd
\end_inset

 is a code name for what is also referred to as the 
\begin_inset Quotes eld
\end_inset

3rd Generation Intel Core Microarchitecture
\begin_inset Quotes erd
\end_inset

, or alternatively 
\begin_inset Quotes eld
\end_inset

Intel Core Microarchitecture Code Name Ivy Bridge
\begin_inset Quotes erd
\end_inset

.
 These are the terms that are used in the manuals, but we will refer to
 architectures mostly by code name throughout the rest of the thesis.
 Preceding Ivy Bridge is 
\begin_inset Quotes eld
\end_inset

2nd Generation Intel Core Microarchitecture
\begin_inset Quotes erd
\end_inset

 with code name 
\begin_inset Quotes eld
\end_inset

Sandy Bridge
\begin_inset Quotes erd
\end_inset

.
 Many of the architectural features found in Ivy Bridge can also be found
 in Sandy Bridge and earlier Core architectures.
 
\end_layout

\begin_layout Standard
For our purposes, a general overview and idea of what happens during program
 execution is sufficient.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:pipeline"

\end_inset

 shows a high level view of the processor pipeline, consisting of a front
 end, out of order engine, execution core, and cache hierarchy.
 We will give a brief overview of each component, while a comprehensive
 reference can be found in the vendor manuals 
\begin_inset CommandInset citation
LatexCommand cite
key "Intel:2013:Volume1,Intel:2012:OptimizationManual"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Img/intel/pipeline.eps

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:pipeline"

\end_inset

Ivy Bridge pipeline, adapted from 
\begin_inset CommandInset citation
LatexCommand cite
key "Intel:2012:OptimizationManual"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Front End
\end_layout

\begin_layout Standard
The front end is responsible for fetching and decoding instructions, feeding
 the execution pipeline with a constant stream of micro-operations.
 The branch predictor is used to fetch instructions speculatively, along
 the most likely path of execution.
 
\end_layout

\begin_layout Standard
There is an important distinction between IA-32 (or Intel 64) instructions
\begin_inset Foot
status open

\begin_layout Plain Layout
Intel uses IA-32 and Intel 64 for what is also commonly known as x86 and
 x86-64 instruction set architectures.
 We will use these terms interchangeably.
\end_layout

\end_inset

 and 
\emph on
micro-operations
\emph default
 (
\begin_inset Quotes eld
\end_inset

micro-ops
\begin_inset Quotes erd
\end_inset

): Assembly instructions emitted by a compiler are decoded into micro-operations
 used internally in the processor.
 The x86 ISA is a 
\emph on
complex
\emph default
 instruction set computer (CISC) architecture, as opposed to a 
\emph on
reduced
\emph default
 instruction set architecture (RISC).
 Complex instruction set architectures support more sophisticated operations,
 such as combinations of memory accesses and arithmetic operations in a
 single instruction 
\begin_inset CommandInset citation
LatexCommand cite
key "Patterson:2011:ComputerOrganization"

\end_inset

.
 For historical reasons and sake of backwards compatibility, the x86 instruction
 set has been constantly expanded with new functionality.
 To manage the complexity of a CISC ISA, the processor reduces complicated
 instructions to much simpler micro-operations internally.
 The micro-operations allow the processor to be organized more like a RISC
 architecture internally.
\end_layout

\begin_layout Standard
Decoding assembly instructions is a costly operation in hardware, and a
 lot of logic in the front end is dedicated to avoid this stage as much
 as possible.
 The Decoded ICache is a cache holding recently executed micro-operations,
 containing up to 1526 entries.
 When the next block of code to execute is determined by the branch predictor,
 the micro-op cache is searched first.
 Intel claims that typical hit rates exceed 80 %, and approaching 100 %
 for hot spots 
\begin_inset CommandInset citation
LatexCommand cite
key "Intel:2012:OptimizationManual"

\end_inset

.
 If not found in the micro-op cache, the 
\begin_inset Quotes eld
\end_inset

legacy
\begin_inset Quotes erd
\end_inset

 fetch-decode pipeline is used.
 New blocks of instruction memory goes through several decode stages, before
 finally being ready to execute as micro-ops.
 To fill 
\begin_inset Quotes eld
\end_inset

holes
\begin_inset Quotes erd
\end_inset

 in the instruction stream, a queue of micro-ops sits between the front
 end and the rest of the pipeline.
 
\end_layout

\begin_layout Paragraph
Macro-Fusion
\end_layout

\begin_layout Standard
To increase the number of instructions that can be executed each cycle,
 pairs of instructions can sometimes be fused by the front-end into one
 equivalent, more complex, operation.
 With macro-fusion, certain pairs of assembly instructions can be combined
 to a single micro-operation.
 This is restricted to pairs where the first instruction modifies condition
 flags (such as 
\family typewriter
test
\family default
 or 
\family typewriter
cmp
\family default
), and the other is a conditional jump.
 Pairs like these appear often in practice, improving the instructions per
 cycle metric when macro fusion is applied.
\end_layout

\begin_layout Paragraph
Loop Stream Detector
\end_layout

\begin_layout Standard
The Loop Stream Detector is, with some restrictions, able to detect software
 loops in the micro-op stream.
 It analyzes micro-ops residing in the Micro-op Queue, and identifies chains
 of repeatedly executed operations.
 When a loop is detected, the LSD locks the micro-ops in the queue, disabling
 any further ICache lookup as well as the whole decode pipeline.
 Micro-ops are streamed directly from the queue, until a branch mispredict
 causes normal operation to resume.
 This optimization can save power by disabling logic, but also give a performanc
e gain in cases where the front end is a bottleneck.
\end_layout

\begin_layout Subsubsection*
Out-of-Order Engine and Execution Core
\end_layout

\begin_layout Standard
One of the key features of modern processors is instruction level parallelism.
 A great amount of logic is dedicated to be able to issue multiple instructions
 per cycle, increasing the throughput.
 Micro-ops are delivered sequentially and in-order from the front end.
 The out-of-order engine then views the stream of micro-ops as a 
\emph on
dataflow
\emph default
 problem.
 A window of available micro-ops are analyzed for potential data dependencies,
 and issued for execution accordingly.
 Multiple operations can be issued simultaneously, as long as there are
 no dependency violations.
 There are six execution ports, giving a maximum of six micro-operations
 issued by the scheduler each cycle.
 
\end_layout

\begin_layout Subsubsection*
Cache Hierarchy
\end_layout

\begin_layout Standard
Each processor core has an L1 data and instruction cache of 32 KiB each,
 and a unified L2 cache of 256 KiB holding both data and instructions.
 An L3 cache of 8 MiB, also known as last level cache (LLC), is shared among
 all cores via a ring connection.
 
\end_layout

\begin_layout Paragraph
Store Forwarding
\end_layout

\begin_layout Standard
If a load follows a store to the same memory location, the store value can
 be forwarded to the load operation.
 Store forwarding avoid accesses to data cache, allowing loads to execute
 faster.
\end_layout

\begin_layout Paragraph
Memory Disambiguation
\end_layout

\begin_layout Standard
In cases where a store operation is followed by load, there is a dependency
 if both instructions refer to the same memory address.
 The processor can not safely issue the load operation before the store
 (out of order) until the addresses are calculated, and determined to not
 overlap.
 A conservative approach is to block all load instructions until previous
 store addresses are resolved.
 With 
\emph on
memory disambiguation
\emph default
, the hardware makes a prediction about whether a conflict will occur, schedulin
g loads speculatively 
\begin_inset CommandInset citation
LatexCommand cite
key "Intel:2006:InsideICM:SmartMemoryAccess,Intel:2006:InsideICM:EnergyEfficientPerformance"

\end_inset

.
 Loads that are predicted not to have any dependencies are allowed to read
 data from L1 cache, before previous store addresses are resolved.
 The predictions are later verified before retirement, re-executing instructions
 that were affected by actual conflicts.
 
\end_layout

\begin_layout Standard
Load and store buffers hold the values of speculatively executed memory
 operations, sometimes collectively referred to as Memory Order Buffer.
 
\end_layout

\begin_layout Subsection
Performance Counters
\end_layout

\begin_layout Standard
Hardware performance counters are special-purpose registers that can be
 configured to 
\emph on
count
\emph default
 various hardware events.
 Dedicated Performance Monitoring Unit (PMU) hardware can be programmed
 to count things like cycle count, number of branch misses, or retired micro-ope
rations.
 Performance counter metrics are commonly used for detailed tuning and profiling
 of software.
 
\end_layout

\begin_layout Standard
\noindent
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begingroup
\backslash
tabcolsep=3pt
\backslash
begin{small}
\end_layout

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="4">
<features booktabs="true" tabularvalignment="middle" tabularwidth="100text%">
<column alignment="center" valignment="top" width="7text%">
<column alignment="center" valignment="top" width="10text%">
<column alignment="left" valignment="top" width="34text%">
<column alignment="left" valignment="top" width="42text%">
<row>
<cell alignment="center" valignment="bottom" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Event
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="bottom" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Umask
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="bottom" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Mnemonic
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Description
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x3C
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x00
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CPU_CLK_UNHALTED.
 THREAD_P
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Counts the number of thread cycles while the thread is not in a halt state
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
C0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
00
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
INST_RETIRED.ANY_P
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Number of instructions at retirement
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
A2 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
01
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
RESOURCE_STALLS.ANY
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Cycles Allocation is stalled due to Resource Related reason
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{small}
\backslash
endgroup
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:example-performance-counters"

\end_inset

Examples of performance counters available on Ivy Bridge.
 The official reference can be found in 
\begin_inset CommandInset citation
LatexCommand cite
key "Intel:2013:Volume3B"

\end_inset

, and a collection of the most relevant events for this thesis is included
 in Appendix 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:list-of-performance-counters"

\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Performance events are identified by two numbers, called 
\emph on
event code
\emph default
 and 
\emph on
unit mask
\emph default
.
 Events are also referred to by names, or 
\emph on
mnemonics
\emph default
.
 A few examples are listed in Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:example-performance-counters"

\end_inset

, including 
\shape smallcaps
cpu_clk_unhalted.thread_p
\shape default
 counting number of cycles, and 
\shape smallcaps
inst_retired.any_p
\shape default
 for counting number of dynamic instructions executed.
 About 200 different events are available on Ivy Bridge 
\begin_inset CommandInset citation
LatexCommand cite
key "Intel:2013:Volume3B"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Img/intel/msr.eps

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:msr"

\end_inset

Performance event select register.
 Adapted from 
\begin_inset CommandInset citation
LatexCommand cite
key "Intel:2013:Volume3B"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Counters are configured up by writing to 32 bit 
\emph on
event select
\emph default
 registers.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:msr"

\end_inset

 illustrates the bit field for initializing counters on Ivy Bridge.
\end_layout

\begin_layout Itemize
Unit mask and event code are written to the lower two least significant
 bytes.
 As an example, looking at Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:example-performance-counters"

\end_inset

 we find the values for 
\shape smallcaps
instr_retired.
 any_p
\shape default
 to be 0xC0 and 0x00 respectively.
\end_layout

\begin_layout Itemize
The remaining bits can be toggled to impose various constraints on what
 is counted.
 We will typically toggle OS mode and user mode such that statistics is
 reported from code executing in user mode only.
 Counters are updated each cycle, adding the number of event occuring to
 a cumulative value.
 An 
\emph on
invert
\emph default
 bit can be set to count cycles where an event does 
\emph on
not
\emph default
 occur.
 
\end_layout

\begin_layout Itemize
On each cycle, the event count is compared to the value specified for counter
 mask (CMASK).
 The performance counter is not incremented if the value is below what is
 specified for counter mask.
 For instance, counting 
\shape smallcaps
instr_ret- ired.any_p
\shape default
 with a counter mask of 2, will count the number of cycles where at least
 two instructions are retired.
\end_layout

\begin_layout Standard
On Ivy Bridge, there are three 
\emph on
fixed
\emph default
 and eight 
\emph on
general-purpose
\emph default
 counter registers, for a maximum of 11 performance events monitored simultaneou
sly.
 The fixed counters are set to count 
\shape smallcaps
instr_retired.any
\shape default
, 
\shape smallcaps
cpu_clk_unhalted.core
\shape default
 and 
\shape smallcaps
cpu_clk_unhalted.ref
\shape default
.
 With some restrictions, the remaining general-purpose registers can be
 programmed to count arbitrary events.
 The official documentation of available performance counters and their
 usage can be found in Volume 3B of the Software Developer's Manual 
\begin_inset CommandInset citation
LatexCommand cite
key "Intel:2013:Volume3B"

\end_inset

.
 A shorter reference is included in Appendix 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:list-of-performance-counters"

\end_inset

, listing only counters that are relevant to the discussion throughout the
 remainder of this thesis.
 
\end_layout

\begin_layout Subsection
Using 
\family typewriter
perf
\end_layout

\begin_layout Standard
There are multiple ways of accessing the processor's performance monitoring
 facilities from software.
 Support is needed from the operating system, as kernel mode privileges
 are needed to manage the low level PMU hardware.
 Linux systems provide a kernel interface called 
\emph on
perf_events
\emph default
, which can be used along with the perf
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
perf
\family default
: Linux profiling with performance counters, 
\begin_inset CommandInset href
LatexCommand href
name "https://perf.wiki.kernel.org"
target "https://perf.wiki.kernel.org/index.php/Main_Page"

\end_inset


\end_layout

\end_inset

 tool.
 Perf is a utility program for interfacing performance counters from user
 code on Linux.
 It is relatively easy to use, with support for many performance counters
 by mnemonics such as 
\begin_inset Quotes eld
\end_inset

cycles
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

instructions
\begin_inset Quotes erd
\end_inset

, and 
\begin_inset Quotes eld
\end_inset

branch-misses
\begin_inset Quotes erd
\end_inset

.
 We will mostly use the 
\family typewriter
stat
\family default
 command, which takes a list of performance counters and a program to benchmark
 as arguments.
 As an example, the following command reports the total cycle count from
 executing ls (listing files and directories).
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

perf stat -e cycles ls
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We will in some cases be using the output format directly when presenting
 measurements.
 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily}"
inline false
status open

\begin_layout Plain Layout

 Performance counter stats for 'ls':
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

         1,748,096 cycles
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

       0.000731187 seconds time elapsed
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Not all counters are available as mnemonics.
 Arbitrary performance events can be used by specifying their respective
 unit mask and event code, available in the documentation 
\begin_inset CommandInset citation
LatexCommand cite
key "Intel:2013:Volume3B"

\end_inset

.
 Perf uses the event select bit-format fairly explicitly, meaning we can
 provide a hexadecimal number corresponding to the desired register value
 to specify which counter to use.
 The perf code for 
\shape smallcaps
resource_stalls.any
\shape default
 is 
\family typewriter
r01A2
\family default
, with 0x01 and 0xA2 for unit mask and event code respectively.
 An initial 'r' character signifies that a 
\begin_inset Quotes eld
\end_inset

raw
\begin_inset Quotes erd
\end_inset

 counter value is specified.
 The user mode bit can be toggled by appending a 'u' character, as in 
\family typewriter
event:u
\family default
.
 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

perf stat -e r01a2:u ls
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Simply concatenating unit mask and event code and appending a trailing 
\family typewriter
:u
\family default
 is what we want to do in most cases.
\end_layout

\begin_layout Section
The Execution Context
\end_layout

\begin_layout Standard
In order to understand why bias effects occur, it is necessary to look at
 some of the low-level aspects of how processes and memory is managed by
 the operating system.
 In particular, we will see that changes to memory layout in virtual address
 space is an important factor.
 Some knowledge of ELF executables and virtual memory is necessary for the
 remainder of the thesis.
 We will provide a brief overview of how code and data is mapped to virtual
 memory on 64 bit Linux systems.
 For a more comprehensive reference to topics in operating systems, refer
 to 
\begin_inset CommandInset citation
LatexCommand cite
key "Tanenbaum:2008:ModernOperatingSystems"

\end_inset

.
\end_layout

\begin_layout Subsection
Virtual Memory Layout
\end_layout

\begin_layout Standard
Virtual memory is an abstraction over the physical memory (RAM), allowing
 every program operate within its own isolated address space.
 Virtual addresses are organized into 
\emph on
pages
\emph default
 of 4 KiB
\begin_inset Foot
status open

\begin_layout Plain Layout
To avoid any confusion with SI units, we will use KiB (kibibyte), MiB etc
 for numbers with base 2.
 1 KiB is 1024 bytes, 1 MiB is 1024 KiB, and so on.
\end_layout

\end_inset

, and a 
\emph on
page table
\emph default
 managed by the operating system defines a mapping to 
\emph on
frames
\emph default
 in physical memory 
\begin_inset CommandInset citation
LatexCommand cite
key "Tanenbaum:2008:ModernOperatingSystems"

\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Img/unix-vm-all.eps

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:virtual-address-space"

\end_inset

Organization of virtual memory of a running process on a typical 64 bit
 Linux system
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
On 64-bit machines, addresses range from 
\begin_inset Formula $0$
\end_inset

 to 
\begin_inset Formula $2^{64}$
\end_inset

.
 A running process is divided into several sections within the virtual address
 space, the most important being stack, heap, bss, data and text, as illustrated
 in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:virtual-address-space"

\end_inset

.
\end_layout

\begin_layout Description
stack Stack frames, containing function parameters and local variables.
 Located somewhere around the top (address 0x7fff'ffffffff) and expanding
 downwards.
\end_layout

\begin_layout Description
heap Dynamically allocated area.
 Located above the uninitialized data segment (bss), and growing upwards
 as more space is required.
 Calls to 
\family typewriter
malloc
\family default
 and related functions can be used to request heap memory.
\end_layout

\begin_layout Description
bss Uninitialized data, containing variables with no value specified.
 This area is implicitly initialized to zero, thus only the size needs to
 be stored in the executable file.
 
\end_layout

\begin_layout Description
data Initialized data, variables that have some assigned value at compile
 time.
 This section is read from the executable file and copied to virtual memory.
\end_layout

\begin_layout Description
text Executable binary code, located at the lower end of the virtual address
 space.
 This section is also stored in the executable.
\end_layout

\begin_layout Standard
Note that effectively only 48 out of 64 available bits are used for addressing.
 The lower 0x0 through 0x7fff'ffffffff is addressable to user programs,
 while the upper segment of addresses from 0xffff8000'00000000 through 0xfffffff
f'ffffffff is reserved for the operating system.
 This leaves a large gap of addresses that are not used, as current hardware
 does not actually support addressing the whole 64 bit range 
\begin_inset CommandInset citation
LatexCommand cite
key "Lomont:2012:x64Assembly"

\end_inset

.
\end_layout

\begin_layout Subsubsection*
Executable File Format
\end_layout

\begin_layout Standard
Modern Unix systems represent executable program files in the Executable
 and Linkable Format (ELF) 
\begin_inset CommandInset citation
LatexCommand cite
key "SystemVABI"

\end_inset

.
 The same format also handles object files (.o) and shared libraries (.so).
 The different steps in a typical compilation process leading up to an ELF
 executable is shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:elf"

\end_inset

.
 One or more source files (for example written in C) are first translated
 to assembly code by a compiler.
 An assembler translates the assembly code to machine code, wrapped in an
 ELF file format.
 Multiple object files can be linked together, forming a single executable
 file.
 The linker resolves any symbols and dependencies between the object files.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Img/elf/compilation.eps

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:elf"

\end_inset

Overview of important steps of the compilation process
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
ELF files is structured in a set of sections, such as 
\begin_inset Quotes eld
\end_inset

.text
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

.data
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

.symtab
\begin_inset Quotes erd
\end_inset

.
 Some sections are 
\emph on
allocable
\emph default
, meaning their contents are copied into virtual memory before the program
 is executed.
 An example of an allocable section is the text area, which contains all
 the executable machine code.
 The data section is also allocable, typically storing things like constants
 and initialized static variables.
 Virtual addresses of code or data stored in allocable section are determined
 statically, and can be found by reading the contents of the ELF file.
 The following example shows disassembly of the first few instruction in
 the main function of a program, which in this case starts at address 0x400544
 
\begin_inset Foot
status open

\begin_layout Plain Layout
Output is generated using the objdump utility, part of GNU Binary Utilities.
 readelf is another useful program for analyzing ELF files.
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily}"
inline false
status open

\begin_layout Plain Layout

0000000000400544 <main>:
\end_layout

\begin_layout Plain Layout

  400544:	55                   	push   %rbp
\end_layout

\begin_layout Plain Layout

  400545:	48 89 e5             	mov    %rsp,%rbp
\end_layout

\begin_layout Plain Layout

  400548:	48 83 ec 10          	sub    $0x10,%rsp
\end_layout

\begin_layout Plain Layout

  40054c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
\end_layout

\begin_layout Plain Layout

  400553:	bf 04 00 00 00       	mov    $0x4,%edi
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Before a program can be executed, it needs to be loaded into virtual memory
 in some way.
 The ELF executable file includes the path to an interpreter, a program
 that is responsible for loading code and data, setting up a stack, and
 loading any dependencies.
 Files compiled for execution on a 64 bit Linux platform will typically
 point to a loader in 
\family typewriter
/lib64/ld-linux-x86-64.so.2
\family default
.
 This file can be a symbolic link to the actual program.
 
\end_layout

\begin_layout Standard
The loader maps each allocable section of the object file into virtual address
 space, such as the text and data areas.
 Stack, heap and bss areas are initialized, resulting in a process image
 like the one shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:virtual-address-space"

\end_inset

.
 Dynamically linked and shared libraries are mapped into virtual memory
 as well, appearing somewhere between the stack and heap segments.
\end_layout

\begin_layout Subsubsection*
Address Space Layout Randomization (ASLR)
\end_layout

\begin_layout Standard
The process of mapping sections to virtual memory is in most cases not determini
stic.
 If addresses can be known a priori, programs will be more vulnerable to
 buffer overflow attacks 
\begin_inset CommandInset citation
LatexCommand cite
key "Shackham:2004:ASLR"

\end_inset

.
 If an attacker manages to inject malicious code, he can use the known virtual
 addresses to access data or call specific functions.
 One technique known as 
\begin_inset Quotes eld
\end_inset

return to libc
\begin_inset Quotes erd
\end_inset

 attacks uses this knowledge to call functions in the C standard library,
 which will be loaded in most scenarios.
 If dynamic libraries are always mapped to the same range of virtual addresses,
 locations of functions in libc can be easily determined.
\end_layout

\begin_layout Standard
Address Space Layout Randomization is a technique employed by the operating
 system to make it more difficult to compromise programs.
 By default, the placement of stack, heap and location of dynamically linked
 libraries will vary between each run of a program.
 For a controlled execution environment, we will need to manually disable
 address randomization in many cases.
 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},language=bash"
inline false
status open

\begin_layout Plain Layout

$ sudo bash -c 'echo 0 > /proc/sys/kernel/randomize_va_space'
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The default value is 2, indicating full randomization
\begin_inset Foot
status open

\begin_layout Plain Layout
A description of the different values can be found in the documentation
 for sysctl, 
\begin_inset CommandInset href
LatexCommand href
name "https://www.kernel.org/doc/Documentation/sysctl/kernel.txt"
target "https://www.kernel.org/doc/Documentation/sysctl/kernel.txt"

\end_inset


\end_layout

\end_inset

.
 To disable heap randomization only, a value of 1 can be written instead.
 We will use zero to disable all randomization, making virtual memory layout
 completely deterministic between each run.
 
\end_layout

\begin_layout Subsubsection*
Environment Variables
\end_layout

\begin_layout Standard
As discussed in previous work on measurement bias 
\begin_inset CommandInset citation
LatexCommand cite
key "Mytkowicz:2009:WrongData"

\end_inset

, the size of a user's Unix environment variable can affect the placement
 of stack.
 Environment variables are allocated above the stack, pushing the initial
 stack address downwards.
 Because of this, the position of stack can be manipulated by manually changing
 environment variables.
\end_layout

\begin_layout Subsection
Memory Context of C Programs
\end_layout

\begin_layout Standard
C will be the programming language of choice throughout the remainder of
 the thesis, as it is both widely known and provides only a thin layer of
 abstraction over virtual memory.
 The program in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:c-context"

\end_inset

 contains four variables, utilizing both initialized and uninitialized data,
 dynamically allocated data on heap, and stack allocated variables.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},breaklines=true,language=C,showstringspaces=false"
inline false
status open

\begin_layout Plain Layout

#include <stdlib.h>
\end_layout

\begin_layout Plain Layout

#include <stdio.h>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

static int a;      /* .bss */
\end_layout

\begin_layout Plain Layout

static int b = 42; /* .data */
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main() {
\end_layout

\begin_layout Plain Layout

    int c = 0;     /* .stack */
\end_layout

\begin_layout Plain Layout

    int *d = malloc(sizeof(int)); /* .heap */
\end_layout

\begin_layout Plain Layout

    printf("stack: %p heap: %p bss: %p data: %p 
\backslash
n", &c, d, &a, &b);
\end_layout

\begin_layout Plain Layout

    return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:c-context"

\end_inset

Simple C program with data allocated in four different segments of virtual
 memory
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Variable 
\family typewriter
c
\family default
 and 
\family typewriter
d
\family default
 are stack-allocated 
\emph on
automatic
\emph default
 variables 
\begin_inset CommandInset citation
LatexCommand cite
key "Kernighan:1988:CProgrammingLanguage"

\end_inset

.
 Their run-time addresses depend on where the stack segment is initialized
 in virtual memory, and can in general not be known ahead of time.
\end_layout

\begin_layout Itemize
The address returned by malloc and stored in variable 
\family typewriter
d
\family default
, points to a location on the heap.
 The exact address depends on the implementation of malloc, as well as the
 initial position of the heap segment, and is also impossible to predict
 in general.
 
\end_layout

\begin_layout Itemize
Global variables 
\family typewriter
a
\family default
 and 
\family typewriter
b
\family default
 should be placed in bss and data segments respectively.
 Variable 
\family typewriter
a
\family default
 is not explicitly initialized, thus it is not necessary to store any value
 in the executable file.
 The C standard specifies that static variables are guaranteed to be initialized
 to zero 
\begin_inset CommandInset citation
LatexCommand cite
key "Kernighan:1988:CProgrammingLanguage"

\end_inset

, which will happen by default if allocated in the bss segment.
 The value 42 is allocated for variable 
\family typewriter
b
\family default
 in the data section of the executable.
 Virtual addresses of static variables are determined at compile time, and
 can be found in the ELF object file's symbol table 
\begin_inset CommandInset citation
LatexCommand cite
key "SystemVABI"

\end_inset

.
 
\end_layout

\begin_layout Standard
Executing the same program multiple times with ASLR enabled will yield different
 output for stack and heap addresses.
 Each variation constitutes a different execution context, with potentially
 different performance characteristics.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily}"
inline false
status open

\begin_layout Plain Layout

stack: 0x7fffffffe1ec heap: 0x602010 bss: 0x601040 data: 0x601028
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Methodology and Experimental Setup
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "chap:Methodology"

\end_inset

This chapter presents the test setup and experimental methodology used throughou
t the rest of this thesis.
 When studying bias effects, carefully controlling all relevant properties
 of the environment is crucial.
 We first describe how our test machine is configured with respect to operating
 system settings, and use of 
\begin_inset Quotes eld
\end_inset

best practices
\begin_inset Quotes erd
\end_inset

 in performance analysis.
 Methods used for aquiring and analyzing performance counter measurements
 is also described.
\end_layout

\begin_layout Section
Setup and Configuration
\end_layout

\begin_layout Standard
Measurement bias is by definition a product of variations in the execution
 environment.
 To produce reliable results, we need to properly control every variable
 that can affect measurements.
 We make the following configuration to our experimental setup:
\end_layout

\begin_layout Itemize
Unless specified otherwise, address space layout randomization (ASLR) is
 kept disabled.
 This is necessary when testing effects from changing memory context, and
 often required to make results reproducible.
\end_layout

\begin_layout Itemize
Hyper threading is disabled, ensuring that only one thread runs simultaneously
 on each core.
 Two threads competing on hardware resources is another potential source
 of bias, which we will not be studying.
 
\end_layout

\begin_layout Itemize
System load is kept at a minimum to avoid interference with other processes
 and tasks.
 
\end_layout

\begin_layout Itemize
Automatic CPU frequency scaling is disabled, keeping the clock speed constant.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Processor
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Intel® Core™ i7-3770 @ 3.40 GHz
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Family: 0x06, Model: 0x3A
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Memory
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16 GB @ 1333 MHz
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Operating System
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
64-bit Ubuntu 12.04 LTS (3.2.0-41)
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Toolchain
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
GCC 4.6.3 (Ubuntu/Linaro 4.6.3-1ubuntu5)
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:machine"

\end_inset

Experimental setup
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Hardware and software configuration of our test machine is shown in Table
 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:machine"

\end_inset

.
 It features an Intel Core i7-3770 
\begin_inset Quotes eld
\end_inset

Ivy Bridge
\begin_inset Quotes erd
\end_inset

 processor and 16 GB RAM.
 The operating system is Ubuntu version 12.04, which at the time of writing
 is the most recent release with long term support.
 We use GCC version 4.6.3 as our compiler toolchain.
 
\end_layout

\begin_layout Section
Performance Analysis
\end_layout

\begin_layout Standard
We use 
\family typewriter
perf stat
\family default
 to acquire hardware performance counter statistics, which should introduce
 minimal overhead and observer effect.
 In many cases we need to collect a large number of counters for the same
 program, while there is a limit to the number of performance counters collected
 simultaneously (see Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Background"

\end_inset

).
 We use a small test script to encapsulate repeated invocations of 
\family typewriter
perf stat
\family default
.
 Measurements are aggregated over several runs, enabling us to collect all
 of the about 200 performance counters available on our architecture 
\begin_inset CommandInset citation
LatexCommand cite
key "Intel:2013:Volume3B"

\end_inset

.
 The implementation can be found in Appendix 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:lperf"

\end_inset

.
 A reference to performance counters discussed in the remaining chapters
 can be found in Appendix 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:list-of-performance-counters"

\end_inset

.
 
\end_layout

\begin_layout Paragraph
Environment Size
\end_layout

\begin_layout Standard
Previous work points to changes in environment variable size as a cause
 of bias, and we will study this effect in detail.
 Unless otherwise specified, we use an empty environment for all out benchmarks
\begin_inset Foot
status open

\begin_layout Plain Layout
A completely emtpy environment is not possible, because 
\family typewriter
perf stat
\family default
 itself adds some variables to the environment
\end_layout

\end_inset

.
 A simple script is used for collecting performance counters under varying
 environment sizes.
 To measure statistics with 
\begin_inset Formula $n$
\end_inset

 bytes added to the environment, we set a dummy variable to 
\begin_inset Formula $0^{n}$
\end_inset

 (repeated zero characters 
\begin_inset Formula $n$
\end_inset

 times).
\end_layout

\begin_layout Paragraph
Correlation
\end_layout

\begin_layout Standard
Many experiments consists of collecting a large number of performance counter
 statistics over a series of different execution contexts, for example increment
ing environment variable size.
 To filter out events that are likely to explain any bias effects, we will
 use a 
\emph on
sample correlation coefficient
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "Walpole:2011:Statistics"

\end_inset

.
 The correlation coefficient is a numerical value between 
\begin_inset Formula $-1$
\end_inset

 and 
\begin_inset Formula $1$
\end_inset

, which can be used to determine the linear relationship between two data
 series 
\begin_inset Formula $X$
\end_inset

 and 
\begin_inset Formula $Y$
\end_inset

.
 Values close to 
\begin_inset Formula $+1$
\end_inset

 or 
\begin_inset Formula $-1$
\end_inset

 indicates strong positive or negative correlation, respectively, while
 values close to 0 indicate no correlation.
 With multiple series of performance counter measurements, a linear correlation
 coefficient serves as a crude indication of possible relationships between
 counter values.
 A particular useful metric in many cases is correlation between cycle count
 and other event counts.
\end_layout

\begin_layout Paragraph
Cache Analysis
\end_layout

\begin_layout Standard
Cache conflicts can in many cases be a potential explanation for bias effects
 observed by changing memory layout.
 If some memory configuration causes contention on a particular cache line,
 then repeated misses can reduce performance.
 Bias caused by cache issues is not the focus of this thesis.
 However, cache is generally a 
\emph on
likely
\emph default
 explanation of performance variations.
 In our experiments, we will carefully monitor various cache metrics in
 order to rule out cache as the underlying cause of bias.
 Relevant events include the hit rates of load micro-ops for each level
 of cache, which can be monitored by the following performance counters
 
\begin_inset CommandInset citation
LatexCommand cite
key "Intel:2012:OptimizationManual"

\end_inset

:
\end_layout

\begin_layout Itemize

\shape smallcaps
MEM_LOAD_UOPS_RETIRED.HIT_LFB_PS
\end_layout

\begin_layout Itemize

\shape smallcaps
MEM_LOAD_UOPS_RETIRED.L1_HIT_PS
\end_layout

\begin_layout Itemize

\shape smallcaps
MEM_LOAD_UOPS_RETIRED.L2_HIT_PS
\end_layout

\begin_layout Itemize

\shape smallcaps
MEM_LOAD_UOPS_RETIRED.LLC_HIT_PS
\end_layout

\begin_layout Itemize

\shape smallcaps
MEM_LOAD_UOPS_RETIRED.LLC_MISS_PS
\end_layout

\begin_layout Standard
Together, these events account for all cache accesses for load operations
 within a single core.
 Every cache access is either a 
\emph on
hit
\emph default
 in Line fill buffer, L1, L2 or L3, or an L3 
\emph on
miss
\emph default
.
  Changes to hit rates for different levels of cache is relevant when evaluating
 cache performance.
 Note that it is also possible for load operations to hit cache lines in
 other processor cores.
 This is scenario is mostly relevant for multithreaded applications, which
 we will not study.
 
\end_layout

\begin_layout Paragraph
Visualization
\end_layout

\begin_layout Standard
Plots are generated using Python's matplotlib package 
\begin_inset CommandInset citation
LatexCommand cite
key "Hunter:2007:Matplotlib"

\end_inset

, using the csv exported data from our test script.
\end_layout

\begin_layout Section
Approach
\end_layout

\begin_layout Standard
The purpose of this work is to investigate possible 
\emph on
causes
\emph default
 of measurement bias, and if possible how this can be used for optimization.
 We have chosen to approach this problem from two sides.
 In Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:SourcesOfBias"

\end_inset

, we present results from 
\emph on
experimental
\emph default
 work on smaller synthetic code examples.
 Simple examples are easier to analyze, allowing us to more accurately describe
 specific hardware mechanisms that results in bias.
 In previous work describing the effects of measurement bias, larger benchmark
 suites such as SPEC is often used.
 With large and complicated programs, it seems less likely that one will
 be able to identify why bias occurs.
 
\end_layout

\begin_layout Standard
Results and experiences from the experimental work is transferred to 
\emph on
case studies
\emph default
 in Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Case Studies"

\end_inset

.
 We choose to specifically look at already highly optimized numerical libraries,
 where any additional speedup from considering bias effects is more likely
 to be considered.
 With a detailed understanding of architectural features causing bias, we
 can look for specific effects in larger applications.
 
\end_layout

\begin_layout Chapter
Sources of Measurement Bias
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "chap:SourcesOfBias"

\end_inset

Modern microprocessors are extremely complex in design and functionality.
 Some features of recent Intel processors includes several layers of cache
 to camouflage slow memory, multiple prefetchers, speculative out-of-order
 execution and complicated branch prediction, just to name a few.
 Hardware features and optimizations interact with memory addresses of program
 code and data in various ways.
 In this chapter, we will unveil characteristics about two specific architectura
l features in Ivy Bridge, and show how they can bias performance towards
 certain memory contexts.
 First we will look at an 
\emph on
aliasing
\emph default
 effect between memory addresses of loads and stores, causing false dependencies
 in the out-of-order execution pipeline.
 This effect can be triggered for example by changing stack position, and
 can explain bias from altering environment variables.
 In previous work on measurement bias from link ordering, the 
\emph on
Loop Stream Detector
\emph default
 has been suggested as a possible explanation.
 We therefore choose to study this particular opimization in detail, and
 show how measurement bias can occur from changing code layout.
\end_layout

\begin_layout Section
Address Alias Effects (4K Aliasing)
\end_layout

\begin_layout Standard
An effect known as 
\begin_inset Quotes eld
\end_inset

4K aliasing
\begin_inset Quotes erd
\end_inset

 can occur when the addresses of a store instruction followed by a load
 instruction differ by a multiple of 4 KiB.
 Consider the following example, first writing a value to the memory address
 stored in %rax, before reading from the address stored in %rbx
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},language={[x86masm]Assembler}"
inline false
status open

\begin_layout Plain Layout

mov %r10, (%rax)
\end_layout

\begin_layout Plain Layout

mov (%rbx), %r11
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If for example %rax is 0x60
\series bold
1
\series default
010 and %rbx is 0x60
\series bold
4
\series default
010, the memory accesses are said to be aliased.
 The difference between the two addresses is 0x3000, which is a multiple
 of 4096, or 0x1000 in hexadecimal.
 The memory system issues load and store operations speculatively and out
 of order to increase throughput and parallelism.
 Some analysis is done to determine which operations are safe to issue out
 of order.
 In the above example, the processor could very well issue the load before
 the store, as they refer to different addresses.
 However, on recent Intel architectures only the last 12 address bits are
 used to determine if operations refer to the same address 
\begin_inset CommandInset citation
LatexCommand cite
key "Intel:2012:OptimizationManual"

\end_inset

.
 The last twelve bits of 0x601010 is 0x010, or 0000'0001'0000 in binary
 -- the same as for 0x604
\series bold
010
\series default
.
 Only doing a partial address compare, dependencies between load and store
 operations are sometimes falsely detected.
 These events can be counted by the following performance counter
\end_layout

\begin_layout Description
LD_BLOCKS_PARTIAL.ADDRESS_ALIAS False dependencies in Memory Order Buffer
 due to partial compare on address.
\end_layout

\begin_layout Standard
The Memory Order Buffer refers to a collection of load/store buffers within
 the L1 data cache.
 It buffers loads and stores of not yet retired instructions, enabling speculati
ve and out of order execution while ensuring that no dependencies are violated
 
\begin_inset CommandInset citation
LatexCommand cite
key "Doweck:InsideIntelCoreMicroarchitecture,Intel:2012:OptimizationManual"

\end_inset

.
 The optimization manual provides a more concrete explanation of the counter,
 stating it 
\begin_inset Quotes eld
\end_inset

Counts the number of loads that have partial address match with preceding
 stores, causing the load to be reissued
\begin_inset Quotes erd
\end_inset

.
 False dependencies due to address aliasing can have a negative effect on
 performance due to loads being reissued.
\end_layout

\begin_layout Paragraph
Intel Optimization Guidelines
\end_layout

\begin_layout Standard
Performance implications of 4K aliasing is discussed to some extent in the
 optimization manual from Intel.
 There are also some concrete suggestions for how to deal with it:
\end_layout

\begin_layout Quote

\series bold
\emph on
User/Source Coding Rule 8.
 (H impact, ML generality)
\series default

\begin_inset Newline newline
\end_inset

Consider using a special memory allocation library with address offset capabilit
y to avoid aliasing
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "Intel:2012:OptimizationManual"

\end_inset


\end_layout

\begin_layout Standard
This rule concerns heap allocated memory, which can be vulnerable to address
 aliasing if the implementation of for example malloc often returns memory
 with identical 12 bit address suffixes.
 This rule is classified as high (H) impact and medium/low generality, suggestin
g that it occurs relatively often, and with significant performance implications.
 In Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:heap-address-aliasing"

\end_inset

 we will study the effects of aliasing of heap allocated memory.
 Alternative allocator implementations is explored in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:dynamic-library-bias"

\end_inset

, identifying dynamic libraries as a potential source of measurement bias.
 
\end_layout

\begin_layout Standard
The second rule concering address aliasing introduces the concept of 
\emph on
padding
\emph default
 variable declarations.
 
\end_layout

\begin_layout Quote

\series bold
\emph on
User/Source Coding Rule 9.
 (M impact, M generality)
\series default
\emph default

\begin_inset Newline newline
\end_inset


\emph on
When padding variable declarations to avoid aliasing, the greatest benefit
 comes from avoiding aliasing on second-level cache lines, suggesting an
 offset of 128 bytes or more
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "Intel:2012:OptimizationManual"

\end_inset


\end_layout

\begin_layout Standard
Aliasing can in some cases be accounted for in software by explicitly handling
 memory location of variable declarations.
 We will use this technique to avoid aliasing for both stack- and heap allocated
 memory.
 Notice that Intel considers these as a 
\begin_inset Quotes eld
\end_inset

User/Source Coding
\begin_inset Quotes erd
\end_inset

 rules.
 This suggests that optimizing for address aliasing is something that should
 be considered not only by compilers, but also by programmers.
 
\end_layout

\begin_layout Paragraph
Outline
\end_layout

\begin_layout Standard
We will study the effects of 4K address aliasing through a set of examples
 and small case studies.
 The purpose is to show how aliasing can explain measurement bias.
 In Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:bias-from-stack-alignment"

\end_inset

 we connect address aliasing with changes to environment size -- showing
 how variations in stack addresses can trigger address collisions.
 Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:heap-address-aliasing"

\end_inset

 discusses common aliasing issues with heap allocated memory.
 We choose to focus on a limited set of concrete code examples, illustrating
 how aliasing can affect real programs.
 Additionally, we show how to use 
\emph on
padding
\emph default
 or similar techniques to programmatically avoid bias in each case.
 Finally, in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:dynamic-library-bias"

\end_inset

 we introduce dynamic libraries as another source of bias.
 In addition to environment variables, we find that different configurations
 or versions of memory allocators can cause measurement bias by triggering
 address aliasing.
 
\end_layout

\begin_layout Subsection
Bias from Environment Size
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sub:bias-from-stack-alignment"

\end_inset

As shown in previous work, changing the Unix environment variables can sometimes
 significantly affect program performance.
 It is typically not the content of environment variables that are important,
 but rather the effect their size has on stack position.
 Environment variables are allocated before the stack when programs are
 mapped into virtual memory, essentially offsetting all the following call
 frames and stack allocated variables.
 
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},language=C"
inline false
status open

\begin_layout Plain Layout

static int i, j, k;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main() {
\end_layout

\begin_layout Plain Layout

    int g = 0, inc = 1;
\end_layout

\begin_layout Plain Layout

    for (; g < 65536; g++) {
\end_layout

\begin_layout Plain Layout

        i += inc;
\end_layout

\begin_layout Plain Layout

        j += inc;
\end_layout

\begin_layout Plain Layout

        k += inc;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:loop-micro-kernel"

\end_inset

C program with bias towards certain stack positions
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Analysis of Micro Kernel
\end_layout

\begin_layout Standard
We begin by showing how address aliasing can explain measurement bias for
 the micro kernel presented in 
\begin_inset CommandInset citation
LatexCommand cite
key "Mytkowicz:2009:WrongData"

\end_inset

, reproduced here in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:loop-micro-kernel"

\end_inset

.
 This example is interesting for several reasons:
\end_layout

\begin_layout Itemize
The bias effects are significant and easily reproducible
\end_layout

\begin_layout Itemize
The example code is simple and easy to analyze
\end_layout

\begin_layout Itemize
No satisfactory explanation as to what causes bias was given in the original
 paper
\end_layout

\begin_layout Standard
As outlined in Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Methodology"

\end_inset

, we use perf and an automated script to collect performance counter statistics
 over a series of runs, incrementally increasing environment size using
 a dummy variable.
 The program is compiled using GCC with no optimization.
 Note that any optimization would likely disregard most of the function
 as redundant code, and reduce it to return zero immediately.
 Collecting the cycle count performance counter, we observe a distinct spike
 over a period of 16 bytes under increasing environment size.
 Illustrated in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:loop-cycles-only"

\end_inset

, the difference is over 20 % between the worst and best case.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Img/loop/cycles.eps

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:loop-cycles-only"

\end_inset

Performance variations from offsetting stack position by changing environment
 size
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
As a starting point in trying to analyze the potential cause for these effects,
 we look at data provided by other performance counters.
 We run the program several times under each environment configuration,
 collecting all available counters.
 The most interesting metrics are filtered out by linear correlation coefficient
, as described in Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Methodology"

\end_inset

.
 The set of counters that most closely follows the cycle count is shown
 in Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:loop-all-counters"

\end_inset

.
 Among all the performance counters supported on our architecture, only
 a few shows significant correlation to cycle count:
\end_layout

\begin_layout Standard
\begin_inset Float table
placement t
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{small}
\end_layout

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="13" columns="3">
<features booktabs="true" tabularvalignment="middle" tabularwidth="100text%">
<column alignment="left" valignment="top" width="60text%">
<column alignment="center" valignment="top" width="0">
<column alignment="decimal" decimal_point="." valignment="top" width="0">
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Performance Counter
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Perf code
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Correlation
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
UnHalted Core Cycles
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
cycles:u
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
UnHalted Reference Cycles
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
bus-cycles:u
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0.9999957522
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
LD_BLOCKS_PARTIAL.ADDRESS_ALIAS
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
r0107:u
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0.9941211321
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
RESOURCE_STALLS.ANY
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
r01a2:u
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0.9922818774
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
CYCLE_ACTIVITY.CYCLES_LDM_PENDING
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
r02a3:u
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0.9879579406
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
CPL_CYCLES.RING123
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
r025c:u
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0.9844339013
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
CYCLE_ACTIVITY.CYCLES_NO_EXECUTE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
r04a3:u
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0.9200557425
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
UOPS_DISPATCHED_PORT.PORT_4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
r40a1:u
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0.7546588979
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
UOPS_DISPATCHED_PORT.PORT_5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
r80a1:u
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
-0.5346383723
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
UOPS_DISPATCHED_PORT.PORT_1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
r02a1:u
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
-0.9308766294
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
UOPS_DISPATCHED_PORT.PORT_0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
r01a1:u
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
-0.9707469127
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
RESOURCE_STALLS.RS
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
r04a2:u
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
-0.986720269
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{small}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:loop-all-counters"

\end_inset

Performance counters with more than 0.3 positive or negative linear correlation
 to cycle count
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Address aliasing (
\shape smallcaps
ld_blocks_partial.address_alias
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
)
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 have a near perfect correlation, indicating that false memory dependencies
 causes a performance hit.
\end_layout

\begin_layout Itemize
Positive correlation with resource stalls supports the aliasing hypothesis.
 Loads blocked by preceding stores due to false dependence is likely generating
 stalls.
 
\shape smallcaps
resource_stalls.any
\shape default
 counts stalled cycles from 
\begin_inset Quotes eld
\end_inset

resource related reasons
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "Intel:2013:Volume3B"

\end_inset

.
 
\shape smallcaps
cycle_activity.cycles_ldm_pending
\shape default
 is a related metric, counting the number of cycles with pending memory
 loads.
 
\end_layout

\begin_layout Itemize
The remaining counters appears to be less interesting.
 
\shape smallcaps
cpl_cycles.ring123
\shape default
 and bus cycles will naturally correlate with cycle count.
 There are differences in the way micro-operations are scheduled between
 dispatch ports, which seems more like a by-product of the other events.
 
\end_layout

\begin_layout Standard

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:stack-alias-resource-plot"

\end_inset

 shows a plot of resource stalls, pending loads and alias, overlaid on cycle
 count.
 We see that 
\family default
\series default
\shape smallcaps
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
ld_blocks_partial.address_alias
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
 reports zero almost everywhere, and spiking in perfect correlation with
 cycle count.
 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
A higher amount of resource stalls and pending loads seems like a natural
 consequence of stalling due to aliasing.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Img/loop/correlation.eps

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:stack-alias-resource-plot"

\end_inset

Cycle count correlating with resource stalls, pending memory loads and address
 alias performance counter events.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
To find out which memory accesses collide, we need to know the memory addresses
 of each variable at run time.
 Referring to Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:loop-micro-kernel"

\end_inset

; statically allocated variables 
\family typewriter
i
\family default
, 
\family typewriter
j
\family default
 and 
\family typewriter
k
\family default
 have their virtual addresses determined at compile time, and are not affected
 by offsetting stack address.
 Inspecting the symbol table section of the ELF object file
\begin_inset Foot
status open

\begin_layout Plain Layout
Output is generated using the readelf utility, part of GNU Binary Utilities
\end_layout

\end_inset

, reveals that the addresses of i, j and k are 0x601028, 0x60102c and 0x601030,
 respectively.
 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily}"
inline false
status open

\begin_layout Plain Layout

Symbol table '.symtab' contains 66 entries:
\end_layout

\begin_layout Plain Layout

   Num:    Value          Size Type    Bind   Vis      Ndx Name
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    42: 0000000000601028     4 OBJECT  LOCAL  DEFAULT   25 i
\end_layout

\begin_layout Plain Layout

    43: 000000000060102c     4 OBJECT  LOCAL  DEFAULT   25 j
\end_layout

\begin_layout Plain Layout

    44: 0000000000601030     4 OBJECT  LOCAL  DEFAULT   25 k
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Variables 
\family typewriter
g
\family default
 and 
\family typewriter
inc
\family default
 are stack allocated local automatic variables, which will be affected by
 changing initial stack position.
 It is difficult to observe their correct addresses without introducing
 observer effects.
 Simply adding a call to printf for instance, completely changes the program
 behavior with respect to bias.
 Instead, we use a small amount of assembly code to calculate the addresses
 and print the numbers directly using system calls.
 We find that the spike in cycle count occurs when the address of 
\family typewriter
g
\family default
 and 
\family typewriter
inc
\family default
 are 0x7fffffffe028 and 0x7fffffffe02c, respectively.
 Note that the last twelve bits (three hexadecimal digits) for 
\family typewriter
g
\family default
 and 
\family typewriter
inc
\family default
 are the same as for 
\family typewriter
i
\family default
 and 
\family typewriter
j
\family default
.
 The two aliasing pairs are illustrated in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:stack-aliasing"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
\left(\text{g},\text{i}\right) & \rightarrow & \left(\text{0x7fffffffe028},\text{0x601028}\right)\\
\left(\text{inc},\text{j}\right) & \rightarrow & \left(\text{0x7fffffffe02c},\text{0x60102c}\right)
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Img/loop/memory-layout.eps

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:stack-aliasing"

\end_inset

With just the right environment size, stack allocated variables end up with
 the same address suffixes as static variables
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
There is a period of 16 byte of environment size where cycle count spikes
 (see Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:stack-alias-resource-plot"

\end_inset

).
 This can be explained by a default stack alignment of 16 byte in GCC, meaning
 addresses of stack variables will only change in multiples of 16.
 It is therefore impossible to have only 
\emph on
one
\emph default
 aliasing pair of variables.
 The next address suffixes of 
\family typewriter
g
\family default
 and 
\family typewriter
inc
\family default
 will be 0x0
\series bold
3
\series default
8 and 0x0
\series bold
3
\series default
c, aliasing with neither 
\family typewriter
i
\family default
, 
\family typewriter
j
\family default
 or 
\family typewriter
k
\family default
.
 The effect is 
\emph on
periodic
\emph default
; with increasing environment size, the spike in cycle count happens every
 4096 byte.
 
\end_layout

\begin_layout Subsubsection*
Relation to Previous Architectures
\end_layout

\begin_layout Standard
When presenting similar results for the Core 2, the authors mentions the
 performance counter 
\shape smallcaps
load_block.overlap_store
\shape default
, which is not available on Ivy Bridge, as a potential indication of what
 causes of bias effects 
\begin_inset CommandInset citation
LatexCommand cite
key "Mytkowicz:2008:Easy"

\end_inset

.
 The documentation states that this counter triggers on loads blocked by
 a preceding store due to a variety of reasons, including the following
 case:
\end_layout

\begin_layout Quote
\begin_inset Quotes eld
\end_inset

The load and store have the same offset relative to the beginning of different
 4-KByte pages.
 This case is also called 4-KByte aliasing.
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "Intel:2013:Volume3B"

\end_inset


\end_layout

\begin_layout Standard
It appears that effects of 4K aliasing emerge as a case of failed store
 forwarding in earlier architectures.
 Address aliasing between static and automatic variables was probably the
 underlying cause of bias in the original paper as well.
\end_layout

\begin_layout Subsubsection*
Avoiding Aliasing at Runtime
\end_layout

\begin_layout Standard
Addresses of automatic variables can not be determined statically, because
 the position of stack at runtime is generally unknown.
 In addition to being offset by environment variables, the stack address
 can also be perturbed by other factors such as address layout randomization.
 Although we can not easily know 
\emph on
if
\emph default
 a collision is going to happen for a given environment, we can try to change
 the program to account for possible alias effects.
 The following strategy is a proof of concept of how alias-free code can
 be generated.
\end_layout

\begin_layout Enumerate
Pointer addresses can be accessed in C, thus we can read out the addresses
 to check if there are any collisions between (g, i) and (inc, j).
\end_layout

\begin_layout Enumerate
If the addresses do alias, branch to an alternative but semantically equivalent
 code path.
 Allocate a new set of variables to avoid aliasing.
\end_layout

\begin_layout Standard
A complete implementation is shown in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:loop-micro-kernel-fixed"

\end_inset

.
 Note that only one pair of variables needs to be checked in this case,
 as both static and stack variables are allocated consecutively.
 If inc and j alias (which is checked), then g and i will alias as well.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement t
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},language=C"
inline false
status open

\begin_layout Plain Layout

static int i, j, k;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main() {
\end_layout

\begin_layout Plain Layout

    int g = 0, inc = 1;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    if ((((long)&inc) & 0xfff) == (((long)&j) & 0xfff)) {
\end_layout

\begin_layout Plain Layout

        int dummy = 0, t1 = g, t2 = inc;
\end_layout

\begin_layout Plain Layout

        for (; t1 < 65536; t1++) {
\end_layout

\begin_layout Plain Layout

            i += t2;
\end_layout

\begin_layout Plain Layout

            j += t2;
\end_layout

\begin_layout Plain Layout

            k += t2;
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        g = t1;
\end_layout

\begin_layout Plain Layout

        goto skip;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    for (; g < 65536; g++) {
\end_layout

\begin_layout Plain Layout

        i += inc;
\end_layout

\begin_layout Plain Layout

        j += inc;
\end_layout

\begin_layout Plain Layout

        k += inc;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

skip:
\end_layout

\begin_layout Plain Layout

    return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:loop-micro-kernel-fixed"

\end_inset

Modified code with explicit check for aliasing between inc and j.
 The alternative loop contains no aliasing, and this program does not suffer
 from bad performance due to address aliasing for any environment size.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Img/loop/fixed.eps

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:loop-fixed"

\end_inset

Performance counter statistics for modified code, showing stable values
 over a full 4 KiB range of possible stack addresses modulo 4096
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:loop-fixed"

\end_inset

 shows that all performance counter statistics are stable through 4096 byte
 of offset.
 This covers a whole period of 12 bit address suffixes, showing that the
 aliasing is not merely moved to another offset.
 With only neglectable overhead from additional code size and instructions
 executed, we are able to completely remove negative bias effects caused
 by stack position for this program.
 
\end_layout

\begin_layout Standard
\begin_inset Newpage clearpage
\end_inset


\end_layout

\begin_layout Subsection
Heap Address Aliasing
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sub:heap-address-aliasing"

\end_inset

Address aliasing can occur from memory accesses to any section of memory.
 The previous section looked at an example of collision between stack variables
 and static data.
 Another important scenario to consider is collisions in dynamically allocated
 memory.
 In this section, we will look at how aliasing in heap allocated memory
 can impact performance.
 In particular, functions that operate on pairs of contiguous arrays can
 be vulnerable to 4K aliasing 
\begin_inset CommandInset citation
LatexCommand cite
key "Intel:2012:OptimizationManual"

\end_inset

.
 Many algorithms work in a 
\begin_inset Quotes eld
\end_inset

sliding window
\begin_inset Quotes erd
\end_inset

 fashion; reading some data from an input buffer, do some computation, and
 write the result to an output buffer.
 Some usages that fit this pattern include:
\end_layout

\begin_layout Itemize
Copy or moving data
\end_layout

\begin_layout Itemize
Vector operations
\end_layout

\begin_layout Itemize
Image filtering
\end_layout

\begin_layout Standard
A typical worst case for this group of functions are when each buffer have
 the same addresses modulo 4096.
 For example, iterating over some data from a buffer starting on 0x601
\series bold
020
\series default
 and writing the result to another buffer starting at 0x865
\series bold
020
\series default
 is likely to generate aliasing.
 We will study one such program in detail, and show how variations in heap
 addresses can give performance variations of over 50 % even for optimized
 programs.
 To provide a little more background, we will first look more closely at
 where dynamically allocated memory is located in virtual address space.
\end_layout

\begin_layout Subsubsection*
Addresses of Heap Allocated Memory
\end_layout

\begin_layout Standard
Whether or not heap areas alias will then depend on properties of the memory
 allocator used.
 On our system, the default memory allocator is found in GNU libc 
\begin_inset Foot
status open

\begin_layout Plain Layout
The GNU C Library (glibc) 
\begin_inset CommandInset href
LatexCommand href
name "http://www.gnu.org/software/libc/"
target "http://www.gnu.org/software/libc/"

\end_inset


\end_layout

\end_inset

.
 Acquiring dynamic memory at run time is usually done by calling 
\family typewriter
malloc
\family default
, which takes a number of bytes to allocate and returns a pointer to that
 area.
 
\end_layout

\begin_layout Standard
\begin_inset Float table
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="right" valignment="top" width="0">
<column alignment="right" valignment="top" width="0">
<column alignment="right" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Request size (B)
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Heap addresses
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x15410
\series bold
1
\series default
0 
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x15410
\series bold
3
\series default
0 
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x15410
\series bold
5
\series default
0 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1,000,000
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x7ff1b13ce
\series bold
010
\series default
 
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x7ff1b0e12
\series bold
010
\series default
 
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x7ff1b0d1d
\series bold
010
\series default
 
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:malloc-request-examples"

\end_inset

Addresses of three consecutive heap allocations, for small and large request
 sizes.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Img/alias/malloc.eps

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:brk-mmap"

\end_inset

Heap memory spread out in virtual memory between 
\family typewriter
mmap
\family default
 and 
\family typewriter
sbrk
\family default
 requests
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Depending on the 
\emph on
size
\emph default
 of the request, malloc uses two different strategies for how to allocate
 memory.
 For smaller allocations, malloc uses the 
\begin_inset Quotes eld
\end_inset

normal
\begin_inset Quotes erd
\end_inset

 heap area.
 As illustrated in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:virtual-address-space"

\end_inset

, the heap is placed after static code and data segments in virtual memory,
 extending upwards.
 Every process has a 
\begin_inset Quotes eld
\end_inset

break
\begin_inset Quotes erd
\end_inset

 position, which marks the heap address limit currently available to the
 process.
 The 
\family typewriter
sbrk
\family default
 system call is used to increase the available heap space for a process.
 For larger requests, heap allocation is typically done with 
\family typewriter
mmap
\family default
.
 This system call creates a mapping between memory address space and the
 contents of a file.
 Memory allocators use 
\family typewriter
mmap
\family default
 with the 
\family typewriter
MAP_ANONYMOUS
\family default
 flag specified for larger requests, creating an allocation that is not
 backed by a file.
 There is a threshold value 
\family typewriter
M_MMAP_THRESHOLD
\family default
 for the minimum request size to allocate outside the normal heap, but mmap
 is also sometimes used for smaller requests than this value 
\begin_inset Foot
status open

\begin_layout Plain Layout
Malloc Tunable Parameters, 
\begin_inset CommandInset href
LatexCommand href
name "http://www.gnu.org/software/libc/manual/html_node/Malloc-Tunable-Parameters.html"
target "http://www.gnu.org/software/libc/manual/html_node/Malloc-Tunable-Parameters.html"

\end_inset


\end_layout

\end_inset

.
 Memory returned by mmap is disjoint from the normal heap area, typically
 located on higher addresses and closer to the stack.
 Organization of different heap areas in virtual memory is illustrated in
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:brk-mmap"

\end_inset

.
 
\end_layout

\begin_layout Standard
One of the properties of 
\family typewriter
mmap
\family default
 is that it guarantees page-alignment.
 Because the page size is 4096 bytes, memory returned from larger requests
 will 
\bar under
always
\bar default
 have alias on the last 12 bits -- at least in all cases where 
\family typewriter
mmap
\family default
 is used internally.
 Note that this property of malloc is not affected by address randomization.
 Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:malloc-request-examples"

\end_inset

 illustrates the difference between heap addresses pointing to the normal
 heap or to areas allocated by mmap.
 
\end_layout

\begin_layout Subsubsection*
Example of Aliasing from Aligned Heap Areas
\end_layout

\begin_layout Standard
As an example of 
\begin_inset Quotes eld
\end_inset

sliding window
\begin_inset Quotes erd
\end_inset

 program working on pairs of memory buffers, consider the function shown
 in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:convolution"

\end_inset

.
 It computes the convolution between an input array and a fixed kernel,
 writing the result to another array (endpoints skipped for simplicity).
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement t
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},language=C"
inline false
status open

\begin_layout Plain Layout

static float kernel[5] = {0.1, 0.25, 0.3, 0.25, 0.1};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void convolve(int size, float *input, float *output)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    int i, j;
\end_layout

\begin_layout Plain Layout

    for (i = 2; i < size - 2; ++i)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        output[i] = 0;
\end_layout

\begin_layout Plain Layout

        for (j = 0; j < 5; ++j)
\end_layout

\begin_layout Plain Layout

            output[i] += input[i-2+j] * kernel[j];
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main() {
\end_layout

\begin_layout Plain Layout

    float *input  = malloc(N*sizeof(float));
\end_layout

\begin_layout Plain Layout

    float *output = malloc(N*sizeof(float));
\end_layout

\begin_layout Plain Layout

    convolve(N, input, output);
\end_layout

\begin_layout Plain Layout

    return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:convolution"

\end_inset

Convolution kernel which is vulnerable to aliasing between input and output
 arrays.
 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
This function is sensitive to aliasing between heap areas.
 Using malloc to allocate float arrays of size 
\begin_inset Formula $N$
\end_inset

, both input and ouput will alias in cases where mmap is used internally.
 For sufficiently large values of 
\begin_inset Formula $N$
\end_inset

, this will always be the case.
 Compiling with optimization O3 and 
\begin_inset Formula $N=\text{0x100000}$
\end_inset

, a very large number of alias events and resource stalls are generated
 compared to cycle count.
 The performance counter statistics from running perf is shown in Table
 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:convolution-o3-stats"

\end_inset

, under column 
\begin_inset Quotes eld
\end_inset

No padding
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="3">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
No padding
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Padding 16
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Cycle count, cycles:u
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12,024,235
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5,570,808
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Address alias, r0107:u
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
9,195,816
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
1,175
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Resource stalls, r01a2:u
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7,742,251
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1,290,946
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Instructions, instructions:u
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
11,166,765
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
11,166,802
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:convolution-o3-stats"

\end_inset

Performance counter statistics for convolution kernel with two different
 heap address alignments.
 No padding is default page aligned buffers returned by malloc.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Because malloc is using mmap and returns page-aligned data, a read from
 
\family typewriter
input[i]
\family default
 will always alias with a write to 
\family typewriter
output[i]
\family default
 in convolve.
 Although distinct memory locations, the processor assumes there are dependencie
s between them.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Paragraph
Padding Data
\end_layout

\begin_layout Standard
Aliasing can be accounted for in software by offsetting one of the arrays
 before calling convolve.
 The main function is modified slightly, to make sure address suffixes of
 
\family typewriter
input
\family default
 and 
\family typewriter
output
\family default
 differ by a variable amount.
 We allocate some extra padding for output, and use pointer arithmetic to
 adjust the initial address.
 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},language=C"
inline false
status open

\begin_layout Plain Layout

int main() {
\end_layout

\begin_layout Plain Layout

    float *input  = malloc(N*sizeof(float));
\end_layout

\begin_layout Plain Layout

    float *output = malloc((N + x)*sizeof(float));
\end_layout

\begin_layout Plain Layout

    convolve(N, input, (output + x));
\end_layout

\begin_layout Plain Layout

    return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The address difference modulo 4096 between input and output arrays now becomes
 
\begin_inset Formula $4x$
\end_inset

 bytes.
 Plotting this for increasing values of x shows that virtually all aliasing
 is removed after offsetting with 12 or more elements.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:convolution-O3-graph"

\end_inset

 shows the amount of aliasing is steadily decreasing on larger offsets.
 The best parameter is found to be at a 16 or more elements difference (at
 least 64 bytes).
 Collecting the same performance counters with offset 16, we see that aliasing
 is almost eliminated, and number of resource stalls is significantly reduced.
 The results are shown in Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:convolution-o3-stats"

\end_inset

.
 By simply altering the default addresses given by malloc, we are able to
 reduce the cycle count by more than 50 %.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Img/alias/offsets-O3-gcc.eps

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:convolution-O3-graph"

\end_inset

Performance statistics for convolution with variable amounts of padding
 for output array.
 
\family typewriter
convolve(N, input, (output + x))
\family default
 is executed for increasing values of x, separating array addresses by 
\begin_inset Formula $x$
\end_inset

 
\family typewriter
float
\family default
 elements (or 
\begin_inset Formula $4x$
\end_inset

 bytes) modulo 4096.
 L1 cache hit ratio remain unaffected.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Cache Efficiency
\end_layout

\begin_layout Standard
Given that we are working with relatively large amounts of data (more than
 what fits in L1 or L2 cache), one might suspect that cache misses impacts
 the cycle count.
 Measuring all the relevant cache related counters, as described in Chapter
 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Methodology"

\end_inset

, we find that cache behavior appears to be completely unaffected by aliasing.
 L1 hits is shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:convolution-O3-graph"

\end_inset

, with no correlation to cycle count.
 We also measure hits in the Line fill buffer (LFB), L2 hits, LLC hits and
 LLC misses, but they all have stable values.
 Most of the memory access operations hit the L1 cache, which suggests the
 hardware prefetcher is able to keep up.
 No cache related events show any correlation to cycle count.
 We can therefore safely rule out cache as a contributing factor.
 
\end_layout

\begin_layout Paragraph
Architectural Optimization
\end_layout

\begin_layout Standard
Address aliasing is an artifact of intricacies in the processor architecture.
 Ideally, one would like the compiler to create efficient code without having
 to manually offset heap pointers.
 On optimization O3 however, the compiler will optimize for a 
\begin_inset Quotes eld
\end_inset

generic
\begin_inset Quotes erd
\end_inset

 machine.
 One could hope that aliasing effects are considered when the compiler is
 asked to target our Intel architecture specifically, which can be done
 by specifying 
\family typewriter
-march=native
\family default

\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset CommandInset href
LatexCommand href
name "http://gcc.gnu.org/onlinedocs/gcc-4.6.3/gcc/i386-and-x86_002d64-Options.html"
target "http://gcc.gnu.org/onlinedocs/gcc-4.6.3/gcc/i386-and-x86_002d64-Options.html#i386-and-x86_002d64-Options"

\end_inset


\end_layout

\end_inset

.
 This includes using instructions that are not necessarily portable, for
 example AVX instructions.
 
\end_layout

\begin_layout Standard
We can provide additional information to the compiler's optimizer by using
 the 
\family typewriter
restrict
\family default
 qualifier, explicitly stating that no pointer aliases exists.
 By marking input and output as restrict, we guarantee they are the only
 pointers to their respective memory areas, and not accesses through any
 other (aliased) pointers.
 This benefits code generation and optimization, potentially improving performan
ce.
 Additionally, the input array should be specified as const, guaranteeing
 that only read operations are done to that array.
 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},breaklines=true,language=C"
inline false
status open

\begin_layout Plain Layout

void convolve(int size, const float * restrict input, float * restrict output)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Together with the function signature changes, we find that the following
 compile parameters gives the best performance.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

gcc -O3 -std=c99 -march=native
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Compared to only using O3, the speedup is quite significant (as before,
 we use N = 0x100000).
 Specifying restrict seems to have the most impact on performance.
 Nevertheless, we still see a fairly high alias event count.
 As shown in Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:convolution-native-gcc"

\end_inset

, there are more than 250,000 alias events with the default heap alignment.
 Compared to the much lower cycle count, this is still a significant amount.
 Attempting to manually offset the output array again, we find the best
 parameter to be 48 or more (a minimum difference of 192 bytes).
 Separating the heap buffers eliminates almost all aliasing, while also
 significantly improving cycle count.
 
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="3">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
No padding
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Padding 48
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Cycle count, cycles:u
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3,451,031
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3,028,162
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Address alias, r0107:u
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
259,605
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
236
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Resource stalls, r01a2:u
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
948,047
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
525,796
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Instructions, instructions:u
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3,302,429
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3,302,444
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:convolution-native-gcc"

\end_inset

Performance counter statistics for convolution example compiled with GCC,
 using modified function signature and optimal compiler optimization flags.
 Showing statistics for default (page aligned) heap addresses, and programmatica
lly offset of output buffer by 48 
\family typewriter
float
\family default
 elements.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Even with every opportunity given to the compiler to account for aliasing,
 we are still able to squeeze out a speedup of 14 % by manually adjusting
 memory addresses.
 This speedup is also consistent through other input sizes.
\end_layout

\begin_layout Paragraph
Other Compilers
\end_layout

\begin_layout Standard
In addition to GCC, we made similar experiments with LLVM's clang
\begin_inset Foot
status open

\begin_layout Plain Layout
clang: a C language family frontend for LLVM, 
\begin_inset CommandInset href
LatexCommand href
name "http://clang.llvm.org/"
target "http://clang.llvm.org/"

\end_inset


\end_layout

\end_inset

 version 3.0, and Intel's icc
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset CommandInset href
LatexCommand href
name "http://software.intel.com/en-us/intel-compilers/"
target "http://software.intel.com/en-us/intel-compilers/"

\end_inset


\end_layout

\end_inset

 version 13.
 The behaviour of Clang is similar to GCC with respect to offsets to minimize
 alias.
 Only 16 padding elements is needed to get rid of aliasing, but the change
 in cycle count is not as clear.
 With almost ten times as many dynamic instructions executed, a much higher
 cycle count probably masks the added cost of aliasing.
 Code produced from Intel's icc is not free from aliasing on default page
 aligned heap memory either.
 A similar alias event count as GCC, about 260,000 for N = 0x100000, is
 generated with no padding.
 Aliasing can be eliminated almost completely, but that requires an offset
 of 160.
 
\end_layout

\begin_layout Standard
For this particular example, we found that GCC generated the most efficient
 code, executing in fewer cycles than both clang and icc.
 The effect of aliasing was also most significant in GCC, providing the
 most speedup when padding output buffer.
 Even when provided with architecture-specific optimization flags, none
 of the compilers we tested generated code that could not be improved by
 manually offsetting heap area.
\end_layout

\begin_layout Subsection
Bias from Dynamic Libraries
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sub:dynamic-library-bias"

\end_inset

Heap address conflicts discussed in the previous section does not show 
\emph on
measurement
\emph default
 
\emph on
bias
\emph default
 per se, but rather an artifact of the particular implementation of malloc
 used.
 A perfectly legal implementation of malloc could insert offsets on every
 other large request, avoiding bad performance in cases when mmap is used
 internally.
 Variations between different versions of libc, or local configurations
 on parameters such as 
\family typewriter
M_MMAP_THRESHOLD
\family default
, could have a huge impact on performance.
 In general, one must consider dynamic libraries as an important part of
 the execution context.
 
\end_layout

\begin_layout Subsubsection*
Alternative Memory Allocators
\end_layout

\begin_layout Standard
In the case of memory allocators alone, there are several alternatives to
 libc.
 One of the key issues different allocators tries to address is contention
 in a multi-threaded environment.
 Heap management is a natural bottleneck for multi-threaded applications,
 as all threads share the same address space.
 A naive allocator will force serialization of calls to malloc and free
 from different threads 
\begin_inset CommandInset citation
LatexCommand cite
key "Berger:2000:Hoard"

\end_inset

.
 
\end_layout

\begin_layout Standard
The implementation used in GNU libc is called ptmalloc, which is based on
 Doug Lea's malloc
\begin_inset Foot
status open

\begin_layout Plain Layout
Doug Lea, A Memory Allocator, 
\begin_inset CommandInset href
LatexCommand href
name "http://g.oswego.edu/dl/html/malloc.html"
target "http://g.oswego.edu/dl/html/malloc.html"

\end_inset


\end_layout

\end_inset

.
 We will look at two alternatives, Hoard
\begin_inset Foot
status open

\begin_layout Plain Layout
The Hoard Memory Allocator, 
\begin_inset CommandInset href
LatexCommand href
name "http://www.hoard.org/"
target "http://www.hoard.org/"

\end_inset


\end_layout

\end_inset

 and TCMalloc
\begin_inset Foot
status open

\begin_layout Plain Layout
Thread-Caching Malloc, 
\begin_inset CommandInset href
LatexCommand href
name "http://google-perftools.googlecode.com/svn/trunk/doc/tcmalloc.html"
target "http://google-perftools.googlecode.com/svn/trunk/doc/tcmalloc.html"

\end_inset


\end_layout

\end_inset

, both explicitly targeting multi-threaded code.
 Implementations of malloc and related functions are typically provided
 as shared libraries.
 Both Hoard and TCMalloc can be used as drop-in replacements for already
 compiled code using the 
\family typewriter
LD_PRELOAD
\family default
 environment variable.
 Directories specified this way will be searched first by the dynamic linker,
 resolving references to malloc to the alternative library.
 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

$ LD_PRELOAD=~/Allocators/Hoard/libhoard.so ./test
\end_layout

\end_inset


\end_layout

\begin_layout Standard
For each of the allocator implementations, we observed the addresses returned
 when sequentially allocating two equally large 
\family typewriter
float
\family default
 arrays.
 Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:malloc-impl-tuples"

\end_inset

 shows a comparison for different request sizes.
 
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="9" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0pt">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Array length
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Default (ptmalloc)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
TCMalloc
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Hoard
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="3" alignment="center" valignment="middle" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3840
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x603010
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x695
\series bold
000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x2aaaac000070
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x606c20
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x699
\series bold
000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x2aaaac004000
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="3" alignment="center" valignment="middle" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4660
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x603010
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x69d
\series bold
000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x2aaaac010070
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x6078f0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x6a2
\series bold
000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x2aaaac014d38
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="3" alignment="center" valignment="middle" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
65535
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x2aaaaaad1
\series bold
010
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x6a7
\series bold
000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x2aaaac020
\series bold
070
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x2aaaaab12
\series bold
010
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x6e7
\series bold
000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x2aaaac070
\series bold
070
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="3" alignment="center" valignment="middle" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16702650
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x2aaaab091
\series bold
010
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x8b57
\series bold
000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x2aaaac030
\series bold
070
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x2aaaaf049
\series bold
010
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0xcb2f
\series bold
000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x2aaaafff0
\series bold
070
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:malloc-impl-tuples"

\end_inset

Addresses returned when allocating two 
\family typewriter
float
\family default
 arrays of the same size, examples of possible sources of 4K alias conflicts
 highlighted.
 Tests were run with ASLR disabled for reproducible results, but we get
 similar results with randomization enabled.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Itemize
The default implementation (ptmalloc) is consistently using the regular
 heap (non-aligned low addresses) for smaller allocations, and mmap for
 larger requests.
 
\end_layout

\begin_layout Itemize
TCMalloc seems to be using the normal heap area exclusively.
 Interestingly, memory is aligned on page boundaries also for small sizes,
 always returning addresses ending in 0x000.
\end_layout

\begin_layout Itemize
Hoard also tends to align on page boundaries for larger requests, with addresses
 ending in 0x070.
 Unlike the other two, it looks like Hoard never utilizes normal heap area.
 
\end_layout

\begin_layout Standard
Each library produces very different results, and potential for address
 alias conflicts depends on the particular implementation of malloc used.
 There are several examples of cases where switching library can eliminate
 alias by changing address suffixes.
 For the convolution example, using ptmalloc or Hoard is very likely to
 outperform TCMalloc for 
\begin_inset Formula $n=\text{0x1234}$
\end_inset

.
 
\end_layout

\begin_layout Standard
Most allocators seem focus mostly on efficiency in a multi-threaded environment,
 and we find that none of the alternatives tested attempts to solve the
 aliasing problem for aligned arrays.
\end_layout

\begin_layout Subsection
Summary
\end_layout

\begin_layout Standard
In this section we have studied how 
\emph on
address aliasing
\emph default
 can affect program performance under different memory layouts.
 This effect is caused by the way speculative and out-of-order memory operations
 are handled by the CPU, only considering the last 12 address bits to resolve
 conflicts load and store operations.
 We have shown how aliasing can cause measurement bias for the following
 cases:
\end_layout

\begin_layout Itemize

\emph on
Variations in environment size
\emph default
: Analyzing the example provided in 
\begin_inset CommandInset citation
LatexCommand cite
key "Mytkowicz:2009:WrongData"

\end_inset

, we determined that collisions between stack variables and static data
 caused aliasing for certain stack positions.
 Variations in environment size changes virtual addresses of stack allocated
 data, and measurement bias observed by this can in some cases be attributed
 to address aliasing.
\end_layout

\begin_layout Itemize

\emph on
Properties of heap allocators
\emph default
: Different versions or implementations of memory allocators can introduce
 measurement bias.
 We presented a code example with extreme sensitivity of data alignment,
 with more than 50 % performance variation between different memory layouts.
 
\end_layout

\begin_layout Standard
Any change to virtual memory layout of data can potentially introduce bias
 effects from address aliasing.
 We find that compilers, even when provided with architecture specific optimizat
ion flags, can not generate code that does not suffer from aliasing.
 Typical heap allocators are found to often use page-aligned memory, which
 is the worst case with respect to aliasing for many algorithms.
 Despite recommendations from Intel, we are not aware of any allocators
 that specifically addresses this issue.
 This means that an understanding of 4K address aliasing is needed to achieve
 optimal performance.
 We show how manual padding of variables, and alternative alias-free code
 paths, can be used to avoid aliasing at run time.
 
\end_layout

\begin_layout Standard
\begin_inset Newpage clearpage
\end_inset


\end_layout

\begin_layout Section
The Loop Stream Detector
\end_layout

\begin_layout Standard
Typical software spends most of the time executing the same instructions
 repeatedly in a loop, where the same branches are taken, and the same instructi
ons are fetched and decoded.
 The Loop Stream Detector (LSD) is a front-end hardware optimization that
 is able to detect small software loops 
\begin_inset CommandInset citation
LatexCommand cite
key "Ramesh:i7PerformanceMonitoring"

\end_inset

.
 Instead of repeatedly fetching and decoding the same instructions, loops
 can be streamed directly from a queue of already decoded micro operations.
 Normal fetch/decode operation is resumed once a branch mispredict occurs.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Img/intel/lsd.eps

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Loop Stream Detector circumvents branch prediction, fetch and decode for
 hot loops, streaming directly from the micro-op queue
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
This optimization is affecting both performance and power efficiency.
 Power savings come from disabling front-end components such as fetch and
 decode when the LSD is active.
 In cases where instruction fetch is the bottleneck, streaming already decoded
 micro-operations can also increase performance.
 
\end_layout

\begin_layout Standard
We choose to study this hardware feature specifically, because it has been
 suggested in previous work as a potential source of measurement bias 
\begin_inset CommandInset citation
LatexCommand cite
key "Mytkowicz:2009:WrongData"

\end_inset

.
 The Loop Stream Detector is dependent on code layout, which can change
 with external factors such as variations in link ordering.
 Some effort has been made to model properties of the LSD on previous Intel
 architectures 
\begin_inset CommandInset citation
LatexCommand cite
key "Hundt:2011:MAO"

\end_inset

, as an aid in low-level optimization.
 In this section we will uncover important characteristics of the Loop Stream
 Detector on Ivy Bridge.
 With an understanding of its limitations, we show an example of how measurement
 bias from link ordering can be explained.
 We also discuss other external factors that can alter code layout, possibly
 causing measurement bias.
\end_layout

\begin_layout Standard
In the documentation, we find two hardware performance counters that can
 measure the utilization of the LSD 
\begin_inset CommandInset citation
LatexCommand cite
key "Intel:2013:Volume3B"

\end_inset

.
\end_layout

\begin_layout Description
LSD.UOPS Counts the number of micro-ops delivered by loop stream detector.
\end_layout

\begin_layout Description
LSD_OVERFLOW Counts number of loops that can't stream from the instruction
 queue.
 
\end_layout

\begin_layout Standard
Note that none of these are listed in the non-architectural counters supported
 by Ivy Bridge.
 However, we find that using the event codes given for previous architectures
 seems to work regardless, and gives reasonable results.
 We suspect that the official reference is either not complete or misleading
 in this case.
\end_layout

\begin_layout Subsection
Properties of the Loop Stream Detector
\end_layout

\begin_layout Standard
A set of restrictions is given on what loops can be recognized by the loop
 stream detector.
 The Architectures Optimization Reference Manual 
\begin_inset CommandInset citation
LatexCommand cite
key "Intel:2012:OptimizationManual"

\end_inset

 states the following requirements for a loop to be recognized by the LSD:
\end_layout

\begin_layout Enumerate
Up to eight chunk fetches of 32 instruction-bytes
\end_layout

\begin_layout Enumerate
Up to 28 micro-ops (~28 instructions)
\end_layout

\begin_layout Enumerate
All micro-ops are also resident in the Decoded ICache
\end_layout

\begin_layout Enumerate
Can contain no more than eight taken branches and none of them can be a
 CALL or RET
\end_layout

\begin_layout Enumerate
Cannot have mismatched stack operations.
 For example, more PUSH than POP instructions
\end_layout

\begin_layout Standard
The capabilities of the LSD is changing between processor generations.
 In particular, the limits to chunk fetches, maximum number of micro-ops
 and taken branches seems to continuously increase 
\begin_inset CommandInset citation
LatexCommand cite
key "Ramesh:i7PerformanceMonitoring,Intel:OnlinePCReference"

\end_inset

.
 It is not clear whether all the stated limitations are valid for the Ivy
 Bridge, as it is not explicitly stated in the manual.
 Information is also contradictory; the limitation to number of micro-ops
 is mentioned as 56 for the Ivy Bridge.
 We create a series of micro benchmarks to manually verify what the actual
 limitations are.
 
\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="3">
<features booktabs="true" tabularvalignment="middle">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
HT off
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
HT on
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Chunk fetches
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Micro-ops
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
56
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
28
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Taken branches
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Properties of the Ivy Bridge Loop Stream Detector, determined empirically
 by a series of micro benchmarks
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Chunk fetches
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement t
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},language=C"
inline false
status open

\begin_layout Plain Layout

    .section .text
\end_layout

\begin_layout Plain Layout

    .globl main
\end_layout

\begin_layout Plain Layout

main:
\end_layout

\begin_layout Plain Layout

    mov $0x1234567, %eax 
\end_layout

\begin_layout Plain Layout

    mov $0, %ebx
\end_layout

\begin_layout Plain Layout

    .p2align 5
\end_layout

\begin_layout Plain Layout

.l0:
\end_layout

\begin_layout Plain Layout

    cmp $0, %ebx
\end_layout

\begin_layout Plain Layout

    je .l1
\end_layout

\begin_layout Plain Layout

    lea 0x100(%rsp), %ecx
\end_layout

\begin_layout Plain Layout

    lea 0x100(%rsp), %ecx
\end_layout

\begin_layout Plain Layout

    lea 0x100(%rsp), %ecx
\end_layout

\begin_layout Plain Layout

    add $0x100, %ecx
\end_layout

\begin_layout Plain Layout

.l1:
\end_layout

\begin_layout Plain Layout

    (...)
\end_layout

\begin_layout Plain Layout

.l11:
\end_layout

\begin_layout Plain Layout

    cmp $0, %eax
\end_layout

\begin_layout Plain Layout

    jne .l0
\end_layout

\begin_layout Plain Layout

    ret
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:lsd-chunks"

\end_inset

Micro kernel for testing chunk fetch limit.
 Additional (
\family typewriter
cmp
\family default
, 
\family typewriter
je
\family default
, 
\family typewriter
lea
\family default
, 
\family typewriter
lea
\family default
, 
\family typewriter
lea
\family default
, 
\family typewriter
add
\family default
) blocks of exactly 32 bytes are inserted until 
\shape smallcaps
lsd.uops
\shape default
 shows the Loop Stream Detector is no longer active.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The documentation states that a maximum number of eight 32 byte 
\begin_inset Quotes eld
\end_inset

chunks
\begin_inset Quotes erd
\end_inset

 of instruction data can be fetched in each loop.
 Our interpretation of this is that instruction data is somehow organized
 into blocks of 32 bytes, aligned to multiples of 0x20 in virtual address
 space.
 
\end_layout

\begin_layout Standard
To test this limit, we need loops that execute instructions spanning a variable
 amount of chunks.
 The micro kernel we used is shown in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:lsd-chunks"

\end_inset

, written in GNU x86-64 assembly.
 The idea is to execute a minimal amount of instructions at the start of
 each block, and immediately jump on to the next.
 Blocks are labeled 
\family typewriter
.l0
\family default
, 
\family typewriter
.l1
\family default
, …, 
\family typewriter
.ln
\family default
, and the first block is explicitly forced to align on a 32 byte boundary
 (5 bits) by the 
\family typewriter
.p2align
\family default
 directive.
 Virtual addresses of code and static data can be read from the ELF binary
 after compilation.
 A disassembled portion of the code is shown below
\begin_inset Foot
status open

\begin_layout Plain Layout
Output shows disassembly generated by the objdump utility, part of GNU Binutils
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily}"
inline false
status open

\begin_layout Plain Layout

400500: 83 fb 00             cmp    $0x0,%ebx
\end_layout

\begin_layout Plain Layout

400503: 74 1b                je     400520 <.l1>
\end_layout

\begin_layout Plain Layout

400505: 8d 8c 24 00 01 00 00 lea    0x100(%rsp),%ecx
\end_layout

\begin_layout Plain Layout

40050c: 8d 8c 24 00 01 00 00 lea    0x100(%rsp),%ecx
\end_layout

\begin_layout Plain Layout

400513: 8d 8c 24 00 01 00 00 lea    0x100(%rsp),%ecx
\end_layout

\begin_layout Plain Layout

40051a: 81 c1 00 01 00 00    add    $0x100,%ecx
\end_layout

\end_inset

 We see that the first compare instruction starts on address 0x400500, aligned
 to 32 byte.
 Because 
\family typewriter
%ebx
\family default
 is always zero, the branch is taken every time.
 The remaining 
\family typewriter
lea
\family default
 and 
\family typewriter
add
\family default
 instructions are added to fill the remaining bytes in the chunk.
 Only the first 
\begin_inset Formula $3+2$
\end_inset

 instruction bytes occupied by 
\family typewriter
cmp
\family default
 and 
\family typewriter
je
\family default
 are executed, while the remaining 
\begin_inset Formula $27$
\end_inset

 bytes is dead code.
 After a number of repeated blocks like these, the counter is incremented
 before jumping back to 
\family typewriter
.l0
\family default
.
 The final 
\family typewriter
sub
\family default
, 
\family typewriter
cmp
\family default
 and 
\family typewriter
jne
\family default
 instructions occupy 12 bytes, so it is possible to insert another 20 bytes
 of padding to completely fill the last chunk as well.
 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily}"
inline false
status open

\begin_layout Plain Layout

400674: 83 e8 01             sub    $0x1,%eax
\end_layout

\begin_layout Plain Layout

400677: 83 f8 00             cmp    $0x0,%eax
\end_layout

\begin_layout Plain Layout

40067a: 0f 85 80 fe ff ff    jne    400500 <.l0>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
For every loop iteration, a total of 
\begin_inset Formula $2N+3$
\end_inset

 instructions are executed, spanning 
\begin_inset Formula $N+1$
\end_inset

 chunks of 32 bytes.
 The 
\family typewriter
cmp
\family default
 and 
\family typewriter
je
\family default
 instructions should be fused to a single micro-op, so we should not be
 hitting the micro-op limit.
 We find that the 
\shape smallcaps
lsd.uops
\shape default
 counter reports high values through 
\begin_inset Formula $N=11$
\end_inset

, meaning the Ivy Bridge Loop Stream Detector must supports at least 12
 chunk fetches.
 
\end_layout

\begin_layout Subsubsection*
Micro-operations
\end_layout

\begin_layout Standard
The second requirement states that each loop can only contain a maximum
 of 28 micro-operations.
 This is no longer true for Ivy Bridge, because of changes to the Micro-op
 Queue.
 In previous generation(s), the micro-op queue was statically partitioned
 with 28 entries for each logical core.
 One of the Front-end enhancement in Ivy Bridge is that all 56 entries in
 the queue can be used when only a single logical core is active, i.e.
 hyper-threading is disabled 
\begin_inset CommandInset citation
LatexCommand cite
key "Intel:2012:OptimizationManual"

\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},language=C"
inline false
status open

\begin_layout Plain Layout

    .section .text
\end_layout

\begin_layout Plain Layout

    .globl main
\end_layout

\begin_layout Plain Layout

main:
\end_layout

\begin_layout Plain Layout

    mov $0x1234567, %eax
\end_layout

\begin_layout Plain Layout

    .p2align 5
\end_layout

\begin_layout Plain Layout

.loop:
\end_layout

\begin_layout Plain Layout

    add %ebx, %ecx
\end_layout

\begin_layout Plain Layout

    add %ebx, %ecx
\end_layout

\begin_layout Plain Layout

    (...)
\end_layout

\begin_layout Plain Layout

    add %ebx, %ecx
\end_layout

\begin_layout Plain Layout

    sub $1, %eax
\end_layout

\begin_layout Plain Layout

    cmp $0, %eax
\end_layout

\begin_layout Plain Layout

    jne .loop
\end_layout

\begin_layout Plain Layout

    ret
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:lsd-micro-ops"

\end_inset

Micro kernel for testing LSD micro-instruction limit.
 Additional 
\family typewriter
add
\family default
 instructions are inserted until LSD.UOPS shows the Loop Stream Detector
 becomes inactive.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
We verify this restriction by measuring 
\shape smallcaps
lsd_overflow
\shape default
 and 
\shape smallcaps
lsd.uops
\shape default
 for loops of increasing size, adding instructions one by one until the
 performance counter statistics report the LSD is inactive.
 Our micro-kernel is shown in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:lsd-micro-ops"

\end_inset

.
 We find that the LSD is active with as many as 54 
\family typewriter
add
\family default
 instructions.
 The loop logic is implemented with a 
\family typewriter
sub
\family default
, 
\family typewriter
cmp
\family default
 and 
\family typewriter
jne
\family default
 instruction.
 With macro-fusion of the last 
\family typewriter
cmp
\family default
 + 
\family typewriter
jne
\family default
, the total is exactly 56 micro-operations per loop.
 With hyper-threading enabled, the number is cut in half to 28, as expected.
\end_layout

\begin_layout Subsubsection*
Taken branches
\end_layout

\begin_layout Standard
The fourth requirement states that a loop can contain no more than eight
 taken branches.
 The chunk fetch limit example already uses 12 branches, so we can immediately
 conclude that at least 12 taken branches is supported.
 We experiment with more than one branch targets in each chunk, but are
 not able to increase the number any further.
 All of our example programs with more than 12 taken branches results in
 low values for LSD.UOPS.
 
\end_layout

\begin_layout Subsection
Hitting the Chunk Fetch Limit
\end_layout

\begin_layout Standard
Knowing the parameters, we can construct programs that are on the limit
 of what the Loop Stream Detector accepts.
 Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:lsd-chunks-c"

\end_inset

 shows a simple loop that generates code much like the micro kernel used
 to test chunk fetch limit.
 Each of the if statements occupies exactly 32 byte in instruction memory
 when compiled with gcc and no optimization.
 Including the instructions needed to compare and increment variable 
\family typewriter
i
\family default
, the loop code covers just under 
\begin_inset Formula $12\times32$
\end_inset

 bytes in the compiled binary.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Img/lsd/chunks-13.eps

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:lsd-chunks-12-13"

\end_inset

Depending on alignment, code can span either 12 or 13 chunks of 32 byte
 instruction memory
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
\begin_inset Float algorithm
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},showstringspaces=false"
inline false
status open

\begin_layout Plain Layout

#include <stdio.h>
\end_layout

\begin_layout Plain Layout

#define B27 a=b, a=b, a=b, a=b, a=b, a=b, a=b, a=b, a=b
\end_layout

\begin_layout Plain Layout

int main() {
\end_layout

\begin_layout Plain Layout

    register int i = 0, a = 1, b = 1;
\end_layout

\begin_layout Plain Layout

    //printf("What is going wrong?");
\end_layout

\begin_layout Plain Layout

    while (i++ < 0x12345678) {
\end_layout

\begin_layout Plain Layout

        if (a != b) B27;
\end_layout

\begin_layout Plain Layout

        if (a != b) B27;
\end_layout

\begin_layout Plain Layout

        if (a != b) B27;
\end_layout

\begin_layout Plain Layout

        if (a != b) B27;
\end_layout

\begin_layout Plain Layout

        if (a != b) B27;
\end_layout

\begin_layout Plain Layout

        if (a != b) B27;
\end_layout

\begin_layout Plain Layout

        if (a != b) B27;
\end_layout

\begin_layout Plain Layout

        if (a != b) B27;
\end_layout

\begin_layout Plain Layout

        if (a != b) B27;
\end_layout

\begin_layout Plain Layout

        if (a != b) B27;
\end_layout

\begin_layout Plain Layout

        if (a != b) B27;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:lsd-chunks-c"

\end_inset

Loop spanning 13 chunks of 32 bytes when compiled with gcc, but only 12
 chunks with the printf statement uncommented.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Even though we are within the limit, a quick test with 
\family typewriter
perf
\family default
 reveals that the Loop Stream Detector is not enabled.
 Only a negligible amount of micro-ops are delivered by the LSD, as reported
 by 
\shape smallcaps
lsd.uops
\shape default
.
 Inspecting the compiled binary, we see that the loop instructions span
 virtual addresses 0x4004d3 through 0x400648.
 The first byte in a chunk have address ending in 0x00, 0x20, 0x40, 0x60,
 0x80, 0xa0, 0xc0 or 0xe0, meaning the first instruction belongs to the
 0x4004
\series bold
c0
\series default
 chunk, and the last is just within the 0x4006
\series bold
40
\series default
 chunk.
 Despite covering less than 
\begin_inset Formula $12\times32$
\end_inset

 byte of instruction addresses, this specific alignment causes the code
 to span not 12 but 13 chunks, exceeding the limitation.
 
\end_layout

\begin_layout Standard
We can create a different alignment by inserting some code before the loop.
 By uncommenting the printf statement, we see that the LSD is able to deliver
 micro-ops, giving a huge speedup.
 The performance counter statistics for each of these programs is shown
 in Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:chunk-limit-stats"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
13 chunks
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12 chunks
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Cycle count, cycles:u
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7,636,642,008
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3,665,689,143
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
LSD.UOPS, r01a8:u
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
10,921
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
4,581,309,568
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Instructions, instruction:u
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8,246,427,939
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8,246,428,712
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:chunk-limit-stats"

\end_inset

Performance counter statistics for program hitting the chunk fetch limit.
 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Looking at the binary again, we find that the loop now only covers 12 chunks,
 spanning addresses 0x400529 through 0x40069e.
 The difference between the two configurations is illustrated in Figure
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:lsd-chunks-12-13"

\end_inset

.
 When no optimization flags are used, GCC does not try to align loops in
 any strict way, meaning that differences like these depend on surrounding
 code.
 We will use a similar approach to show how bias from link ordering can
 be explained by the LSD, presenting an example that also works with optimizatio
n enabled.
\end_layout

\begin_layout Subsection
Bias from Link Order
\end_layout

\begin_layout Standard
Different link orders affects determines the relative position of code and
 static data within the final compiled binary file.
 Cases where programs are 
\emph on
biased
\emph default
 towards certain link orders, can be explained by hitting some limitation
 of the Loop Stream Detector.
 
\end_layout

\begin_layout Subsubsection*
Chunk fetches
\end_layout

\begin_layout Standard
With a few modifications to our previous example, we can create a program
 that utilizes the LSD only for certain link orders.
 Our program is shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:lsd-link-O3"

\end_inset

, containing three files; main.c, foo.c and loop.c.
 
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\emph on
foo.c:
\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\ttfamily}"
inline false
status open

\begin_layout Plain Layout

int foo(int n)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    int a = 1;
\end_layout

\begin_layout Plain Layout

    return a;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Plain Layout

\emph on
main.c:
\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\ttfamily}"
inline false
status open

\begin_layout Plain Layout

#include <stdio.h>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    int i = loop(10);
\end_layout

\begin_layout Plain Layout

    int f = foo(10);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    printf("Loop: %d
\backslash
n",i);
\end_layout

\begin_layout Plain Layout

    printf("Foo : %d
\backslash
n",f);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "50col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\emph on
loop.c:
\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\ttfamily}"
inline false
status open

\begin_layout Plain Layout

#define B22(n) b += i*i*a + 1
\end_layout

\begin_layout Plain Layout

volatile int i = 42;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int loop(int a) {
\end_layout

\begin_layout Plain Layout

    register int b = i==42 ? 1 : 0;
\end_layout

\begin_layout Plain Layout

    do {
\end_layout

\begin_layout Plain Layout

        if (!i) B22(1);
\end_layout

\begin_layout Plain Layout

        if (!i) B22(2);
\end_layout

\begin_layout Plain Layout

        if (!i) B22(3);
\end_layout

\begin_layout Plain Layout

        if (!i) B22(4);
\end_layout

\begin_layout Plain Layout

        if (!i) B22(5);
\end_layout

\begin_layout Plain Layout

        if (!i) B22(6);
\end_layout

\begin_layout Plain Layout

        if (!i) B22(7);
\end_layout

\begin_layout Plain Layout

        if (!i) B22(8);
\end_layout

\begin_layout Plain Layout

        if (!i) B22(9);
\end_layout

\begin_layout Plain Layout

        if (!i) B22(10);
\end_layout

\begin_layout Plain Layout

        if (!i) B22(11);
\end_layout

\begin_layout Plain Layout

   } while (i++ < 0x12345678);
\end_layout

\begin_layout Plain Layout

    return b;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:lsd-link-O3"

\end_inset

Program with measurement bias from link order, favoring (main, foo, loop)
 over (main, loop, foo) when compiled with GCC and optimization level O3
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In the example from Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:lsd-chunks-c"

\end_inset

, we exploited weak alignment guarantees from GCC, sometimes spilling loop
 code over 13 chunks.
 One might hope that with the proper optimization flags, compilers will
 fix such alignment flaws.
 There is an 
\begin_inset Quotes eld
\end_inset

align-loops
\begin_inset Quotes erd
\end_inset

 flag in GCC
\begin_inset Foot
status open

\begin_layout Plain Layout
Optimize Options -- Using the GNU Compiler Collection (GCC), 
\begin_inset CommandInset href
LatexCommand href
name "http://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html"
target "http://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html"

\end_inset


\end_layout

\end_inset

, enabled by default in O2 and O3, which allows the assembler align loops
 by inserting necessary padding.
 On optimization O3, the following assembly directives are inserted before
 the first instruction that is part of the loop in loop.c
\begin_inset Foot
status open

\begin_layout Plain Layout
The GNU Assembler, 
\begin_inset CommandInset href
LatexCommand href
name "http://tigcc.ticalc.org/doc/gnuasm.html"
target "http://tigcc.ticalc.org/doc/gnuasm.html"

\end_inset


\end_layout

\end_inset

.
\begin_inset listings
lstparams "basicstyle={\small\ttfamily}"
inline false
status open

\begin_layout Plain Layout

.p2align 4,,10
\end_layout

\begin_layout Plain Layout

.p2align 3
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The first directive tries to align to four address bits, inserting at most
 10 bytes for padding.
 If that does not work, the next directive forces loops to be aligned to
 three bits -- meaning addresses ending in 0x0 or 0x8.
 Within a 32 byte instruction block, the first loop instruction can end
 up being offset by 0x00, 0x08, 0x10 or 0x18.
 The loop itself spans 379 instruction bytes when compiled in our example,
 just shy of the 
\begin_inset Formula $12\times32=384$
\end_inset

 bytes that can maximally fit in the LSD.
 Out of the four possible alignments, only zero offset into a chunk will
 work in our case.
 Performance counter statistics for two different link order are shown in
 Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:link-order-stats"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
main.c, loop.c, foo.c
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
main.c, foo.c, loop.c
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Cycle count, cycles:u
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7,636,374,873
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3,665,668,196
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
LSD.UOPS, r01a8:u
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
10,998
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
8,246,350,119
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Instructions, instruction:u
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
11,606,047,809
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
11,606,046,865
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:link-order-stats"

\end_inset

Performance counter statistics for different link orders.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Link order 
\emph on
main.c, loop.c, foo.c
\emph default
: The first loop instruction is aligned to 0x400590, an offset of 0x10 into
 the 0x4005
\series bold
80
\series default
 chunk.
 Covering 13 chunks, the Loop Stream Detector can not be utilized.
\end_layout

\begin_layout Itemize
Link order 
\emph on
main.c, foo.c, loop.c
\emph default
: The first loop instruction is aligned to 0x4005
\series bold
a0
\series default
, right at the start of a chunk.
 Cycle count is reduced by more than 50% from utilizing the LSD.
\end_layout

\begin_layout Standard
We see that measurement bias from link order can in some cases be explained
 by hitting the chunk fetch limit of the Loop Stream Detector.
 Even when compiling with sensible optimization flags, GCC does not always
 hit the optimal loop alignment, causing code to spill over additional chunks.
 A possible solution in this scenario could be to manually specify the loop
 alignment to 32 byte, with -falign-loops=32.
\end_layout

\begin_layout Subsubsection*
Decoded ICache Limitations
\end_layout

\begin_layout Standard
Any property of the Loop Stream Detector that depends on the code layout
 in memory can potentially be triggered by different link orders.
 This is not limited to the number of chunk fetches, but also includes propertie
s of the Decoded ICache.
 One of the LSD requirements states that all micro-ops must be present in
 the Decoded ICache.
 The manual describes additional restrictions to what micro-ops can be stored
 in this cache, imposing limitations to the number of branches per block,
 and other alignment properties 
\begin_inset CommandInset citation
LatexCommand cite
key "Intel:2012:OptimizationManual"

\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\ttfamily}"
inline false
status open

\begin_layout Plain Layout

#include <stdio.h>
\end_layout

\begin_layout Plain Layout

volatile static int color;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main() {
\end_layout

\begin_layout Plain Layout

    printf("Fixing colors");
\end_layout

\begin_layout Plain Layout

    for (int i = 0; i < 10000000; ++i) {
\end_layout

\begin_layout Plain Layout

        if (color == 0x000)
\end_layout

\begin_layout Plain Layout

            color = 0xaaa;
\end_layout

\begin_layout Plain Layout

        else if (color == 0xaaa)
\end_layout

\begin_layout Plain Layout

            color = 0xfff;
\end_layout

\begin_layout Plain Layout

        else if (color == 0xfff)
\end_layout

\begin_layout Plain Layout

            color = 0x000;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:lsd-color"

\end_inset

Loop using LSD only for certain alignments when compiled with GCC and no
 optimization, likely hitting limitations in Decoded ICache
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Consider the small C program from Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:lsd-color"

\end_inset

.
 Compiling with 
\family typewriter
cc -std=c99
\family default
 and no optimization, the binary code generated by this function clearly
 spans far less than 12 chunks.
 Counting LSD.UOPS, we see that the Loop Stream Detector is not in use.
 However, by removing the printf statement the loop alignment is moved from
 0x400517 to 0x4004c1, and the LSD is enabled.
 We did not investigate the actual cause of this any further, but speculate
 that specific alignments prevents all micro-ops to reside in ICache simultaneou
sly.
 
\end_layout

\begin_layout Subsection
Trivial Code Changes Introducing Bias
\end_layout

\begin_layout Standard
The focus of previous work, and elaborated in this section, is measurement
 bias caused by altering link ordering.
 The important factor is not the process of linking itself, but the effect
 it has on final code layout in the compiled binary.
 Any interaction that affects code layout can potentially trigger performance
 cliffs caused by the LSD.
 The following briefly discusses some additional properties to consider.
\end_layout

\begin_layout Subsubsection*
The order of functions within a source file
\end_layout

\begin_layout Standard
As with link order, the order of functions within a source file usually
 determines their relative position in the text segment of the compiled
 binary.
 Given a program with functions foo and bar, listing foo before bar and
 vice versa generates two 
\begin_inset Quotes eld
\end_inset

different
\begin_inset Quotes erd
\end_inset

 programs with respect to memory layout.
 GCC prints functions to the text segment in the order they appear in the
 source code.
\end_layout

\begin_layout Subsubsection*
Length of external symbols
\end_layout

\begin_layout Standard
Symbols such as function names are placed in a symbol table section in the
 ELF file.
 When running readelf or objdump, the names are used to print nice output.
 However, names of external symbols resolved at run-time does affect code
 layout.
 Longer function names (or more external dependencies) will offset the text
 segment because of allocable segments related to dynamic linking is placed
 before text.
 This includes dynsym, dynstr, gnu.version and rela sections in an executable
 made with GCC.
 Details for each of the ELF sections can be found in the man pages 
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset CommandInset href
LatexCommand href
name "http://linux.die.net/man/5/elf"
target "http://linux.die.net/man/5/elf"

\end_inset


\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection*
Interpreter path
\end_layout

\begin_layout Standard
When executing an ELF binary, the first thing that happens is to load and
 run an interpreter/dynamic linker.
 The interpreter is responsible for unpacking the object file and map all
 the allocable sections to virtual memory, as well as loading any external
 dependencies.
 The path to the interpreter itself is located in the ELF 
\begin_inset Quotes eld
\end_inset

.interp
\begin_inset Quotes erd
\end_inset

 section, which is allocable and loaded first.
 On our system, this defaults to 
\begin_inset Quotes eld
\end_inset

/lib64/ld-linux-x86-64.so.2
\begin_inset Quotes erd
\end_inset

.
 Other loaders can be specified, either at compile time or by patching the
 object file
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset CommandInset href
LatexCommand href
name "http://nixos.org/patchelf.html"
target "http://nixos.org/patchelf.html"

\end_inset


\end_layout

\end_inset

.
 Specifying an alternative interpreter at compile time can be done with
 a linker flag, for example:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},breaklines=true"
inline false
status open

\begin_layout Plain Layout

-Wl,-dynamic-linker,/home/me/very/long/path/to/an/alternative/loader.symlink.so.2
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The string containing the path to the interpreter is actually allocated
 to virtual memory, before the text segment.
 This means that the string length (in characters) can offset code addresses.
 
\end_layout

\begin_layout Subsection
Summary
\end_layout

\begin_layout Standard
The Loop Stream Detector can provide significant speedup, but subtle changes
 to code layout sometimes prevents this optimization to be utilized.
 In this section we have shown that simply adding (or removing) a printf
 statement, or changing the link order, can have a severe performance impact.
 Programmers rarely care, or even know, about intricate details such as
 the addresses and alignment of code.
 We expect, and probably rightfully so, that sensible compilers and linkers
 will organize code somewhat optimally.
 In cases where this is not true, weird effects that might be categorized
 as 
\begin_inset Quotes eld
\end_inset

bias
\begin_inset Quotes erd
\end_inset

 occurs.
 For developers, it is useful to be aware of the fact that 
\emph on
any
\emph default
 change to instruction addresses can potentially have a huge impact on performan
ce.
 
\end_layout

\begin_layout Standard
On a final note, it is not too difficult to come up with smaller programs
 like that hits some limitation of the LSD for certain alignments.
 It appears that this particular hardware feature is a very likely cause
 of measurement bias in practice.
 
\end_layout

\begin_layout Chapter
Case Studies
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "chap:Case Studies"

\end_inset

In this chapter, we show instances of how bias effects illustrated in the
 previous chapter affects real software.
 The goal is to identify possible instances of bias, and also discuss how
 to take bias into account for optimization purposes.
 We choose to focus on already highly optimized numerical applications for
 our case studies, because the real world impact of bias effects is most
 relevant for performance critical applications.
 If only a minor improvement can be mady by avoiding some memory alignment
 issue, the cost of implementing an architecture specific optimization will
 probably be worth it.
\end_layout

\begin_layout Standard
Two applications are studied: In Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:FFTW"

\end_inset

 we will look at FFTW, which isa widely used library for computing Fourier
 transforms.
 We show that for smaller input sizes, there is potential for bias towards
 certain stack positions.
 In Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:BLAS"

\end_inset

 we look at ATLAS, an implementation of the BLAS API for linear algebra
 routines.
 We find that matrix-vector multiplication is sensitive to address aliasing,
 and show how to improve performance on average by padding data.
 
\end_layout

\begin_layout Standard
\begin_inset Newpage clearpage
\end_inset


\end_layout

\begin_layout Section
FFTW
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sec:FFTW"

\end_inset

As an integral part of applications such as signal and image processing,
 a huge amount of work has been done over the years to optimize and tweak
 the performance of the Fast Fourier Transform (FFT).
 Today, there are a plethora of excellent implementations available, among
 them FFTW
\begin_inset Foot
status open

\begin_layout Plain Layout
FFTW Home Page,
\begin_inset CommandInset href
LatexCommand href
name "http://www.fftw.org/"
target "http://www.fftw.org/"

\end_inset


\end_layout

\end_inset

, an acronym for 
\begin_inset Quotes eld
\end_inset

Fastest Fourier Transform in the West
\begin_inset Quotes erd
\end_inset

.
 Its design goal is to be portable, yet achieve close to optimal performance
 across a wide variety of platforms 
\begin_inset CommandInset citation
LatexCommand cite
key "Frigo:2005:FFTW3"

\end_inset

.
 The library is not optimized specifically for any processor or architecture,
 but uses 
\emph on
automatic tuning
\emph default
 to adapt to the underlying hardware 
\begin_inset CommandInset citation
LatexCommand cite
key "Vuduc:2000:CodegenFFTW"

\end_inset

.
 Provided that a speedup on average can be achieved, explicitly handling
 of context bias could be a realistic addition to FFTW.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},breaklines=true,language=C"
inline false
status open

\begin_layout Plain Layout

int main() 
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    fftw_complex *in  = fftw_malloc(sizeof(fftw_complex)*N);
\end_layout

\begin_layout Plain Layout

    fftw_complex *out = fftw_malloc(sizeof(fftw_complex)*N);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    fftw_plan p = fftw_plan_dft_1d(N, in, out, FFTW_FORWARD, FFTW_ESTIMATE);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    for (int i = 0; i < X; ++i)
\end_layout

\begin_layout Plain Layout

        fftw_execute(p);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    fftw_destroy_plan(p);
\end_layout

\begin_layout Plain Layout

    fftw_free(in), fftw_free(out);
\end_layout

\begin_layout Plain Layout

    return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:fft-alias-program"

\end_inset

C program snippet for computing the Fourier transform of N double precision
 complex numbers X times.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Installation and Configuration
\end_layout

\begin_layout Standard
We used the latest version 3.3.3 of FFTW in all our tests, compiled from source
 and built as a shared library.
 The configure script is invoked with the following parameters:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},breaklines=true"
inline false
status open

\begin_layout Plain Layout

./configure CC="gcc -march=native" --enable-shared --enable-sse2 --enable-avx
\end_layout

\end_inset


\end_layout

\begin_layout Standard
For optimal performance on our machine, we explicitly enable support for
 SSE2 and AVX instructions.
 In addition, we set the 
\begin_inset Quotes eld
\end_inset

arch
\begin_inset Quotes erd
\end_inset

 compiler flag to 
\begin_inset Quotes eld
\end_inset

native
\begin_inset Quotes erd
\end_inset

, allowing the GCC to specifically tune generated code to our architecture.
 
\end_layout

\begin_layout Paragraph
Setup and Methodology
\end_layout

\begin_layout Standard
FFTW is a very comprehensive library with lots of functionality.
 Our approach will be to concentrate on smaller transform sizes, and identify
 specific examples where bias is easily measurable.
 We create a small C program, shown in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:fft-alias-program"

\end_inset

, with two parameters; the number of elements to transform, and the number
 of times to repeat the transform.
 The iteration count is used to amplify any bias for smaller input sizes.
 The API calls made in the example are explained below.
\end_layout

\begin_layout Description
fftw_malloc A wrapper around the standard malloc, returning heap-allocated
 data.
 This is supposed to provide a stronger alignment guarantee than malloc
 does, needed for vectorized code.
 The system's default malloc might not align data on wide enough boundaries,
 although reasonable implementations do.
\end_layout

\begin_layout Description
fftw_plan_dft_1d This creates a 
\emph on
plan
\emph default
 for how to most efficiently compute a discrete Fourier transform of size
 
\begin_inset Formula $N$
\end_inset

.
 This step encapsulates the auto-tuning part of FFTW, as plans can be constructe
d based on actual measurements and benchmarks done on the current machine.
 Knowledge of well performing plans can be stored as 
\emph on
wisdom
\emph default
, which is used to construct other plans later.
\end_layout

\begin_layout Description
fftw_execute Perform the computations specified by the given plan, calculating
 the Fourier transform of 
\begin_inset Quotes eld
\end_inset

in
\begin_inset Quotes erd
\end_inset

 and writing the result to 
\begin_inset Quotes eld
\end_inset

out
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
This setup is specifically designed to identify sensitivity to changes in
 
\emph on
environment size
\emph default
.
 The assumption is that interactions with stack allocated variables from
 calling fftw_execute can potentially introduce bias.
 We search through different configurations manually, by specifying different
 values for iteration count and transform size.
 For all our experiments, we use the same machine and methodology as outlined
 in Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Methodology"

\end_inset

.
 Specifically looking for stack alignment bias, the most relevant performance
 metrics are cycle count and address aliasing (r0107:u).
 We use the automated test script to gather these metrics over increasing
 environment size.
 The program is run 512 times, adding 16 bytes to the environment between
 each iteration.
 This covers 8192 bytes of environment size, or two 4K segments, which should
 generate patterns repeating twice in case of bias from address aliasing.
\end_layout

\begin_layout Subsection
Bias from Environment Size
\end_layout

\begin_layout Standard
After attempting several different configurations for transform size and
 iteration count, we find that computing transforms of size 16 have noticeable
 bias.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:fftw-stack-bias"

\end_inset

 shows the relation between address alias and cycle count for repeated benchmark
s under increasing environment size.
 The effect is amplified by iterating 
\begin_inset Formula $X=$
\end_inset

 200,000 times, resulting in significant performance variations.
 We choose study this particular case in depth, with the purpose of finding
 out why aliasing occur and how it can be avoided.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Img/fft/default.eps

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:fftw-stack-bias"

\end_inset

Performance counter measurements for computing complex DFT of size 
\begin_inset Formula $N=16$
\end_inset

, repeated 
\begin_inset Formula $X=200{,}000$
\end_inset

 times.
 Address aliasing under some stack offsets negatively impacts cycle count.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Analysis of Aliasing Effects
\end_layout

\begin_layout Standard
The first step in determining the cause of aliasing is to look at exactly
 what code is executed.
 An overview of which kernels are used to execute a plan can be found by
 calling 
\family typewriter
fftw_print_plan
\family default
.
 In our case, the plan consists of a single kernel called 
\begin_inset Quotes eld
\end_inset

n1fv_16
\begin_inset Quotes erd
\end_inset

, compiled with AVX instructions enabled.
 Valgrind 
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset CommandInset href
LatexCommand href
name "http://valgrind.org/"
target "http://valgrind.org/"

\end_inset


\end_layout

\end_inset

 is used to analyze the call graph from fftw_execute, shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:call-graph"

\end_inset

.
 There is a chain of calls, eventually leading to the actual kernel invocation.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Img/fft/callgraph.eps

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:call-graph"

\end_inset

Call graph showing the actions taken after calling fftw_execute for the
 16 element transform.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The kernel itself is located in the file dft/simd/common/n1fv_16.c, which
 contains an automatically generated C program for computing a 16 element
 DFT
\begin_inset Foot
status open

\begin_layout Plain Layout
There are actually two separate implementations provided, one specifically
 optimized for architectures supporting fused multiply-add instructions.
 FFTW is compiled with FMA disabled in our case, as there are no such instructio
ns on Ivy Bridge.
\end_layout

\end_inset

.
 The function signature gives an idea of how the kernel works.
 There are 9 parameters, where the most interesting are input buffer (
\begin_inset Quotes eld
\end_inset

ri
\begin_inset Quotes erd
\end_inset

) and output buffer (
\begin_inset Quotes eld
\end_inset

ro
\begin_inset Quotes erd
\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},breaklines=true,language=C"
inline false
status open

\begin_layout Plain Layout

void n1fv_16(const R *ri, const R *ii, R *ro, R *io, stride is, stride os,
 INT v, INT ivs, INT ovs)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Conflicting memory accesses within this function are causing bias effects.
 Looking at the generated assembly, we find three areas of memory whose
 address suffixes can potentially overlap: 
\end_layout

\begin_layout Itemize
Heap allocated input and output buffers, parameters 
\begin_inset Quotes eld
\end_inset

ri
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

ro
\begin_inset Quotes erd
\end_inset

 respectively.
 These are pointers previously returned by calls to fftw_malloc, addresses
 in general unpredictable by the kernel, except for some alignment constraints.
\end_layout

\begin_layout Itemize
Stack allocated function parameters and local automatic variables.
 Compiled with optimization, the six first arguments will be passed in registers.
 The remaining three are pushed on stack.
 
\end_layout

\begin_layout Itemize
Statically allocated constants in memory.
 Three floating point constants are statically built into the object file,
 and their locations in memory are determined at runtime by the dynamic
 linker.
 
\end_layout

\begin_layout Standard
The static constants are loaded initially, using only a few load instructions.
 Because most memory access instructions are either to temporary stack variables
 or to heap, it is a fair assumption that address alias happens when stack
 accesses collide with heap addresses.
 Under synthetic testing with address randomization disabled, all parameters
 are fixed and deterministic.
 For our particular test, the heap allocated input and output buffers always
 reside in virtual addresses 0x602040 and 0x601c0 respectively -- on the
 low end of a 4K segment of suffixes between 0x000 and 0xfff.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Img/fft/collision-random-rsp.eps

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:stack-wild"

\end_inset

Position of stack can be aligned anywhere within the space of virtual addresses
 
\begin_inset Formula $\bmod$
\end_inset

 0x1000.
 With ASLR disabled, the last 12 bits of 
\family typewriter
ri
\family default
 and 
\family typewriter
ro
\family default
 are 0x040 and 0x1c0 respectively.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
As illustrated in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:stack-wild"

\end_inset

, the potential for overlap between stack and heap accesses will depend
 on where the stack is aligned, and the position of stack will vary with
 environment size.
 Alias effects likely occur when addresses of stack variables overlap with
 heap accesses.
 The program becomes 
\emph on
biased
\emph default
 to certain environment sizes, as it can execute with a 
\begin_inset Quotes eld
\end_inset

good
\begin_inset Quotes erd
\end_inset

 configuration with few collisions, or a 
\begin_inset Quotes eld
\end_inset

bad
\begin_inset Quotes erd
\end_inset

 configuration as in one of the periodic peaks illustrated in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:fftw-stack-bias"

\end_inset

.
 
\end_layout

\begin_layout Subsubsection*
Adjusting Stack to Avoid Aliasing
\end_layout

\begin_layout Standard
Assuming aliasing occurs from conflicts between stack and heap, bias can
 be eliminated by altering addresses of memory accesses to either of these
 areas.
 Once 
\family typewriter
fftw_execute
\family default
 is called, the only thing we can control is the placement of stack allocated
 variables.
 Our solution idea is to programmatically adjust the stack in such a way
 that accesses do not collide (alias) with heap memory.
 With heap allocated input and output buffers having address suffixes close
 to 0x000, a reasonable placement of stack is in the other side of the spectrum,
 close to 0xfff and expanding towards lower addresses.
 The concept is illustrated in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:naive-fix"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Img/fft/collision-fixed-rsp.eps

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:naive-fix"

\end_inset

Collisions can be avoided by reseting the stack pointer to an address that
 does not conflict with the heap allocated areas.
 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Looking at the call graph from Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:call-graph"

\end_inset

 again, we have several options for where to programmatically align stack
 on a suitable address.
 In order to be transparent to the user, the adjustments must happen in
 either 
\family typewriter
fftw_execute
\family default
, 
\family typewriter
fftw_dft_solve
\family default
, 
\family typewriter
apply_extra_iter
\family default
 or 
\family typewriter
n1fv_16
\family default
.
 In the end, we found that modifying 
\family typewriter
apply_extra_iter
\family default
 made the most sense, and also provided a slight gain compared to doing
 it within the kernel itself.
 As the name suggests, this function actually calls the kernel twice.
 
\end_layout

\begin_layout Standard
\noindent
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},breaklines=true"
inline false
status open

\begin_layout Plain Layout

static void apply_extra_iter(const plan *ego_, R *ri, R *ii, R *ro, R *io)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    void *rsp;
\end_layout

\begin_layout Plain Layout

    asm volatile (
\end_layout

\begin_layout Plain Layout

        "movq  %%rsp, %0;"
\end_layout

\begin_layout Plain Layout

        "andq  $-4096, %%rsp;"
\end_layout

\begin_layout Plain Layout

        : "=r"(rsp) : : );
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    /* original implementation */
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    asm volatile (
\end_layout

\begin_layout Plain Layout

        "movq  %0, %%rsp;"
\end_layout

\begin_layout Plain Layout

        : : "r"(rsp) : );
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:apply-extra-iter"

\end_inset

Modified 
\family typewriter
apply_extra_iter
\family default
, aligning stack to a 4K boundary.
 The hidden function body makes two calls to the 
\family typewriter
n1fv_16
\family default
 kernel.
 Implementation is located in the file 
\family typewriter
dft/direct.c
\family default
.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The modified function is shown in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:apply-extra-iter"

\end_inset

.
 The 
\family typewriter
andq
\family default
 instruction from will zero out the last 12 bits of the stack pointer (%rsp
 register), effectively subtracting some number between 0 and 4096.
 The stack grows downwards, thus subtracting any (reasonably small) amount
 will not overwrite other data.
 We run the same benchmark again, results shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:fftw-modified"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Img/fft/modified.eps

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:fftw-modified"

\end_inset

Performance after stack alignment fix is added to apply_extra_iter.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Over two 4K periods, the modified version is much less sensitive to stack
 placement, removing almost all the bias from previously.
 Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:fftw-kernel-fix-numbers"

\end_inset

 shows a reduction in cycle count by 11.8 % for the worst case, but unfortunately
 there is no significant speedup on average.
 
\end_layout

\begin_layout Standard
\begin_inset Float table
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="5">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Min
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Median
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Mean
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Max
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Default version
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
30,337,010
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
30,445,740
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
31,051,690
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
37,349,700
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Kernel modification
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
30,760,320
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
30,885,300
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
30,947,460
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
32,909,300
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:fftw-kernel-fix-numbers"

\end_inset

Cycle count statistics over 512 runs, sampling uniformly over two 4 KiB
 periods
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Even though we are able to remove most of the alias effects, performance
 did not improve as much as we had hoped.
 The constant overhead added by inserting the extra instructions in apply_extra_
iter consumes any aliasing improvement.
 About 1 million dynamic instructions are added to our example in the modified
 version, an increase of 1.3 %.
\end_layout

\begin_layout Paragraph
Evaluating the Worst Case Scenario
\end_layout

\begin_layout Standard
With address randomization disabled, both stack and heap locations will
 be fixed for all environment sizes.
 If however heap buffers happen to reside on the opposite end of a 4 KiB
 segment, both stack and heap segments will be close considering the last
 12 address bits.
 By allocating another buffer of 7400B using regular malloc before calling
 fftw_malloc, the input and output buffers are pushed to 0x604
\series bold
da0
\series default
 and 0x604
\series bold
f00
\series default
 respectively.
 The relative position between each memory segment in this scenario is shown
 in Figure
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:fftw-worstcase-4k"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Img/fft/collision-overlap.eps

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:fftw-worstcase-4k"

\end_inset

Offsetting heap addresses to always overlap with fixed stack pointer
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
With both heap and stack addresses suffixes located on the 
\begin_inset Quotes eld
\end_inset

high
\begin_inset Quotes erd
\end_inset

 end, there will always be aliasing.
 The effect is shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:fftw-worstcase"

\end_inset

.
 As expected, a constant number of alias events are added across all environment
 sizes.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Img/fft/worstcase.eps

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:fftw-worstcase"

\end_inset

Bad heap alignment combined with static stack alignment results in aliasing
 consistently across all environment sizes
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
A Generic Solution
\end_layout

\begin_layout Standard
The static rule of aligning stack to page boundary only works with ASLR
 disabled, and because our fftw_malloc happens to place 
\begin_inset Quotes eld
\end_inset

ri
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

ro
\begin_inset Quotes erd
\end_inset

 close to the lower end of a 4 KiB range of address suffixes.
 A complete solution would require a function at least these three parameters
 to calculate the optimal stack offset.
\begin_inset Formula 
\[
f\left(\text{input},\text{output},\text{stack position}\right)\rightarrow\text{offset}
\]

\end_inset


\end_layout

\begin_layout Standard
A plausible solution to the worst case scenario from Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:fftw-worstcase-4k"

\end_inset

 would be to align stack to start at 
\family typewriter
ri
\family default
, no longer overlapping any heap segments.
 However, given the somewhat discouraging results from our simple static
 fix, we did not attempt to implement a function like this for the n1fv_16
 kernel.
 Using inline assembly, the cost of additional dynamic instructions will
 quickly cancel out any speedup we might get.
\end_layout

\begin_layout Subsection
Bias in Other Kernels
\end_layout

\begin_layout Standard
While we have only looked extensively at one particular kernel, FFTW consists
 of a quite large collection of automatically generated codelets.
 Other kernels can be invoked by specifying different values for 
\begin_inset Formula $N$
\end_inset

 in the test program.
 We find that alias effects are apparent in all kernels we tried, a selection
 of them shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:fftw-kernels"

\end_inset

.
 Each kernel shows a different pattern, with clear bias towards some stack
 positions that performs noticeably better than others.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Img/fft/kernels.eps

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:fftw-kernels"

\end_inset

Cycle and alias counts for four additional kernels, for 8, 15, 20 and 32
 element complex DFTs respectively.
 Plot shows 
\begin_inset Formula $N=200{,}000$
\end_inset

 iterations of the kernel, incrementing stack offset (horizontal axis) between
 each run, up to 4096 bytes.
 Vertical axis is given in millions.
 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Ways to Account for Address Alias
\end_layout

\begin_layout Standard
The main problem we faced when trying to do anything about aliasing within
 FFTW itself, was that too many dynamic instructions are added in the process.
 The problem is of course that the hack is implemented inside the hot loop,
 where fftw_execute is called repeatedly.
 However, we can also align stack 
\emph on
before
\emph default
 the loop, adding only a negligible overhead.
 The relevant parts of our modified main function is shown in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:fftw-stackfix-main"

\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},language=C,showstringspaces=false"
inline false
status open

\begin_layout Plain Layout

    void *rsp;
\end_layout

\begin_layout Plain Layout

    __asm__ volatile (
\end_layout

\begin_layout Plain Layout

        "movq  %%rsp, %0;"
\end_layout

\begin_layout Plain Layout

        "andq  $-4096, %%rsp;"
\end_layout

\begin_layout Plain Layout

        : "=r"(rsp) : : );
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    for (int i = 0; i < X; ++i)
\end_layout

\begin_layout Plain Layout

        fftw_execute(p);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    __asm__ volatile (
\end_layout

\begin_layout Plain Layout

        "movq   %0, %%rsp;"
\end_layout

\begin_layout Plain Layout

        : : "r"(rsp) : );
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:fftw-stackfix-main"

\end_inset

Modified test program with forced stack alignment in main.
 Stack pointer is saved to a temporary variable before aligned to a 4 KiB
 boundary, then restored once we are done.
 Only a couple additional instructions are executed, with a significant
 performance increase on average over all environment sizes.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
With ASLR disabled, keeping the heap addresses constant through all runs,
 we are now able to avoid 
\emph on
all
\emph default
 alias effects for the n1fv_16 kernel.
 If we were to plot the results, the graph for cycle count and alias events
 would be completely flat.
 As shown in Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:fftw-stackfix-main"

\end_inset

, the average cycle count is reduced from 31,051,690 to 30,425,240, a speedup
 of 1.02x.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="5">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Min
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Median
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Mean
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Max
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Default
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
30,337,010
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
30,445,740
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
31,051,690
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
37,349,700
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Kernel modification
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
30,760,320
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
30,885,300
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
30,947,460
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
32,909,300
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Modified main
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
30,350,120
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
30,427,600
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
30,425,240
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
30,585,470
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:fftw-stackfix-main"

\end_inset

Cycle count statistics over 512 runs, sampling uniformly over two 4KiB stack
 position periods.
 Notice a significant improvement on average with stack alignment in main.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
There is clearly a potential for speedup of FFTW kernels by accounting for
 aliasing in some way.
 However, requiring users of the library to fiddle with the stack before
 calling fftw_execute is not a satisfactory solution.
 A more reasonable approach would be to incorporate these ideas in the steps
 performed 
\emph on
prior
\emph default
 to executing a plan.
 
\end_layout

\begin_layout Subsubsection*
Planning for Alias
\end_layout

\begin_layout Standard
A more realistic solution is to give this responsibility to the planner.
 Note that the heap addresses are already required when computing a plan.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},language=C"
inline false
status open

\begin_layout Plain Layout

fftw_plan_dft_1d(N, in, out, FFTW_FORWARD, FFTW_ESTIMATE);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As we have shown, the optimal stack position for each kernel depends on
 the memory addresses of input and output arrays, but the component that
 is missing is stack position.
 In principle, planning using a more thorough planner which considers empirical
 timings (for example using 
\family typewriter
FFTW_MEASURE
\family default
) could cancel out bias if the following were true;
\end_layout

\begin_layout Enumerate
Multiple alternative kernels with varying alias characteristics exists.
 
\end_layout

\begin_layout Enumerate
The call chain are the same during benchmarking in the planner as when the
 plan is later executed.
 Stack addresses during planning must be the same.
\end_layout

\begin_layout Standard
Unfortunately, the planner can not know the stack depth of which a user
 calls fftw_execute with a given plan.
 Simply benchmarking multiple alternative implementation to find which one
 does not suffer from bias will not work in general.
 On the contrary, empirical planning might actually falsely predict which
 kernels are good.
 A hypothetical scenario would be if planning is done in a memory environment
 that are not affected by aliasing, and later executed in a worst-case environme
nt for aliasing.
 
\end_layout

\begin_layout Subsubsection*
Allocating Alias-free
\end_layout

\begin_layout Standard
FFTW comes with fftw_malloc, which is a wrapper around regular malloc with
 stronger alignment guarantees.
 The purpose of using this is to optimize for use with SIMD instructions.
 In cases where address conflicts between heap data can occur, extending
 fftw_malloc to avoid returning aliased heap segments would be a realistic
 solution.
 For the n1fv_16 kernel, we found that alias in heap addresses did not matter.
 However, this is not necessarily true for all kernels.
 Looking into possible improvements here might be worthwhile.
 
\begin_inset Newpage clearpage
\end_inset


\end_layout

\begin_layout Section
BLAS
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sec:BLAS"

\end_inset

Basic Linear Algebra Subroutines (BLAS), is the de facto standard API for
 high performance linear algebra routines 
\begin_inset Foot
status open

\begin_layout Plain Layout
BLAS (Basic Linear Algebra Subprograms) 
\begin_inset CommandInset href
LatexCommand href
name "http://www.netlib.org/blas/"
target "http://www.netlib.org/blas/"

\end_inset


\end_layout

\end_inset

.
 The functionality is divided into three categories: 
\end_layout

\begin_layout Description
Level
\begin_inset space ~
\end_inset

1 Scalar and vector operations, such as dot product and vector addition.
\end_layout

\begin_layout Description
Level
\begin_inset space ~
\end_inset

2 Matrix-vector operations
\end_layout

\begin_layout Description
Level
\begin_inset space ~
\end_inset

3 Matrix-matrix operations, including the widely applied 
\family typewriter
gemm
\family default
 matrix multiplication.
 
\end_layout

\begin_layout Standard
Many highly optimized implementations of BLAS exists.
 We will look at ATLAS, which similar to FFTW uses automatic tuning to optimize
 for the underlying hardware 
\begin_inset CommandInset citation
LatexCommand cite
key "Whaley:2000:ATLAS"

\end_inset

.
 
\end_layout

\begin_layout Subsection
Address Aliasing in 
\family typewriter
cblas_dgemv
\end_layout

\begin_layout Standard
Consider matrix-vector multiplication of the form 
\begin_inset Formula $\boldsymbol{y}=A\boldsymbol{x}$
\end_inset

.
 Let 
\begin_inset Formula $A$
\end_inset

 be of size 
\begin_inset Formula $M\times N$
\end_inset

, where 
\begin_inset Formula $M$
\end_inset

 is the number of rows.
 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\left[\begin{array}{ccccc}
a_{0,0} & a_{0,1} &  &  & a_{0,N}\\
a_{1,0}\\
 &  &  & \ddots\\
a_{M,0} &  &  &  & a_{M,N}
\end{array}\right]\left[\begin{array}{c}
x_{0}\\
x_{1}\\
\vdots\\
\\
x_{N}
\end{array}\right]=\left[\begin{array}{c}
y_{0}\\
y_{1}\\
\vdots\\
y_{M}
\end{array}\right]
\]

\end_inset


\end_layout

\begin_layout Standard
The corresponding BLAS function is the level 2 
\family typewriter
gemv
\family default
 routine, computing the more general matrix-vector product given as 
\begin_inset Formula 
\[
\boldsymbol{y}=\alpha\text{op}\left(A\right)\boldsymbol{x}+\beta\boldsymbol{y}
\]

\end_inset

Here, 
\begin_inset Formula $\alpha$
\end_inset

 and 
\begin_inset Formula $\beta$
\end_inset

 are constants, and 
\begin_inset Formula $\text{op}\left(A\right)$
\end_inset

 is an optional transpose or complex conjugate of the matrix.
 A typical invocation of this routine is shown in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:blas-gemv"

\end_inset

.
 We set 
\begin_inset Formula $\alpha=1$
\end_inset

, 
\begin_inset Formula $\beta=0$
\end_inset

 and 
\begin_inset Formula $\text{op}\left(A\right)=A$
\end_inset

 to reduce the formula to 
\begin_inset Formula $\boldsymbol{y}=A\boldsymbol{x}$
\end_inset

.
 Note that 
\begin_inset Formula $A$
\end_inset

 is declared as 
\family typewriter
CblasColMajor
\family default
, meaning we impose a column major ordering of the data.
 The prefix indicates data type, in this case d for double.
 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},breaklines=true,language=C"
inline false
status open

\begin_layout Plain Layout

cblas_dgemv(CblasColMajor, CblasNoTrans, M, N, alpha, A, M, x, 1, beta,
 y, 1);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We find that ATLAS is vulnerable to aliasing in matrix-vector multiplication
 with column-major ordering.
 For a simple program with 
\begin_inset Formula $N=M=8192$
\end_inset

, performance varies quite significantly with different heap addresses of
 
\begin_inset Formula $A$
\end_inset

, 
\begin_inset Formula $\boldsymbol{x}$
\end_inset

 and 
\begin_inset Formula $\boldsymbol{y}$
\end_inset

.
 As might be suspected, the worst case seems to be when all memory buffers
 align closely on the same 12 bit suffix.
 
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="6">
<features booktabs="true" tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
&A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
&x
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
&y
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Cycles (cycles:u)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Alias (r0107:u)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(a)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x2aaaac292
\family default
\series bold
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
010
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x607
\series bold
010
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x617
\series bold
020
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
195,155,171
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
34,095,566
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(b)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x2aaaac292
\family default
\series bold
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
010
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x607
\series bold
010
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x6170b0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
186,788,588
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5,724,675
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(c)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x2aaaac292010
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x6073d0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x6173e0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
180,778,001
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
37,555
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:dgemv"

\end_inset

Performance counter statistics for a simple program invoking ATLAS' cblas_dgemv
 with matrix size 
\begin_inset Formula $8192\times8192$
\end_inset

.
 Cycle count and aliasing varies with different heap addresses for 
\begin_inset Formula $A$
\end_inset

, 
\begin_inset Formula $\boldsymbol{x}$
\end_inset

 and 
\begin_inset Formula $\boldsymbol{y}$
\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Performance counter statistics shown in Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:dgemv"

\end_inset

 are obtained from invoking cblas_dgemv once, in the main function of a
 small C program.
 Still, the measurement does not represent the true cost of aliasing for
 dgemv, as overhead from things like memory allocation is also counted.
 
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},breaklines=true,language=C"
inline false
status open

\begin_layout Plain Layout

int main() {
\end_layout

\begin_layout Plain Layout

    const double alpha = 1.0, beta = 0.0;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    double *A = malloc(sizeof(double) * M * N);
\end_layout

\begin_layout Plain Layout

    double *x = malloc(sizeof(double) * N);
\end_layout

\begin_layout Plain Layout

    double *y = malloc(sizeof(double) * M);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    for (int i = 0; i < K; ++i)
\end_layout

\begin_layout Plain Layout

        cblas_dgemv(CblasColMajor, CblasNoTrans, M, N, alpha, A, M, x, 1,
 beta, y, 1);
\end_layout

\begin_layout Plain Layout

    return 0:
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:blas-gemv"

\end_inset

Computing double precision matrix-vector multiplication 
\begin_inset Formula $\boldsymbol{y}=A\boldsymbol{x}$
\end_inset

 using 
\family typewriter
dgemv
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
To better be able to assess the effects of aliasing, the call to gemv needs
 to be isolated.
 We use the program from Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:blas-gemv"

\end_inset

 to make two benchmarks, one with 
\begin_inset Formula $K=1$
\end_inset

 and another with 
\begin_inset Formula $K=101$
\end_inset

.
 The approximated cost for a single invocation of dgemv can be expressed
 as 
\begin_inset Formula 
\[
t_{\text{estimate}}=\frac{t_{K=101}-t_{K=1}}{100}
\]

\end_inset


\end_layout

\begin_layout Standard
Where 
\begin_inset Formula $t$
\end_inset

 represents some metric, such as the number of cycles.
 Subtracting the 
\begin_inset Formula $K=1$
\end_inset

 run removes the constant overhead from the 
\begin_inset Formula $K=101$
\end_inset

 run.
 Dividing by 
\begin_inset Formula $100$
\end_inset

 averages the values from the remaining iterations.
 Other iteration counts could have been used as well.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement t
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{small}
\end_layout

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="12" columns="4">
<features booktabs="true" tabularvalignment="middle">
<column alignment="left" valignment="top" width="0">
<column alignment="right" valignment="top" width="0pt">
<column alignment="right" valignment="top" width="0">
<column alignment="right" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(a)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(b)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(c)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
UnHalted Core Cycles
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
60,578,750
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
51,654,310
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
46,059,028
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\shape smallcaps
ld_blocks_partial.address_alias
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
33,444,229
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
3,805,742
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
2,322
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\shape smallcaps
mem_uops_retired.stores
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
16,781,370
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
16,781,370
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
16,781,370
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\shape smallcaps
mem_uops_retired.loads
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
58,745,150
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
58,745,734
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
58,745,216
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\shape smallcaps
mem_load_uops_retired.hit_lfb
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
6,106,659
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
7,942,348
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
6,043,806
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\shape smallcaps
mem_load_uops.retired.l1_hit
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
52,189,609
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
49,964,781
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
51,675,427
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\shape smallcaps
mem_load_uops.retired.l2_hit
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
448,620
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
838,025
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
1,025,608
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\shape smallcaps
mem_load_uops.retired.llc_hit
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
-29
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
531
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
178
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\shape smallcaps
mem_load_uops.retired.llc_miss
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
7
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
61
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
18
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\shape smallcaps
load_hit_pre.hw_pf
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
14,425,267
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
13,428,234
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
6,332,654
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\shape smallcaps
cycle_activity.cycles_ldm_pending
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
121,057,180
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
103,250,874
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
91,998,759
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{small}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:gemv-estimate"

\end_inset

Estimated cost of a single invocation of 
\family typewriter
cblas_dgemv
\family default
 with matrix size 
\begin_inset Formula $8192\times8192$
\end_inset

 in ATLAS.
 Each column shows statistics for different heap addresses.
 The 12 bit address suffixes for 
\begin_inset Formula $A$
\end_inset

, 
\begin_inset Formula $\boldsymbol{x}$
\end_inset

 and 
\begin_inset Formula $\boldsymbol{y}$
\end_inset

 in each case is (0x010, 0x010, 0x020) for column a, (0x010, 0x010, 0xb0)
 for b and (0x010, 0x3d0, 0x3e0) for c.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Performance counter statistics for each of the three address configurations
 from Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:dgemv"

\end_inset

 are shown in Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:gemv-estimate"

\end_inset

.
 In addition to cycle count and alias events, a number of relevant metrics
 such as cache hit rates are included.
 Notice that almost all load micro-ops are served by either the line feed
 buffer or L1 cache in all cases.
 Only a small amount of loads comes from L2, and almost none from L3.
 The hit rate for L1 actually decreases somewhat (considering LFB as well)
 with better execution time.
 This could be explained by less time for prefetchers to feed the L1 cache
 with data.
 The hardware prefetch counter indicates more hits in cases a and b.
 Again, we find that cache efficiency does not explain the performance cliffs
 we observe.
 Our results show that variations in memory addresses alone can give a speedup
 of more than 31 % for matrix-vector multiplication in ATLAS.
 
\end_layout

\begin_layout Subsection
Dealing With Bias
\end_layout

\begin_layout Standard
For the particular case we investigated, a good heuristic is to align heap
 segments 
\begin_inset Quotes eld
\end_inset

far apart
\begin_inset Quotes erd
\end_inset

 within the 4 KiB area of 12 bit suffixes.
 More specifically, it appears that address suffixes of 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $\boldsymbol{y}$
\end_inset

 are the most important to separate.
 
\end_layout

\begin_layout Standard
Using heap allocated memory, address aliasing is an artifact of the allocator
 used.
 A possible run time solution to adjust heap addresses can be realized as
 follows:
\end_layout

\begin_layout Enumerate
Allocate some extra space for one of the vectors when calling malloc, for
 instance 
\family typewriter
sizeof(double) * (M + 0x100)
\family default
 for 
\begin_inset Formula $\boldsymbol{y}$
\end_inset

.
\end_layout

\begin_layout Enumerate
Check the returned pointers for potential alias, i.e.
 the difference between 
\family typewriter
&A
\family default
 and 
\family typewriter
&y
\family default
.
 Offset using pointer arithmetic into the array with extra padding at the
 end, i.e.
 
\family typewriter
y += 0x100
\family default
.
 
\end_layout

\begin_layout Standard
Another option is to explicitly account for 
\begin_inset Quotes eld
\end_inset

worst cases
\begin_inset Quotes erd
\end_inset

 in the implementation of routines that are vulnerable to aliasing.
 Addresses can be explicitly checked for potential conflicts in cblas_dgemv,
 and if possible branch to code that will not suffer from aliasing.
 
\end_layout

\begin_layout Subsection
Conclusion
\end_layout

\begin_layout Standard
We briefly looked at potential bias effects in BLAS routines, and found
 that matrix-vector multiplication in ATLAS suffered from alias effects.
 Close alignment within a 4K segment of addresses can have a significant
 performance penalty.
 Users of BLAS packages are probably more willing to invest in hand optimizing
 hot spots where aliasing might occur.
 It is also not unlikely that one or more matrix-vector operations are part
 of a hot loop.
 Bias from address alias will probably be worth considering in some cases.
 
\end_layout

\begin_layout Chapter
Conclusions and Future Work
\end_layout

\begin_layout Standard
In this thesis we have studied effects of contextual bias on the Intel Core
 
\begin_inset Quotes eld
\end_inset

Ivy Bridge
\begin_inset Quotes erd
\end_inset

 architecture, and shown how avoiding bias can also improve performance.
 The premise for our work relies heavily in previous work done by Mytkowicz
 et al.
 Their study of measurement bias in earlier architectures showed that changes
 to environment variables and link order could heavily impact performance.
 Furthermore, the effects were concluded to be unpredictable and difficult
 to account for.
 Questions of what actually causes bias are left largely unanswered, which
 leaves room for valuable research.
 Our goal was to gain a better understanding of the mechanisms causing bias
 effects, and if possible use this knowledge to improve performance of real
 world applications.
\end_layout

\begin_layout Standard
As a starting point for our research, we chose to study the micro-kernel
 first presented in 
\begin_inset CommandInset citation
LatexCommand cite
key "Mytkowicz:2009:WrongData"

\end_inset

.
 It was not clear whether bias effects were even an issue on our architecture,
 as previous work studied mostly Core 2 and earlier processors.
 Being able to reproduce similar effects from changing environment size
 motivated continued exploration.
 In Chapter 3, we present an in-depth study of what was causing bias for
 that particular program.
 Through careful measurements using hardware performance counters, we find
 that address aliasing between local and static variables can explain what
 is happening.
 
\end_layout

\begin_layout Standard
With an understanding of the possible performance penalties incurred from
 aliasing, we explore what other use cases might be affected by this.
 The fact that malloc often allocates on page boundary by default proved
 to be troubling, essentially guaranteeing bad performance from aliasing
 in many cases.
 The convolution example exploits this synergy between heap allocation and
 4K aliasing, showing that some knowledge of the hardware could provide
 massive speedup in real world applications.
 
\end_layout

\begin_layout Standard
The Loop Stream Detector had been previously mentioned as a possible cause
 of bias.
 Studying the LSD proved to be challenging, because most of the documentation
 was either incomplete or misleading.
 Using several hand coded assembly programs, we were able to identify the
 correct parameters for the Ivy Bridge LSD.
 Interestingly, the capacity was improved compared to previous generations,
 not reflected in the documentation.
 With a clear understanding of the chunk fetch limit, we were able to identify
 cases where link ordering caused serious bias effects.
 The underlying reason proved to be code layout with respect to 32 byte
 chunks, where a maximum of 12 chunks would fit in the LSD cache.
 
\end_layout

\begin_layout Standard
In our case studies, we chose to concentrate on highly optimized numerical
 libraries.
 Applications like these are more likely to incorporate extremely processor
 specific optimizations, in order to achieve the maximum possible performance.
 We were able to identify bias towards certain stack positions for small
 kernels in FFTW, caused by 4K aliasing.
 Attempts were made to align stack dynamically in the kernels, but the added
 dynamic instructions quickly incur too large of an overhead to be worth
 it.
 
\end_layout

\begin_layout Standard
Lastly, we wanted to investigate whether BLAS libraries also suffered from
 bias.
 We suspected that certain operations might be sensitive to aliasing between
 heap buffers, similar to the effects pointed out in Chapter 3.
 The impact of address aliasing in matrix-vector multiplication proved to
 be huge, even for an automatically tuned ATLAS installation.
 By manually adjusting alignment of matrix and vector buffers, speedups
 of over 30 % can be achieved for invocations of dgemv.
 
\end_layout

\begin_layout Section
Contributions
\end_layout

\begin_layout Standard
Previous work identifies 
\emph on
environment variables
\emph default
 and 
\emph on
link order
\emph default
 as potential triggers of bias effects in performance analysis 
\begin_inset CommandInset citation
LatexCommand cite
key "Mytkowicz:2009:WrongData"

\end_inset

.
 The main purpose of this work was to gain an understanding of the underlying
 effects causing measurement bias.
 We have identified and documented two such architecture-specific properties
 of the Intel Core 
\begin_inset Quotes eld
\end_inset

Ivy Bridge
\begin_inset Quotes erd
\end_inset

;
\end_layout

\begin_layout Itemize
4K address aliasing: Alias on the last 12 bits can cause false conflicts
 in the memory ordering system, biasing performance towards certain data
 layouts.
\end_layout

\begin_layout Itemize
Loop Stream Detector: Limitations in micro-op caches favors code with certain
 static memory layouts.
\end_layout

\begin_layout Standard
It is important to point out that limitations of the LSD and the existence
 of 4K aliasing is not new or unknown.
 Although scarcely documented, both of these issues are discussed to some
 extent in the processor vendor manuals.
 However, modern CPU architectures are tremendously complicated, and very
 few people would even care to read the manuals for arcane details of these
 topics.
 
\end_layout

\begin_layout Standard
Our work extends to the documented processor behavior, and links these propertie
s to the concept of measurement bias.
 We show how code and data layout in memory can affect program performance,
 finally providing satisfactory explanations of measurement bias that can
 be observed from changing link order or environment variables.
 We also present other bias triggers not mentioned in previous work.
 Functionality of heap allocators is important for address aliasing, and
 bias effects can occur from using different versions or implementations.
 In addition to link ordering, other properties that changes code layout
 can affect usage of the Loop Stream Detector.
 Things like the order of functions within a source file, or the length
 of external symbols, can be significant.
 
\end_layout

\begin_layout Standard
Unlike stated in previous work, we find that bias is in fact 
\emph on
not
\emph default
 entirely unpredictable.
 Furthermore, a clear understanding of what causes bias is necessary in
 order achieve optimal performance in real applications.
 Our results are relevant to anyone who care about optimizing program performanc
e on modern Intel architectures.
\end_layout

\begin_layout Section
Directions for Future Work
\end_layout

\begin_layout Standard
Studying sources of bias effects proved to be complicated and challenging.
 One of the main problems is lack of accurate documentation, making the
 processor a kind of 
\begin_inset Quotes eld
\end_inset

black box
\begin_inset Quotes erd
\end_inset

.
 We believe that we have only scratched the surface when it comes to interesting
 and lesser known architectural features.
 The optimization manual 
\begin_inset CommandInset citation
LatexCommand cite
key "Intel:2012:OptimizationManual"

\end_inset

 is a good starting point for further research, describing how various hardware
 features interact and operate.
 Some of the features we think might be worthwhile to investigate include;
\end_layout

\begin_layout Itemize
Decoded ICache limitations: We observed corner cases of the Loop Stream
 Detector that were probably related to micro-ops not being cached.
 Figuring out the exact parameters for the micro-op cache could help compilers
 generate optimal code layout.
 
\end_layout

\begin_layout Itemize
Hyper-threading: This feature was disabled throughout our testing to avoid
 any interference.
 We imagine there are many interesting performance implication occurring
 from threads competing about resources.
 For example, the LSD micro-op limitation being shared between logical cores
 is clearly a potential source of bias towards systems without hyper-threading
 enabled.
 
\end_layout

\begin_layout Standard
Further work is needed to lift more of the knowledge buried among technical
 details in official manuals.
 With increased awareness of these effects, there is clearly a potential
 for improving performance of existing programs.
\end_layout

\begin_layout Subsection
Compiler Optimizations
\end_layout

\begin_layout Standard
The most natural place to encode architectural-specific knowledge used for
 optimization is of course in compilers.
 In an ideal world, programmers would not need to care about intricate corner
 cases in hardware to achieve the best performance.
 Optimizing code layout for maximal usage of the Loop Stream Detector could
 be a worthwhile endeavor.
 We did not investigate to what degree this is handled by modern compilers
 other than GCC, but would not be surprised if there is considerable room
 for improvement.
 
\end_layout

\begin_layout Standard
Generating alias-free code could potentially also be done by the compiler.
 We show how aliasing can be avoided by adding alternative code paths in
 Chapter 3, which at least in principle shows that compilers could handle
 this in some cases.
 Code that relies on heap-allocated buffers seems like a particularly difficult
 thing to optimize for.
 A starting point could be to detect functions that might suffer from aliasing
 via some static analysis, perhaps issuing a warning.
\end_layout

\begin_layout Standard
Using 
\emph on
profiling
\emph default
 information could be another way of identifying potential bias related
 issues.
 GCC has support for two-stage compilation, using profiling information
 from an intrumented version of the program to aid in optimization of the
 final compilation.
 Encoding knowledge of for example 4K aliasing in a profiling step seems
 feasible.
\end_layout

\begin_layout Subsection
Alias-free Allocators
\end_layout

\begin_layout Standard
We show that typical memory allocators are prone to cause aliasing in 
\emph on
all
\emph default
 cases, because heap memory is often page aligned.
 As far as we know, there are no malloc implementations that specifically
 addresses aliasing issues.
 Developing good heuristics on the optimal heap addresses to return from
 malloc would be an interesting topic for further research.
 An obvious improvement would be to perturb addresses of allocations done
 with mmap, avoiding identical 12 bit address suffixes of large allocations.
\end_layout

\begin_layout Subsection
Library Optimizations
\end_layout

\begin_layout Standard
In our case studies, we found that bias effects from address aliasing affected
 both FFTW and ATLAS.
 For highly optimized numerical libraries in particular, there should be
 incentive to account for address aliasing to improve performance.
 
\end_layout

\begin_layout Standard
In cases where aliasing depend on heap allocated memory, a possible solution
 could be to provide special-purpose wrappers around malloc.
 FFTW already has fftw_malloc, which would be a perfect place to encode
 knowledge about aliasing.
 We did not find any effects from conflicts between heap areas in the particular
 kernel we studied, but other kernels or code within FFTW might be sensitive
 to this.
 Providing a similar function for BLAS implementations is also an option.
 
\end_layout

\begin_layout Standard
There is probably also opportunities for writing code that is less sensitive
 to data alignment.
 In the case of matrix-vector multiplication, it might be possible to access
 data in a different order depending on heap addresses.
 By explicitly checking the addresses of input parameters, different code
 paths can be chosen to avoid aliasing.
 With potential for over 30 % performance improvement in the worst case,
 the added cost and complexity is probably acceptable.
 
\end_layout

\begin_layout Standard
The extent and impact of bias in other libraries is also an open question.
 Of the two we studied, we were able to identify address aliasing fairly
 easily.
 We suspect that this is a common phenomenon, and worth investigating for
 developers of performance critical applications.
\end_layout

\begin_layout Subsection
Other Architectures
\end_layout

\begin_layout Standard
We limited our study to one specific architecture, the at the time of writing
 most recent 
\begin_inset Quotes eld
\end_inset

Ivy Bridge
\begin_inset Quotes erd
\end_inset

 from Intel.
 An interesting question is whether effects from Loop Stream Detector limitation
s and 4K aliasing translate to other CPU architectures.
 Effects from 4K aliasing are documented in architectures as far back as
 the first Core processors 
\begin_inset CommandInset citation
LatexCommand cite
key "Intel:2012:OptimizationManual"

\end_inset

.
 Limitations of the LSD have changed throughout the last several generations,
 suggesting that the particular examples we present might not behave similarly
 on other Intel processors.
 Processor architectures changes at a rapid pace, and by the time this thesis
 is published the 
\begin_inset Quotes eld
\end_inset

Ivy Bridge
\begin_inset Quotes erd
\end_inset

 will have been replaced by 
\begin_inset Quotes eld
\end_inset

Haswell
\begin_inset Quotes erd
\end_inset

.
 More research is needed on sources of bias effects, both in previous and
 future architectures.
 
\end_layout

\begin_layout Section
Final Words
\end_layout

\begin_layout Standard
Our work shows that 4K aliasing and the Loop Stream Detector, both intricate
 and highly architecture-specific properties of the processor, can have
 significant performance impact in real software.
 Raising awareness of the importance of memory layout of code and data is
 relevant to both users and developers of performance critical software.
 A continual effort to expand and update this knowledge for current and
 future architectures is needed.
 
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "references"
options "bibtotoc,acm"

\end_inset


\end_layout

\begin_layout Chapter
\start_of_appendix
List of Performance Counters
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "chap:list-of-performance-counters"

\end_inset


\end_layout

\begin_layout Standard
There are two categories of performance events; 
\emph on
architectural events
\emph default
 are defined across families of microarchitectures, where the same event
 codes are supported on a range of processors.
 
\emph on
Non-architectural
\emph default
 events are specific to each architecture.
 The following includes a reference of important counters discussed in this
 thesis.
 
\end_layout

\begin_layout Section*
Architectural Events
\end_layout

\begin_layout Standard
The following architectural events are supported on processors based on
 the Intel Core microarchitecture.
 Adapted from Table 19-1 in the Software Developer's Manual 
\begin_inset CommandInset citation
LatexCommand cite
key "Intel:2013:Volume3B"

\end_inset

.
\end_layout

\begin_layout Standard
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begingroup
\backslash
tabcolsep=3pt
\backslash
begin{small}
\end_layout

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="5">
<features booktabs="true" tabularvalignment="middle" tabularwidth="100text%">
<column alignment="center" valignment="top" width="8text%">
<column alignment="center" valignment="top" width="9text%">
<column alignment="left" valignment="top" width="34text%">
<column alignment="left" valignment="top" width="15text%">
<column alignment="left" valignment="top" width="25text%">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Event num.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Umask value
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Event Mask Mnemonic
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Perf mnemonic
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Description
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x3C
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x00
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
UnHalted Core Cycles
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
cycles
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
3C
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
01
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
UnHalted Reference Cycles
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
bus-cycles
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
C0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
00
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Instruction Retired
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
instructions
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
2E
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
4F
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
LLC Reference
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
cache-references
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Last level cache references
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
2E
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
41
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
LLC Misses
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
cache-misses
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Last level cache misses
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
C4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
00
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Branch Instruction Retired
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
branches
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Branch instruction at retirement
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
C5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
00
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Branch Misses Retired
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
branch-misses
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Mispredicted Branch Instruction at retirement
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{small}
\backslash
endgroup
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section*
Non-Architectural Events
\end_layout

\begin_layout Standard
This following table contains a subset of the non-architectural performance
 counters available on 3rd generation Intel Core 
\begin_inset Quotes eld
\end_inset

Ivy Bridge
\begin_inset Quotes erd
\end_inset

 processors.
 The official reference can be found in Table 19-5 in the Software Developer's
 Manual 
\begin_inset CommandInset citation
LatexCommand cite
key "Intel:2013:Volume3B"

\end_inset

.
 Note that 
\shape smallcaps
lsd_overflow
\shape default
 and 
\shape smallcaps
lsd.uops
\shape default
 are included in this list, despite not being officially supported.
\end_layout

\begin_layout Standard
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begingroup
\backslash
tabcolsep=3pt
\backslash
begin{small}
\end_layout

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="35" columns="4">
<features booktabs="true" islongtable="true" longtabularalignment="center">
<column alignment="center" valignment="top" width="8text%">
<column alignment="center" valignment="top" width="9text%">
<column alignment="left" valignment="top" width="38text%">
<column alignment="left" valignment="top" width="40text%">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Event num
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Umask value
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Event Mask Mnemonic
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Description
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x03
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x02
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
LD_BLOCKS.
 STORE_FORWARD
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Loads blocked by overlapping with store buffer that cannot be forwarded
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x07
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x01
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
LD_BLOCKS_PARTIAL.
 ADDRESS_ALIAS
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
False dependencies in MOB due to partial compare on address
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x20
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x01
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
LSD_OVERFLOW
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Counts number of loops that can't stream from the instruction queue
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x2E
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x4F
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
LONGEST_LAT_CACHE.
 REFERENCE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
This event counts requests originating from the core that reference a cache
 line in the last level cache.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x2E
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x41
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
LONGEST_LAT_CACHE.MISS
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
This event counts each cache miss condition for references to the last level
 cache.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x3C
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x00
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CPU_CLK_UNHALTED.
 THREAD_P
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Counts the number of thread cycles while the thread is not in a halt state.
 The thread enters the halt state when it is running the HLT instruction.
 The core frequency may change from time to time due to power or thermal
 throttling.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x3C
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x01
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CPU_CLK_THREAD_UN- HALTED.REF_XCLK
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Increments at the frequency of XCLK (100 MHz) when not halted.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x4C
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x02
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\shape smallcaps
LOAD_HIT_PRE.HW_PF
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Non-SW-prefetch load dispatches that hit fill buffer allocated for H/W prefetch.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
5C
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
01
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CPL_CYCLES.RING0
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Unhalted core cycles when the thread is in ring 0
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
5C
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
02
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CPL_CYCLES.RING123
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Unhalted core cycles when the thread is not in ring 0
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
A1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
01
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
UOPS_DISPATCHED_PORT.
 PORT_0
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Cycles which a uop is dispatched on port 0
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
A1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
02
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
UOPS_DISPATCHED_PORT.
 PORT_1
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Cycles which a uop is dispatched on port 1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
A1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
0C
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
UOPS_DISPATCHED_PORT.
 PORT_ 2
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Cycles which a uop is dispatched on port 2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
A1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
30
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
UOPS_DISPATCHED_PORT.
 PORT_ 3
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Cycles which a uop is dispatched on port 3
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
A1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
40
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
UOPS_DISPATCHED_PORT.
 PORT_ 4
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Cycles which a uop is dispatched on port 4
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
A1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
80
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
UOPS_DISPATCHED_PORT.
 PORT_ 5
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Cycles which a uop is dispatched on port 5
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
A2 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
01
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
RESOURCE_STALLS.ANY
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Cycles Allocation is stalled due to Resource Related reason
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0xA2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x04
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
RESOURCE_STALLS.RS
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Cycles stalled due to no eligible RS entry available
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
A3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
01
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CYCLE_ACTIVITY.
 CYCLES_L2_PENDING
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Cycles with pending L2 miss loads
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
A3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
02
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CYCLE_ACTIVITY.
 CYCLES_LDM_PENDING
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Cycles with pending memory loads
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
A3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
08
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CYCLE_ACTIVITY.
 CYCLES_L1D_PENDING
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Cycles with pending L1 cache miss loads
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
A3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
04
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CYCLE_ACTIVITY.
 CYCLES_NO_EXECUTE
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Cycles of dispatch stalls
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0xA8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x01
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
LSD.UOPS
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Counts the number of micro-ops delivered by loop stream detector
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0xC0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x00
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
INST_RETIRED.ANY_P
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Number of instructions at retirement.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0xC4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x00
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
BR_INST_RETIRED.
 ALL_BRANCHES
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Branch instructions at retirement.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0xC5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x00
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
BR_MISP_RETIRED.
 ALL_BRANCHES
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Mispredicted branch instructions at retirement.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0xD0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x01
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\shape smallcaps
MEM_UOPS_RETIRED.
\end_layout

\begin_layout Plain Layout

\shape smallcaps
LOADS
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Qualify retired memory uops that are loads.
 Combine with umask 0x10, 0x20, 0x40, 0x80.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0xD0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x02
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\shape smallcaps
MEM_UOPS_RETIRED.
 STORES
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Qualify retired memory uops that are stores.
 Combine with umask 0x10, 0x20, 0x40, 0x80.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0xD0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x80
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\shape smallcaps
MEM_UOPS_RETIRED.
 ALL
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Qualify any retired memory uops.
 Must combine with umask 0x01, 0x02, to produce counts.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0xD1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x01
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\shape smallcaps
MEM_UOPS_RETIRED.
 L1_HIT
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Retired load uops with L1 cache hits as data sources.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0xD1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x02
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\shape smallcaps
MEM_UOPS_RETIRED.
 L2_HIT
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Retired load uops with L2 cache hits as data sources.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0xD1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x04
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\shape smallcaps
MEM_UOPS_RETIRED.
 LLC_HIT
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Retired load uops whose data source was LLC hit with no snoop required.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0xD1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x20
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\shape smallcaps
MEM_UOPS_RETIRED.
 LLC_MISS
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Retired load uops whose data source is LLC miss
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0xD1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x40
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\shape smallcaps
MEM_UOPS_RETIRED.
 HIT_LFB
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Retired load uops which data sources were load uops missed L1 but hit FB
 due to preceding miss to the same cache line with data not ready.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{small}
\backslash
endgroup
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Benchmark Script
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "chap:lperf"

\end_inset

A Python script is used as a wrapper around 
\family typewriter
perf stat
\family default
 to collect performance counters under varying execution contexts.
 A dummy variable 
\begin_inset Quotes eld
\end_inset

FOO
\begin_inset Quotes erd
\end_inset

 is used to incrementally add bytes to the environment.
 The command line interface is similar to 
\family typewriter
perf
\family default
, with the same syntax for specifying which events to monitor.
 The following command gathers cycles:u and r0107:u (address alias) over
 256 runs of 
\begin_inset Quotes eld
\end_inset

loop
\begin_inset Quotes erd
\end_inset

, while incrementing the environment by 16 bytes each time.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},breaklines=true"
inline false
status open

\begin_layout Plain Layout

$ ./lperf ./loop -e cycles:u,r0107:u -n 256 --environment-increment 16
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The script relies on a file containing event codes and mnemonics, by default
 called 
\begin_inset Quotes eld
\end_inset

counters
\begin_inset Quotes erd
\end_inset

.
 Output is exported as comma separated values to 
\begin_inset Quotes eld
\end_inset

stat.csv
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},breaklines=true,commentstyle={\color{deepgreen}},emphstyle={\ttb\color{deepred}},frame=tb,keywordstyle={\ttb\color{deepblue}},language=Python,showstringspaces=false,stringstyle={\color{javared}}"
inline false
status open

\begin_layout Plain Layout

#!/usr/bin/env python 
\end_layout

\begin_layout Plain Layout

import subprocess, argparse, sys, copy
\end_layout

\begin_layout Plain Layout

from scipy import stats
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Use at most 4 counters simultaneously
\end_layout

\begin_layout Plain Layout

n_counters = 4
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def disable_layout_randomization():
\end_layout

\begin_layout Plain Layout

    subprocess.call('sudo bash -c "echo 0 > /proc/sys/kernel/randomize_va_space"'
, shell=True)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def benchmark(events, args):
\end_layout

\begin_layout Plain Layout

    for e in events:
\end_layout

\begin_layout Plain Layout

        e['count'] = [0]*args.num
\end_layout

\begin_layout Plain Layout

        e['variance'] = [0]*args.num
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    environment = {'FOO':'0'*args.environment_offset}
\end_layout

\begin_layout Plain Layout

    argument = args.argument_offset;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    for run in range(args.num):
\end_layout

\begin_layout Plain Layout

        tempfile = 'stat.tmp.' + str(run) + '.dat'
\end_layout

\begin_layout Plain Layout

        subprocess.call('cp /dev/null '+tempfile, shell=True)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        for batch in [events[i:i+n_counters] for i in range(0, len(events),
 n_counters)]:
\end_layout

\begin_layout Plain Layout

            e = ','.join(map(lambda x: x['code'], batch))
\end_layout

\begin_layout Plain Layout

            c = ' '.join(['perf stat -r', str(args.repeat), '-x","', '-e',
 e, args.program, str(argument), '0>>', tempfile])
\end_layout

\begin_layout Plain Layout

            p = subprocess.Popen(c, env=environment, shell=True)
\end_layout

\begin_layout Plain Layout

            p.wait()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        with open(tempfile, 'r') as f:
\end_layout

\begin_layout Plain Layout

            for i in range(len(events)):
\end_layout

\begin_layout Plain Layout

                line = f.readline().strip().split(',')
\end_layout

\begin_layout Plain Layout

                if (line[0] == "<not counted>"):
\end_layout

\begin_layout Plain Layout

                    continue
\end_layout

\begin_layout Plain Layout

                events[i]['count'][run] = float(line[0])
\end_layout

\begin_layout Plain Layout

                if args.repeat > 1:
\end_layout

\begin_layout Plain Layout

                    events[i]['variance'] = float(line[2][:-1])
\end_layout

\begin_layout Plain Layout

        subprocess.call('rm '+tempfile, shell=True)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        environment['FOO'] += '0'*args.environment_increment
\end_layout

\begin_layout Plain Layout

        argument += args.argument_increment;
\end_layout

\begin_layout Plain Layout

    return events
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def correlation(events, reference_event):
\end_layout

\begin_layout Plain Layout

    reference = events[0]
\end_layout

\begin_layout Plain Layout

    for i in range(len(events)):
\end_layout

\begin_layout Plain Layout

        if events[i]['code'] == reference_event or events[i]['perfmn'] ==
 reference_event:
\end_layout

\begin_layout Plain Layout

            reference = events[i]
\end_layout

\begin_layout Plain Layout

            break
\end_layout

\begin_layout Plain Layout

    for e in events:
\end_layout

\begin_layout Plain Layout

        e['pearson'], _ = stats.pearsonr(reference['count'], e['count'])
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def export_csv(events, filename):
\end_layout

\begin_layout Plain Layout

    with open(filename, 'w') as f:
\end_layout

\begin_layout Plain Layout

        for line in events:
\end_layout

\begin_layout Plain Layout

            row = [line['mnemonic'], line['code']] + [line['pearson']] +
 map(str, line['count'])
\end_layout

\begin_layout Plain Layout

            f.write(','.join(map(str, row)))
\end_layout

\begin_layout Plain Layout

            f.write('
\backslash
n')
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Read file containing performance event information
\end_layout

\begin_layout Plain Layout

def read_file_events(filename):
\end_layout

\begin_layout Plain Layout

    events = []
\end_layout

\begin_layout Plain Layout

    with open(filename) as f:
\end_layout

\begin_layout Plain Layout

        for line in f:
\end_layout

\begin_layout Plain Layout

            code, perfmn, name = map(lambda s : s.strip(), line.split('
\backslash
t'))
\end_layout

\begin_layout Plain Layout

            code = ''.join(['r', code.lower(), ':u']) if perfmn == '' else
 perfmn+':u'
\end_layout

\begin_layout Plain Layout

            events.append({'code': code, 'perfmn': perfmn, 'mnemonic': name})
\end_layout

\begin_layout Plain Layout

    return events
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Match events specified with "-e" flag with metadata from file
\end_layout

\begin_layout Plain Layout

def filter_events(file_events, include):
\end_layout

\begin_layout Plain Layout

    if include == []:
\end_layout

\begin_layout Plain Layout

        return file_events
\end_layout

\begin_layout Plain Layout

    events = []
\end_layout

\begin_layout Plain Layout

    for e in include:
\end_layout

\begin_layout Plain Layout

        found = False
\end_layout

\begin_layout Plain Layout

        for s in file_events:
\end_layout

\begin_layout Plain Layout

            if s['code'] == e or s['mnemonic'] == e:
\end_layout

\begin_layout Plain Layout

                found = True
\end_layout

\begin_layout Plain Layout

                events.append(copy.copy(s))
\end_layout

\begin_layout Plain Layout

        if not found:
\end_layout

\begin_layout Plain Layout

            print "Adding unknown event", e
\end_layout

\begin_layout Plain Layout

            events.append({'code': e, 'perfmn': '', 'mnemonic': ''})
\end_layout

\begin_layout Plain Layout

    return events
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if __name__ == '__main__':
\end_layout

\begin_layout Plain Layout

    parser = argparse.ArgumentParser(description='perf runner')
\end_layout

\begin_layout Plain Layout

    parser.add_argument('program', help='program, ex ./a.out')
\end_layout

\begin_layout Plain Layout

    parser.add_argument('-e', '--events')
\end_layout

\begin_layout Plain Layout

    parser.add_argument('-f', '--event-file', default='counters')
\end_layout

\begin_layout Plain Layout

    parser.add_argument('-o', '--output', default='stat.csv')
\end_layout

\begin_layout Plain Layout

    parser.add_argument('-n', '--num', type=int, default=2)
\end_layout

\begin_layout Plain Layout

    parser.add_argument('-r', '--repeat', type=int, default=1)
\end_layout

\begin_layout Plain Layout

    parser.add_argument('-c', '--correlate', default='cycles:u')
\end_layout

\begin_layout Plain Layout

    parser.add_argument('--environment-offset', type=int, default=0)
\end_layout

\begin_layout Plain Layout

    parser.add_argument('--environment-increment', type=int, default=1)
\end_layout

\begin_layout Plain Layout

    parser.add_argument('--argument-offset', type=int, default=0)
\end_layout

\begin_layout Plain Layout

    parser.add_argument('--argument-increment', type=int, default=0)
\end_layout

\begin_layout Plain Layout

    args = parser.parse_args()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    # Make memory layout deterministic    
\end_layout

\begin_layout Plain Layout

    disable_layout_randomization()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    # List of event properties [[code, perfmnemonic, description]]
\end_layout

\begin_layout Plain Layout

    events = filter_events(read_file_events(args.event_file), [] if args.events
 == None else args.events.strip().lower().split(','))
\end_layout

\begin_layout Plain Layout

    events = benchmark(events, args)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    # Export result
\end_layout

\begin_layout Plain Layout

    correlation(events, args.correlate)
\end_layout

\begin_layout Plain Layout

    export_csv(events, args.output)
\end_layout

\end_inset


\end_layout

\end_body
\end_document
