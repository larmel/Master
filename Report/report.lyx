#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass report
\begin_preamble
\usepackage{float}
\floatname{algorithm}{Listing}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman lmodern
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 12
\spacing single
\use_hyperref false
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks true
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry true
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 2
\paperpagestyle headings
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Analyzing Context Bias on Modern Architectures
\end_layout

\begin_layout Author
Lars Kirkholt Melhus
\end_layout

\begin_layout Date
Supervisor: Anne C.
 Elster
\begin_inset Newline newline
\end_inset

Co-supervisor: Rune E.
 Jensen
\end_layout

\begin_layout Quotation
\begin_inset Quotes eld
\end_inset

None really knows what is happening inside the CPU...
 It follows heisenburg uncertainity principle...
 lol..
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Quotation
k_sarnath - Intel forums.
\end_layout

\begin_layout Abstract
Carefully controlling observer effect and measurement bias when conducting
 experiments, is taken very seriously in other scientific fields such as
 medical research.
 These issues are also relevant when doing performance analysis, for instance
 when evaluating the efficiency of some new algorithm or compiler optimization.
 A computer program does not necessarily have the same performance across
 all machines.
 Running the same program multiple times does not always yield the same
 performance either.
 For accurate analysis of performance, it is important to sample a representativ
e set of tests -- this is true also in computer science.
 Seemingly trivial properties of the environment can bias programs towards
 certain configurations -- memory layout being the primary source of variation,
 but other sources such as room temperature and time of day could also be
 considered in the broadest sense.
\end_layout

\begin_layout Abstract
In this thesis we will study a small set of very distinct bias effects,
 that can be experienced by innocuous changes to the Unix environment, or
 changing the link order of a program.
 Through experimentation and careful measurement using hardware performance
 counters, we locate the source of what causes performance deviations.
 We show that environment bias is in fact not completely unpredictable,
 and discuss measures can be made to try to avoid problems caused by bias.
\end_layout

\begin_layout Abstract
Lastly we provide a brief case study of FFTW, showing how to account for
 hardware optimizations and avoid bias effects in performance critical software.
\end_layout

\begin_layout Section*
Problem Description
\end_layout

\begin_layout Standard
Variations in execution context has been shown to affect performance of
 programs on recent CPUs.
 Previous work has looked at offsetting the stack and changing link order
 -- biasing performance measurements towards certain configurations 
\begin_inset CommandInset citation
LatexCommand cite
key "Mytkowicz:2008:Easy,Mytkowicz:2009:WrongData,Mytkowicz:2008:OE&MB"

\end_inset

.
 Variables such as the placement of stack, heap and text segments in memory,
 combined with memory access instructions, can impact program performance
 quite significantly.
 
\end_layout

\begin_layout Standard
The goal of this project is to model some of these effects for common use
 cases, and methods for avoiding them, in order to avoiding bias and achieving
 peak performance.
 These effects might be highly platform dependent, so to limit the scope
 we will focus on a particular architecture, the Intel Core i7 "Ivy Bridge".
 Case studies will include small isolated programs, and ideally also "real"
 applications such as FFT algorithms.
\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Chapter
Introduction
\end_layout

\begin_layout Standard
Optimizing for performance often consist of 
\begin_inset Quotes eld
\end_inset

high level
\begin_inset Quotes erd
\end_inset

 tasks such as reducing algorithmic complexity, change data structures and
 ..., but also trying to eliminate branch misses and reduce the number of cache
 misses.
 As programmers, we are usually content as soon as we are able to measure
 a speedup.
 We will often be using simple techniques for observing performance metrics,
 such as incrementing counter variables for each invocation of function
 X, or inserting printf's in strategic places.
 
\end_layout

\begin_layout Standard
In disciplines other than computer science, such as medicine and the social
 sciences, the notions of measurement bias and observer effect is more often
 considered.
 
\end_layout

\begin_layout Description
Observer
\begin_inset space ~
\end_inset

effect The phenomena is changed (or even disappears) merely by observing
 it.
\end_layout

\begin_layout Description
Measurement
\begin_inset space ~
\end_inset

bias Properties of the experimental setup or environment, external and independe
t of what is being measured, is affecting the outcome of the experiment.
 
\end_layout

\begin_layout Standard
Seemingly innocious properties properties of the experimental setup, external
 to the program being measured, can bias performance measurements.
 There are many potential sources of bias that could come from the environment.
 In the widest sense, properties like the time of day, or temperature of
 the room should be considered relevant variables of the execution environment.
 This is actually not as far fetched as it may sound -- electronic circuits
 might very well operate more efficiently in lower temperatures, and programs
 we benchmark might use some API to ask for the time of day and execute
 different code paths dependent on that information.
\end_layout

\begin_layout Section
Motivation
\end_layout

\begin_layout Standard
In the paper appropriately named 
\begin_inset Quotes eld
\end_inset

Producing Wrong Data Without Doing Anything Obviously Wrong
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "Mytkowicz:2009:WrongData"

\end_inset

, the authors show how simple changes to the execution environment can heavily
 impact performance of SPEC 2006 benchmarks.
 Two variables are studied; size of the Unix environment variables, and
 link order of object files.
 Both are found to be significant with respect to measured performance of
 standardized benchmarks.
 This paper is getting old however, thus it is unclear whether measurement
 bias is an issue on newer CPUs.
 A quick reproduction of one of their tests however, clearly shows that
 measurement bias is still an issue on the -- at the time of writing --
 most recent Intel Core i7 Ivy Bridge architecture.
\end_layout

\begin_layout Standard
\noindent
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "42col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},language=C"
inline false
status open

\begin_layout Plain Layout

static int i=0,j=0,k=0;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main() {
\end_layout

\begin_layout Plain Layout

    int g = 0, inc = 1;
\end_layout

\begin_layout Plain Layout

    for (;g<65536;g++) {
\end_layout

\begin_layout Plain Layout

        i += inc;
\end_layout

\begin_layout Plain Layout

        j += inc;
\end_layout

\begin_layout Plain Layout

        k += inc;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "57col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\noindent
\align right
\begin_inset Graphics
	filename Img/loop/motivation.eps
	scale 70

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:motivation"

\end_inset

A simple C program with significant performance variations under different
 environment sizes.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:motivation"

\end_inset

 shows the micro-kernel presented in 
\begin_inset CommandInset citation
LatexCommand cite
key "Mytkowicz:2009:WrongData"

\end_inset

, together with measurements from our machine.
 The graph shows the number of cycles over a large number of runs, where
 characters are appended to a dummy environment variable between each.
 Cycle counts were measured with hardware performance counters using perf
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

perf
\end_layout

\end_inset

: Linux profiling with performance counters, 
\begin_inset CommandInset href
LatexCommand href
name "https://perf.wiki.kernel.org"
target "https://perf.wiki.kernel.org/index.php/Main_Page"

\end_inset


\end_layout

\end_inset

 to obtain accurate results.
 The program is compiled with gcc using all default options.
 The code should not appear particularly extraordinary in any way, yet its
 performance characteristics are quite peculiar.
 Even though the exact same binary executable file is run multiple times,
 the performance is clearly not the same for every environment size.
 Measurement bias is still an issue on the most recent architectures, and
 worth investigating.
\end_layout

\begin_layout Section
Outline
\end_layout

\begin_layout Standard
The purpose of this thesis is to explore ways to tackle the effects of measureme
nt bias.
 Previous work has focused mostly on ways to statistically eliminate the
 effects in order to produce reliable measurements -- working towards a
 more statistically valid methodology employed in the computer science community.
 Our approach is slightly different.
 If bias could be controlled in certain situations, we could change program
 or environment to enhance performance -- essentially control the bias to
 work in our favor.
 
\end_layout

\begin_layout Description
Chapter
\begin_inset space ~
\end_inset

2 presents some of the previous work done on measurement bias, showing its
 severity as well as proposed solutions to mitigate or compensate for it.
 A discussion of what actually constitutes the 
\emph on
environment
\emph default
 is discussed.
 
\end_layout

\begin_layout Description
Chapter
\begin_inset space ~
\end_inset

3 investigates various performance metrics acquired from simple programs,
 trying to identify potential 
\emph on
sources
\emph default
 of measurement bias.
 We will focus on two different bias effects; memory address aliasingthe
 first has to with memory address aliasing between variables, that can cause
 problems for the out-of-order scheduling.
 Next we will look at Loop Stream Detector, another hardware optimization
 that sometimes can give bad performance.
\end_layout

\begin_layout Description
Chapter
\begin_inset space ~
\end_inset

4 applies knowledge of bias effects from Chapter 3 in an attempt to speed
 up real-world applications.
 We take an in-depth look at FFTW, a high performance and automatically
 tuned implementation of the fourier transform.
 
\end_layout

\begin_layout Description
Chapter
\begin_inset space ~
\end_inset

5 summarizes results from previous chapters, and provides directions for
 future work.
 
\end_layout

\begin_layout Chapter
Background and Related Work
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "chap:Background"

\end_inset

In this chapter, we begin by presenting some of the previous work done on
 measurement bias in computer science.
 An introduction to virtual memory, linking and loading on x86_64 Linux
 architectures is provided as background material -- explaining what we
 mean by the 
\emph on
environment
\emph default
 of a program.
 Lastly, we include a brief overview of the Intel Core i7 architecture,
 highlighting some of the features and hardware optimizations that can cause
 problems.
 
\end_layout

\begin_layout Section
Observer Effect and Measurement Bias
\end_layout

\begin_layout Standard
Several papers dealing with bias in performance analysis have been published.
 Mytkowitcz et.
 al.
 provide an excellent introduction to measurement bias, together with the
 closely related phenomenon of observer effect, in the paper 
\begin_inset Quotes eld
\end_inset

Observer Effect and Measurement Bias in Performance Analysis
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "Mytkowicz:2008:OE&MB"

\end_inset

.
 The authors draw parallels to the social and natural sciences, scientific
 fields where considerable care is taken to avoid observer effect and bias
 in experimental setups.
 They argue that the methodology currently employed in performance analysis
 for software is lacking, if not flawed.
 In a literature survey, they find that very few authors even considers
 potential effects of bias when evaluating results.
 
\end_layout

\begin_layout Paragraph
Observer effect 
\end_layout

\begin_layout Standard
The set of relevant metrics in performance analysis is diverse; a database
 application might be interested in the number of transactions per second,
 while for a sorting algorithm implementation, the cycle count and cache
 misses might be more relevant.
 Many low level metrics such as cycle count and cache misses, can be aquired
 with minimal overhead by performance counters in hardware.
 In other cases we might need to add instrumentation to the program being
 measured, for example in the form of counter variables incremented for
 each function call.
 
\end_layout

\begin_layout Standard
Mytkowitcz et al.
 shows that both strict use of hardware counters, as well as adding any
 form of software instrumentation, is vulnerable to observer effects.
 Even in standardized benchmark suites such as SPEC 2006, they find that
 change in performance due to observer effect is significant, enough to
 invalidate research results if not properly considered.
\end_layout

\begin_layout Paragraph
Measurement bias
\end_layout

\begin_layout Standard
The performance characteristics of software changes also from external propertie
s of the experimental setup.
 The authors consider two, seemingly irrelevant, properties of the environment:
\end_layout

\begin_layout Itemize
Link order of object files: The order of which the .o files are provided
 to the linker, usually more than one valid permutations exist.
\end_layout

\begin_layout Itemize
Shell state, specifically environment variables.
 The content of environment variables depends on many factors, such as the
 user currently logged in (stored as 
\begin_inset Quotes eld
\end_inset

USER
\begin_inset Quotes erd
\end_inset

 in Linux), or which programs are currently installed, adding directories
 to the 
\begin_inset Quotes eld
\end_inset

PATH
\begin_inset Quotes erd
\end_inset

 variable.
\end_layout

\begin_layout Standard
The authors study how different compiler optimization levels is affected
 by adding characters to environment variables or altering the permuting
 link order.
 The results show that SPEC benchmarks are sensitive to this as well.
 Different conclusions about O2's efficiency versus O3 can be drawn depending
 on the environment.
\end_layout

\begin_layout Subsection
Causes of Measurement Bias
\end_layout

\begin_layout Standard
In a following paper by the same authors, the effects previously presented
 are reiterated, along with a more detailed analysis of measurement bias.
 In addition to pointing out sensitivity in large benchmark programs from
 the SPEC suite, the authors also provide a small, isolated C program with
 very high sensitivity to change in environment size.
 We discuss this particular program in the Introduction chapter, showing
 that similar bias effects appear on newer architectures as well.
\end_layout

\begin_layout Standard
For both changing environment variables and link order, the authors points
 to changes to the virtual memory layout being the real cause of bias.
\end_layout

\begin_layout Itemize
Changing environment variables has an effect on where the stack is placed
 in memory at runtime.
 A copy of the environment is loaded into virtual address space before the
 call stack starts.
 Thus, increasing the environment size offsets the stack start address.
 The authors suggests that altering the stack addresses of variables at
 runtime can have an impact on things like alignment in cache and accuracy
 of branch predictors.
\end_layout

\begin_layout Itemize
Changing link order can change the virtual addresses of instructions.
 Using hardware simulators, the authors show that performance also depends
 on code alignment in memory.
 For instance, when a hot loop fits entirely in a single cache line, the
 number of accesses to instruction cache can be reduced.The authors speculate
 that the 
\begin_inset Quotes eld
\end_inset

Loop Stream Detector
\begin_inset Quotes erd
\end_inset

 might cause bias on the Core 2, a hardware optimization that is supposed
 to speed up instruction fetching of hot loops.
\end_layout

\begin_layout Standard
Dispite demystifying the causes of bias somewhat, this paper provides no
 satisfactory explanation of exactly what mechanisms of the processor causes
 bias.
 
\end_layout

\begin_layout Subsection
Conclusion
\end_layout

\begin_layout Standard
The conclusion reached in both papers is that both observer effect and measureme
nt bias is unpredictable.
 Measures should be taken to mitigate rather than avoid
\end_layout

\begin_layout Section
Exploiting Bias for Optimization
\end_layout

\begin_layout Standard
Bias effects are hardware dependent -- need to optimize for specific architectur
es.
\end_layout

\begin_layout Standard
Support in GCC and other compilers.
\end_layout

\begin_layout Subsection
Blind Optimization
\end_layout

\begin_layout Standard
In an attemt to circumvent the negative 
\end_layout

\begin_layout Standard
Giving up, treat everything as a black box.
 Use methods from AI to find local minima/maxima 
\begin_inset CommandInset citation
LatexCommand cite
key "Knights:2009:BlindOpt"

\end_inset

.
\end_layout

\begin_layout Standard
Recognizing that properties such as link order can have large impact on
 performance
\end_layout

\begin_layout Subsection
Assembly-Level Optimizations
\end_layout

\begin_layout Standard
MAO, paper from Google.
 
\end_layout

\begin_layout Section
Hardware Performance Counters
\end_layout

\begin_layout Standard
To be able to tell anything about bias effects we need to have a reliable
 way to gather various metrics.
 There are many different approaches for measuring performance of software;
 debuggers, profilers and the likes are widely used in both industry and
 academia.
 Unfortunately, measurement techniques relying on intervention from software
 are prone to observer effect.
 In addition, any measurement instrumentation that alters the executed program
 per definition measures a 
\emph on
different
\emph default
 program -- making it difficult to accurately identify bias effects.
\end_layout

\begin_layout Standard
Luckily, modern processors have support in hardware for measuring a plethora
 of different metrics, called performance counters.
 
\end_layout

\begin_layout Subsection
Accuracy of Performance Counters
\end_layout

\begin_layout Standard
Unfortunately, performance counters are not necessarily accurate or predictable.
 Several papers have looked at the relationship between measured counts
 and the 
\begin_inset Quotes eld
\end_inset

right answer
\begin_inset Quotes erd
\end_inset

.
 For certain metrics it is quite easy to verify wether the reported counts
 are accurate.
 One example is the number of retired instructions, for the perf utility
 reported as instructions:u.
 At least for small programs, we can easily count the number of dynamic
 intructions and compare to reported counts.
 
\end_layout

\begin_layout Subsubsection*
Accuracy vs.
 Precision
\end_layout

\begin_layout Standard
For clarity, it is worth pointing out the difference between accuracy and
 precision.
 A series of measurements can be accurate, but not precise, and vice-versa.
 Consider a bow-and-arrow contest after a series of arrows are fired at
 the same target.
 The archer is 
\emph on
accurate
\emph default
 if the arrows land close to the target, and 
\emph on
precise
\emph default
 if the arrows lands close together.
 Note that accuracy does not entail precision, and vice-versa.
\end_layout

\begin_layout Standard
For performance measurements, these are properties of the performance counters.
 Ideally we want counters to be both precise and accurate.
 Many papers have looked at the properties of performance counters, and
 unfortunately very few seems to have the desired properties.
 A counter that appears to be both accurate and precise is INSTR_RETIRED
 -- which can be pretty easily verified by inspecting the source code.
 Measuring the number of cucles accurately seems to be more of a challenge.
 There will always be some overhead in setting up the counters and reading
 the values after the program has run.
 We can try to create an empty program -- but the cycle count reported by
 perf will not be anywhere near zero.
 Trying to measure the 
\begin_inset Quotes eld
\end_inset

empty
\begin_inset Quotes erd
\end_inset

 program yields about 2000 cycles in our setup.
\end_layout

\begin_layout Subsection
Performance Counters in Linux
\end_layout

\begin_layout Standard
The Linux kernel provides an interface to hardware performance counters
 through the perf utility, which we will be using for our measurements.
 
\end_layout

\begin_layout Subsection
Details from Intel Manual
\end_layout

\begin_layout Standard
The current generations of Intel microarchitectures are called, from earliest
 to newest, Sandy Bridge, Ivy Bridge and Haswell.
 In the official documentation on hardware performance monitoring, Ivy Bridge
 is 
\begin_inset Quotes eld
\end_inset

generally the same
\begin_inset Quotes erd
\end_inset

 as described for Sandy Bridge.
 Ref 18.9 in Part 3B.
 
\end_layout

\begin_layout Standard
Another note: Ivy Bridge is 
\begin_inset Quotes eld
\end_inset

3rd generation Core
\begin_inset Quotes erd
\end_inset

, while Haswell is 
\begin_inset Quotes eld
\end_inset

Next generation
\begin_inset Quotes erd
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sandy/Ivy Bridge
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Number of fixed counters per thread
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Number of general-purpose counters per core
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Number of programmable counters per thread
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4 (8 if a core is not shared by two threads)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
PMU (Performance Monitoring Unit) capabilities for 2nd and 3rd generation
 Intel Core microarchitectures (Sandy Bridge and Ivy Bridge).
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Quote from 18.11.5.2
\end_layout

\begin_layout Quote
The performance-monitoring events listed in Chapter 19, “Performance-Monitoring
 Events,” are intended to be used as guides for performance tuning.
 The counter values reported are not guaranteed to be absolutely accurate
 and should be used as a relative guide for tuning.
 Known discrepancies are documented where applicable.
 
\end_layout

\begin_layout Paragraph
Fixed counters
\end_layout

\begin_layout Standard
Can only count one event (?)
\end_layout

\begin_layout Paragraph*
Generic counters
\end_layout

\begin_layout Standard
Can count any event
\end_layout

\begin_layout Standard
In case there are more events than counters, OS will multiplex and perf
 do scaling (inaccurate).
\end_layout

\begin_layout Paragraph
Software events
\end_layout

\begin_layout Standard
Things like context switches.
 (How is this counted?)
\end_layout

\begin_layout Paragraph
Hardware events
\end_layout

\begin_layout Standard
Cycles
\end_layout

\begin_layout Paragraph
PMI
\end_layout

\begin_layout Standard
Performance Monitor Interrupt
\end_layout

\begin_layout Paragraph
At Retirement Events
\end_layout

\begin_layout Standard
At-retirement counting provides a means counting only events that represent
 work committed to architectural state and ignoring work that was performed
 speculatively and later discarded.
 (Quote from 18.11.6)
\end_layout

\begin_layout Standard
Tagging of micro-operations enables counting at retirement.
 Ex from manual: A micro-op can have several cache-misses during execution.
 Tag to get counted only once.
\end_layout

\begin_layout Subsection
Precise Event Based Sampling (PEBS) 
\end_layout

\begin_layout Standard
Same support as Sandy Bridge, with events listed in Table 18-21.
\end_layout

\begin_layout Standard
Allows PMU to collect architectural state and Instruction Pointer (IP) 
\emph on
after
\emph default
 instruction that caused event is completed.
 Only 
\begin_inset Quotes eld
\end_inset

at-retirement
\begin_inset Quotes erd
\end_inset

 events.
 PEBS buffer can contain all general purpose registers + IP for analyzing
 later.
 Used in V-tune.
\end_layout

\begin_layout Standard
Supported in perfmon2 for some version number > x.
 
\end_layout

\begin_layout Standard
Quote from forum post: http://software.intel.com/en-us/forums/topic/277553
\end_layout

\begin_layout Quote
PEBS (Precise Event Based Sampling) is a feature available to a subset of
 events which allows the hardware to collect additionalinformation very
 close to the exact time the configured event overflowed.
 This presents theanalysis tools whith susbstantially more accurate information
 since the alternative is to wait for a software interrupt to collect this
 information, typically hundreds of cycles later.The additional collected
 information are stored in a special PEBS buffer and retrieved by the tool
 (in this case perf_events) later.
\end_layout

\begin_layout Standard
For use in perf: append :pp to event.
 Needs to be used with perf record.
\end_layout

\begin_layout Section
Intel Microarchitecture
\end_layout

\begin_layout Standard
Information in Intel 64 and IA-32 Architectures Optimization Reference Manual.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
Image of memory system, showing MOB etc.
 Might be useful.
\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Intel Core Microarchitecture
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
MOB
\end_layout

\begin_layout Standard
The Intel architecure enables speculative loads and stores based on predictions.
 Separate buffers are used to provide speculative memory operations, and
 instructions are restarted if conflicts are discovered at retirement.
 
\end_layout

\begin_layout Standard
Memory disambiguation: Information in 2.2.4.5.
 Predicts conflict of loads, issue speculatively.
\end_layout

\begin_layout Subsection
Loop Stream Detecor
\end_layout

\begin_layout Standard
Front end optimization.
 Hinted to being a possible source of bias in Google tech talk (reference).
\end_layout

\begin_layout Section
The Execution Context
\end_layout

\begin_layout Standard
The operating system might be cosidered a vital part of the execution environmen
t.
 Running tests on a particular operating system might very well result in
 big performance differences.
 Because of time limitations we have not considered bias effects due to
 specific variations in OS-es, but rather specific variations within the
 execution context provided by the operating system.
 For all our results, we have used the latest stable release of Ubuntu,
 version 12.04, updated with the latest kernel updates.
\end_layout

\begin_layout Standard
To understand why some of the bias effects occur, it is necessary to understand
 some of the low-level aspects of how processes and memory is managed by
 the operating system.
 In particular, we will see that changes to memory layout in virtual address
 space can lead to performance variations.
 
\end_layout

\begin_layout Subsection
Virtual Memory
\end_layout

\begin_layout Standard
Before a program can be run, it needs to be loaded into memory in some way.
 The ELF file includes the path to an interpreter, a program that is responsible
 for loading code and data, setting up a stack, and loading any dependencies.
 Files compiled for execution on a 64 bit Linux platform will point to a
 loader in 
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

/lib64/ld-linux-x86-64.so.2
\end_layout

\end_inset

.
 This file can be a symbolic link to the actual program.
 The loader then places each 
\emph on
allocable
\emph default
 section of the object file in virtual address space.
 The most important sections include the stack, heap, bss, data and text,
 as shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:virtual-address-space"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Img/unix-vm-all.eps

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:virtual-address-space"

\end_inset

Organization of virtual memory on a typical 64 bit Linux system.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Effectively, only 48 out of 64 available bits are used for addressing.
 The lower 
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

0x0
\end_layout

\end_inset

 through 
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

0x7fff'ffffffff
\end_layout

\end_inset

 is addressable to user programs, i.e.
 the virtual address space.
 The upper segment of addresses 
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

0xffff8000'00000000
\end_layout

\end_inset

 through 
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

0xffffffff'ffffffff
\end_layout

\end_inset

 is reserved for the operating system .
 Note that this leaves a large 
\begin_inset Quotes eld
\end_inset

hole
\begin_inset Quotes erd
\end_inset

 of unused addresses, as current hardware does not support addressing the
 whole 64 bit range 
\begin_inset CommandInset citation
LatexCommand cite
key "Lomont:2012:x64Assembly"

\end_inset

.
\end_layout

\begin_layout Standard
A running process is divided into several sections within the virtual address
 space:
\end_layout

\begin_layout Description
stack Stack frames with parameters and local variables for function calls.
 Allocated starting somewhere around the top address 
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

0x007fff'ffffffff
\end_layout

\end_inset

 and expanding downwards.
 
\end_layout

\begin_layout Description
heap Dynamically allocated memory, allocated above the text and data segments
 and growing upwards as programs request more memory.
 The start of heap is marked by 'brk'.
 A Linux system call to brk will request more memory, extending the current
 limit.
 
\end_layout

\begin_layout Description
bss Uninitialized data.
 This segment occupies no space in the object file, only the size is needed.
 Everything is initialized to zero.
 
\end_layout

\begin_layout Description
data Initialized data, variables that have some assigned value at compile
 time.
 
\end_layout

\begin_layout Description
text Executable binary code.
 This segment is placed at the lower end of virtual address space.
 
\end_layout

\begin_layout Standard
Dynamically loaded libraries are mapped into virtual memory as well.
 They typically end up with high addresses, located relatively close to
 the stack.
 
\end_layout

\begin_layout Subsubsection*
Address Space Layout Randomization (ASLR)
\end_layout

\begin_layout Standard
The process of loading segments to virtual memory is not necessarily determinist
ic.
 If virtual addresses can be known a priori, programs will be more vulnerable
 to buffer overflow attacks 
\begin_inset CommandInset citation
LatexCommand cite
key "Shackham:2004:ASLR"

\end_inset

.
 If an attacker manages to inject malicous code, he can use the known virtual
 addresses to access data or call any function.
 One technique known as 'return to libc' attacks uses this knowledge to
 call functions in the C standard library, which will be loaded in most
 scenarios.
\end_layout

\begin_layout Standard
Address space randomization is a technique employed by the operating system
 to make it more difficult to compromise programs.
 By default, the placement of stack, heap (initial position of brk) and
 location of dynamically linked libraries will vary between each run of
 a program.
 For a controlled execution environment we will need to manually disable
 address randomization in many cases.
 This is done by overwriting the randomize_va_space file.
 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=bash"
inline false
status open

\begin_layout Plain Layout

bash -c 'echo 0 > /proc/sys/kernel/randomize_va_space'
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The default value is 2, indicating full randomization.
 For randomizing only (??), a value of 1 can be written instead.
 We will use zero to disable all randomization, making virtual memory layout
 completely deterministic between each run.
\end_layout

\begin_layout Subsubsection*
Environment Variables
\end_layout

\begin_layout Standard
As pointed out in 
\begin_inset CommandInset citation
LatexCommand cite
key "Mytkowicz:2009:WrongData"

\end_inset

, the size of a user's Unix environment variable can affect the placement
 of stack.
 Environment variables are allocated above the stack, pushing the first
 possible stack starting address downwards.
 With ASLR disabled, the initial stack address can be manipulated by manually
 changing environment variables.
\end_layout

\begin_layout Subsection
Memory Context of C Programs
\end_layout

\begin_layout Standard
Recognizing that the location of variables in virtual memory is significant,
 it is useful to have an idea of where data might end up in actual programs.
 The program in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:c-context"

\end_inset

 contains four variables, utilizing both initialized and unitialized data,
 as well as dynamically allocated data on heap and automatic stack allocated
 variables.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},language=C,showstringspaces=false"
inline false
status open

\begin_layout Plain Layout

static int a;      // .bss
\end_layout

\begin_layout Plain Layout

static int b = 42; // .data
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main() {
\end_layout

\begin_layout Plain Layout

    int c = 0; // .stack
\end_layout

\begin_layout Plain Layout

    int *d = malloc(sizeof(int)); // .heap
\end_layout

\begin_layout Plain Layout

    printf("stack: %p
\backslash
nheap: %p
\backslash
nbss: %p
\backslash
ndata: %p
\backslash
n", &c, d, &a, &b);
\end_layout

\begin_layout Plain Layout

    return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:c-context"

\end_inset

Simple C program with data allocated in four different segments of virtual
 memory
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Variable c and d are 
\emph on
automatic
\emph default
 variables
\begin_inset CommandInset citation
LatexCommand cite
key "Kernighan:1988:CProgrammingLanguage"

\end_inset

, which are stack allocated.
 Their run-time address depends on where the stack segment is initialized
 in virtual memory, and can in general not be known ahead of time.
 The address returned by malloc and stored in variable d points to a location
 on the heap.
 The exact address depends on the implementation of malloc, as well as the
 initial position of the heap segment, and is also impossible to predict
 in general.
 Global variables a and b should be placed in bss and data segments respectively.
 Their virtual addresses are determined at compile time, and can be found
 in the ELF object file's symbol table 
\begin_inset CommandInset citation
LatexCommand cite
key "SystemVABI"

\end_inset

.
 
\end_layout

\begin_layout Standard
Executing the same program multiple times with ASLR enabled will yield different
 output for stack and heap addresses.
 Each variation constitutes a different execution context, with potentially
 different performance characteristics.
\end_layout

\begin_layout Standard
The actual memory map from running processes can be obtained by reading
 the file 
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

/proc/$id/maps
\end_layout

\end_inset

 for some process id.
 A sample output from a run of the previous hello world example is shown
 below.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\scriptsize\ttfamily}"
inline false
status open

\begin_layout Plain Layout

00400000-00401000 r-xp 00000000 08:01 161842             /home/lars/Master/Code/
Env/a.out
\end_layout

\begin_layout Plain Layout

00600000-00601000 r--p 00000000 08:01 161842             /home/lars/Master/Code/
Env/a.out
\end_layout

\begin_layout Plain Layout

00601000-00602000 rw-p 00001000 08:01 161842             /home/lars/Master/Code/
Env/a.out
\end_layout

\begin_layout Plain Layout

01027000-01048000 rw-p 00000000 00:00 0                  [heap]
\end_layout

\begin_layout Plain Layout

7f127e493000-7f127e646000 r-xp 00000000 08:01 266366     /lib/x86_64-linux-gnu/l
ibc-2.15.so
\end_layout

\begin_layout Plain Layout

7f127e646000-7f127e845000 ---p 001b3000 08:01 266366     /lib/x86_64-linux-gnu/l
ibc-2.15.so
\end_layout

\begin_layout Plain Layout

7f127e845000-7f127e849000 r--p 001b2000 08:01 266366     /lib/x86_64-linux-gnu/l
ibc-2.15.so
\end_layout

\begin_layout Plain Layout

7f127e849000-7f127e84b000 rw-p 001b6000 08:01 266366     /lib/x86_64-linux-gnu/l
ibc-2.15.so
\end_layout

\begin_layout Plain Layout

7f127e84b000-7f127e850000 rw-p 00000000 00:00 0 
\end_layout

\begin_layout Plain Layout

7f127e850000-7f127e872000 r-xp 00000000 08:01 266346     /lib/x86_64-linux-gnu/l
d-2.15.so
\end_layout

\begin_layout Plain Layout

7f127ea59000-7f127ea5c000 rw-p 00000000 00:00 0 
\end_layout

\begin_layout Plain Layout

7f127ea6f000-7f127ea72000 rw-p 00000000 00:00 0 
\end_layout

\begin_layout Plain Layout

7f127ea72000-7f127ea73000 r--p 00022000 08:01 266346     /lib/x86_64-linux-gnu/l
d-2.15.so
\end_layout

\begin_layout Plain Layout

7f127ea73000-7f127ea75000 rw-p 00023000 08:01 266346     /lib/x86_64-linux-gnu/l
d-2.15.so
\end_layout

\begin_layout Plain Layout

7fff47114000-7fff47135000 rw-p 00000000 00:00 0          [stack]
\end_layout

\begin_layout Plain Layout

7fff471ff000-7fff47200000 r-xp 00000000 00:00 0          [vdso]
\end_layout

\begin_layout Plain Layout

ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0  [vsyscall]
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Sources of Measurement Bias
\end_layout

\begin_layout Standard
Modern microprocessors are extremely complex in design and functionality.
 Some of the features on our Ivy Bridge includes; several layers of cache
 to camouflage slow memory, multiple prefetchers -- able to detect strided
 access patters[ref], 
\emph on
macro fusion[ref]
\emph default
 -- combining simple instructions to one, speculative out-of-order execution,
 complicated branch prediction, just to name a few.
 Optimizing for the common case, these hardware optimizations sometimes
 behaves badly.
 Dispite reasonably good documentation, only Intel knows all the details
 of the inner workings of the processor, leaving us with sort of a black
 box testing.
 In this chapter we will unveil characteristics about two architectural
 features in the Core i7; speculative out-of-order memory operations, and
 the Loop Stream Detector.
\end_layout

\begin_layout Section
Measurement Methodology
\end_layout

\begin_layout Standard
Before going ahead with all the details, it is important to describe the
 methodology used to aquire accurate measurements.
 For many of our examples, we are interested first and foremost in the number
 of cycles retured in user mode during execution.
 We use perf stat to aquire performance counter measurements.
 We make the following configuration to our experimental setup:
\end_layout

\begin_layout Itemize
Unless specified otherwise, address space layout randomization (ASLR) is
 kept disabled.
 This is necessary when testing effects from memory context, and often required
 to make results reproducible.
\end_layout

\begin_layout Itemize
Hyper threading is disabled, ensuring that only one thread runs simultaneously
 on each core.
 Two threads competing on hardware resources is another potential source
 of bias, which we will not be studying.
 
\end_layout

\begin_layout Itemize
System load is kept at a minimum to avoid interference with other processes
 and OS tasks.
\end_layout

\begin_layout Section
Address Alias Effects
\end_layout

\begin_layout Standard
In 
\begin_inset Quotes eld
\end_inset

Producing Wrong Data Without Doing Anything Obviously Wrong!
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "Mytkowicz:2009:WrongData"

\end_inset

, the authors present an intriguing little C program with extreme sensitivity
 to environment bias.
 They show that by adding bytes to the Unix environment, the cycle count
 periodically increases by about 33%, and some times by almost 300%.
 Their measurements are done on an older Intel Core 2 architecture, providing
 this an excellent example to start our investigation of the newer Core
 i7 architecture.
 
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily}"
inline false
status open

\begin_layout Plain Layout

static int i = 0, j = 0, k = 0;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main() {
\end_layout

\begin_layout Plain Layout

    int g = 0, inc = 1;
\end_layout

\begin_layout Plain Layout

    for (; g < 65536; g++) {
\end_layout

\begin_layout Plain Layout

        i += inc;
\end_layout

\begin_layout Plain Layout

        j += inc;
\end_layout

\begin_layout Plain Layout

        k += inc;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:loop-micro-kernel"

\end_inset

C code for micro-kernel
\end_layout

\end_inset


\end_layout

\end_inset

The micro-kernel from Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:loop-micro-kernel"

\end_inset

 does in fact show clear bias effects also on the newer architecture.
 We use perf and an automated script to run samples, with increasing environment
 size using a dummy variable.
 The program is compiled using cc and no optimization (-O0).
 The results are plotted for each environment size, incrementing by one
 between each run.
 A very distinct spike can be observed, starting at an offset of 3400? bytes.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Img/loop-alias-cycles.eps
	scale 70

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Cycle count from running the same program with different Unix environment
 size.
 Horizontal axis shows number of bytes added to an empty environment.
 Tests were run with an empty initial environment and address randomization
 disabled, for reproducible results.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Analysis of Alias Effects
\end_layout

\begin_layout Standard
How we found out what caused the strange behaviour.
 Correlation for all counters (note, not really all, but should cover interestin
g cases).
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{small}
\end_layout

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="17" columns="3">
<features tabularvalignment="middle" tabularwidth="100text%">
<column alignment="left" valignment="top" width="60text%">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Performance Counter
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Perf code
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Correlation
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
UnHalted Core Cycles
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
cycles:u
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
UnHalted Reference Cycles
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
bus-cycles:u
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0.9999993516
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
CYCLE_ACTIVITY.CYCLES_LDM_PENDING
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
r02a3:u
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0.9969137483
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
LD_BLOCKS_PARTIAL.ADDRESS_ALIAS
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
r0107:u
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0.9967140166
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
RESOURCE_STALLS.ANY
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
r01a2:u
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0.9965375371
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
task-clock:u
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0.9700350589
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
cpu-clock:u
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0.9699529964
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
CPU_CLK_THREAD_UNHALTED.REF_XCLK
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
r013c:u
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0.960707912
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
CPU_CLK_UNHALTED.THREAD_P
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
r003c:u
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0.960679448
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
CPL_CYCLES.RING123
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
r025c:u
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0.9605066987
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
CYCLE_ACTIVITY.CYCLES_NO_EXECUTE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
r04a3:u
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0.9595685545
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
CYCLE_ACTIVITY.STALLS_L2_PENDING
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
r05a3:u
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0.9590751052
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
…
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
UOPS_DISPATCHED_PORT.PORT_1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
r02a1:u
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
-0.9590123729
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
UOPS_DISPATCHED_PORT.PORT_0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
r01a1:u
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
-0.9862913345
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
RESOURCE_STALLS.RS
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
r04a2:u
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
-0.9895979962
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{small}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Performance counters with more than 90% positive or negative correlation
 to cycle count
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Img/loop-alias.eps
	scale 80

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
wat.
 UnHalted Core Cycles.
\begin_inset Newline newline
\end_inset

CYCLE_ACTIVITY.CYCLES_LDM_PENDING
\begin_inset Newline newline
\end_inset

Note: Postscript files should be scaled by 75%.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Used already provided kernel from paper -- no detailed explanation provided,
 other than a reference to certain counters.
\end_layout

\begin_layout Itemize
Developed script to run a large numbe of performance counters on the same
 program under controlled environment.
 With varying stack offset.
\end_layout

\begin_layout Itemize
Calculated correlation between cycle count and all counters to find a subset
 that stood out.
 Observe that schedule pipe0-4 are utilized differently.
 Lots of interesting stuff.
 => Read various intel docs.
\end_layout

\begin_layout Itemize
Hypothesis: address alias is the cause.
 Test by observing address.
\end_layout

\begin_layout Standard
Detailed analysis with a clever drawing showing where the collision is.
 
\end_layout

\begin_layout Subsection
Run-time Solutions to Address Aliasing
\end_layout

\begin_layout Standard
In general, the address of stack variables cannot be determined statically.
 It seems like there are two ways to approack the problem of mitigating
 or avoiding aliasing in practice.
 One approach could be to amploy some clever compile-time heuristics to
 pad variables in some way -- hopefully reducing conflicts without hurting
 performance.
 Another approach would be to do some run-time analysis of the variables
 addresses, and execute alternative code paths once a conflict is found.
 This is in principle a feasible solution.
 In the previous example, we can 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Img/loop-alias-fixed.eps
	scale 80

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
No change to performance based on environment size.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Heap address conflicts
\end_layout

\begin_layout Standard
Dynamic memory allocation can also trigger alias effects.
 Observations:
\end_layout

\begin_layout Standard
Malloc appears to be deterministic, once the ASLR has placed heap start
 address somewhere.
 On x86_64, the heap is typically located around virtual address 0x600000,
 right above program text and data segments (see illustration).
 Some metadata for each allocated area is used to handle free requests etc.
 The pointer returned from malloc seems to be aligned to a single byte,
 meaning returned addresses always end with 0x0.
\end_layout

\begin_layout Standard
For slightly larger requests (how large?), malloc uses mmap, which aligns
 to page size; i.e.
 0x1000.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily}"
inline false
status open

\begin_layout Plain Layout

#define N 0x7ffa // 65536 = 0x10000
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

static int inc = 0;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main(int argc, char **argv)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    int offset  = atoi(argv[1]), i;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    float *a    = malloc(N*sizeof(float));
\end_layout

\begin_layout Plain Layout

    float *fill = malloc(offset*sizeof(float));
\end_layout

\begin_layout Plain Layout

    float *b    = malloc(N*sizeof(float));
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    for (i = 0; i < N; ++i)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        b[i] += inc;
\end_layout

\begin_layout Plain Layout

        b[i]++;
\end_layout

\begin_layout Plain Layout

        b[i]++;
\end_layout

\begin_layout Plain Layout

        b[i]++;
\end_layout

\begin_layout Plain Layout

        b[i]++;
\end_layout

\begin_layout Plain Layout

        a[i]++;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Micro-kernel with a simple loop reading and writing to arrays a and b.
 With the correct input argument, a and b will alias and the cycle count
 noticeably spikes.
 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Internals of malloc
\end_layout

\begin_layout Standard
For the previous example, adding a single byte to the b array, suddently
 malloc will begin using mmap instead of brk after some amount of offset
 (fill array).
 
\end_layout

\begin_layout Standard
brk is a strange system call: It increases the boundary of the data segment,
 by simply pushing the 
\begin_inset Quotes eld
\end_inset

break
\begin_inset Quotes erd
\end_inset

 address upwards.
 Break marks the end of the 
\begin_inset Quotes eld
\end_inset

bss
\begin_inset Quotes erd
\end_inset

 segment -- uninitialized data.
 See man page.
 Is it actually used in malloc? Called only once perhaps?
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Img/heap-step.svg
	scale 30

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Adding a single float causes mmap to be called after a certain amount of
 offset.
 Very weird.
 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
mmap is a posix system call for mapping a file to contiguous memory.
 Using the ANONYMOUS parameter, memory can be mapped without a backing file.
 malloc uses mmap instead of brk for large allocations -- although the rules
 seems kind of complicated.
\end_layout

\begin_layout Subsection
Malloc with Pthreads
\end_layout

\begin_layout Standard
Knowign about the possibility of aliasing with aligned array, we can try
 to come up with plausible scenarios where bias can occur.
 An idea for provoking malloc alignment could be to use threading.
\end_layout

\begin_layout Standard
Pthread malloc is probably another implementation, which does not use the
 low-address heap space.
 The high-addresses, apparantly up to 0x7fff'f0000000, are used in the pthread
 implementation.
 Two threads are allocated with heaps 0x7fff'
\series bold
e8
\series default
000000 and 0x7fff'
\series bold
f0
\series default
000000.
\end_layout

\begin_layout Standard
Plan 2: Allocate enough space on each thread-specific are to fill them,
 causing subsequent calls to allocate on shared area.
 Now, allocate (_, 1, 2) + (_, 3) arrays, with arrays 1 and 2 colliding
 if the allocations happen 1, 3, 2 -- alternatively 1, 2, 3.
 The _ allocation is for eating up 
\begin_inset Quotes eld
\end_inset

local
\begin_inset Quotes erd
\end_inset

 heap.
 The size of the local segment is ? 
\end_layout

\begin_layout Standard
Does not work.
 Multiple threads have their own 
\begin_inset Quotes eld
\end_inset

start
\begin_inset Quotes erd
\end_inset

 heap area -- when it overflows, mmap is used which aligns to 12 bit.
 Multiple threads do allocate different areas dependent on ordering, but
 with mmap alignment, there is not much to about it.
\end_layout

\begin_layout Subsection
Example: Convolution
\end_layout

\begin_layout Standard
To illustrate possible performance problems caused by address aliasing,
 consider the following simple 1D convolution function.
 This function computes the convolution between an input array and a fixed
 kernel, disregarding endpoints for simplicity.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},language=C"
inline false
status open

\begin_layout Plain Layout

static float kernel[5] = {0.1, 0.25, 0.3, 0.25, 0.1};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void convolve(int size, float *input, float *output)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    int i, j;
\end_layout

\begin_layout Plain Layout

    for (i = 2; i < size - 2; ++i)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        output[i] = 0;
\end_layout

\begin_layout Plain Layout

        for (j = 0; j < 5; ++j)
\end_layout

\begin_layout Plain Layout

            output[i] += input[i-2+j] * kernel[j];
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We use malloc to allocate two reasonably sized arrays (N = 0x100000), skipping
 initialization to save some cycles.
 Recall that for large allocation, mmap is likely used internally for malloc,
 meaning that input and output are most likely initialized to zero.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},language=C"
inline false
status open

\begin_layout Plain Layout

int main(void) {
\end_layout

\begin_layout Plain Layout

    float *input  = malloc(N*sizeof(float));
\end_layout

\begin_layout Plain Layout

    float *result = malloc(N*sizeof(float));
\end_layout

\begin_layout Plain Layout

    convolve(N, input, result);
\end_layout

\begin_layout Plain Layout

    return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We use the perf utility to measure number of cycles, PARTIAL_ADDRESS_ALIAS
 and RESOURCE_STALLS.ALL.
 The program was compiled with GCC and optimization O3.
 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\scriptsize}"
inline false
status open

\begin_layout Plain Layout

        12,391,475 cycles:u                  #    0.000 GHz             
         ( +-  1.06% )
\end_layout

\begin_layout Plain Layout

         9,039,041 r0107:u                                             
          ( +-  0.79% )
\end_layout

\begin_layout Plain Layout

         7,931,308 r01a2:u                                             
          ( +-  0.17% )
\end_layout

\begin_layout Plain Layout

        11,163,873 instructions:u            #    0.90  insns per cycle 
         ( +-  0.00% )
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

       0.004906424 seconds time elapsed                                 
         ( +-  1.33% )
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As suspected, the code generates a huge number of address alias conflicts
 and resource stalls.
 For moderately large allocations, the input and output arrays will 
\emph on
always
\emph default
 be aligned to 12 bits.
 The likely cause of alias problems here is a conflict between input[i]
 and output[i].
 Although distinct memory locations, the out of order memory system detects
 conflicts.
 The hypothesis can be tested by offseting one of the arrays before calling
 convolve.
 We allocate some extra space for output, and use pointer arithmetic to
 offset the buffer sent to convolve.
 Offset is defined using a compile directive, adding no overhead in the
 generated source.
 The impact of a constant addition of allocated space is neglegtible.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},language=C"
inline false
status open

\begin_layout Plain Layout

    float *result = malloc((N + 0x100)*sizeof(float));
\end_layout

\begin_layout Plain Layout

    convolve(N, input, (result + OFFSET));
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="8">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
x
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x01
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x04
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x08
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x0c
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x10
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x14
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-O0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Not very interesting, but some savings from offseting a little.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-O1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-O2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-O3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Performance statistics for 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=C"
inline true
status open

\begin_layout Plain Layout

convolve(input, (result + x), N)
\end_layout

\end_inset

, with varying offset x, and array size N of 0xffff.
 Measured using 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=C"
inline true
status open

\begin_layout Plain Layout

perf stat -e r0107:u -r 10
\end_layout

\end_inset

, counting number of partial address alias events averaged over 10 runs.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
TODO: Might want graph to visualize number of address alias per offset and/or
 cycles.
\end_layout

\begin_layout Standard
The best parameter is found to be at a 16 element difference in alignment
 between input and output.
 Adding 0x10 to the output pointer (allocating some extra space to compensate),
 we get much faster code.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small}"
inline false
status open

\begin_layout Plain Layout

         5,719,361 cycles:u                  #    0.000 GHz             
         ( +-  1.30% )
\end_layout

\begin_layout Plain Layout

             1,094 r0107:u                                             
          ( +-  2.19% )
\end_layout

\begin_layout Plain Layout

         1,351,256 r01a2:u                                             
          ( +-  1.43% )
\end_layout

\begin_layout Plain Layout

        11,163,873 instructions:u            #    1.95  insns per cycle 
         ( +-  0.00% )
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

       0.002919409 seconds time elapsed                                 
         ( +-  1.03% )
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that the number of alias conflicts reduces with increasing offset.
 This is likely because adjacent indeces are accessed in the loop.
 If output is offset by 0x01, then output[i] is aliased with input[i-1].
 Intuitively, one could suspect that an offset of 3 floats would be enough
 to eliminate alias, as the maximum difference is 2.
 (Is this true for low optimization?) We find that as many as 16 is needed
 on the highest level of optimization, illustrating the depth of speculative
 execution of memory operations.
 
\end_layout

\begin_layout Standard
Interestingly, neither O1, O2 or O3 was able to do anything about this --
 yet a very simple change with no obvious significance gave a speedup of
 over 1.4x.
 
\end_layout

\begin_layout Subsubsection*
Architectural Optimization Flags
\end_layout

\begin_layout Standard
Because address aliasing is an artifact of intricacies in the Intel Core
 architecture, we could hope that GCC will help when provided this information.
 In the documentation
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset CommandInset href
LatexCommand href
name "http://gcc.gnu.org/onlinedocs/gcc-4.6.3/gcc/i386-and-x86_002d64-Options.html"
target "http://gcc.gnu.org/onlinedocs/gcc-4.6.3/gcc/i386-and-x86_002d64-Options.html#i386-and-x86_002d64-Options"

\end_inset


\end_layout

\end_inset

 we find four possible architecture specifications; 
\emph on
native
\emph default
, 
\emph on
core2
\emph default
, 
\emph on
corei7
\emph default
 and 
\emph on
corei7-avx
\emph default
.
 Native seems to produce code equivalent to corei7-avx.
 Using the -march=native flag does indeed prodice better code, but not as
 efficient as offseting arrays manually and not specifying any particular
 architecture.
 Note that code compiled with these flags are not guaranteed to work on
 other architectures, reducing portability.
\end_layout

\begin_layout Subsubsection*
Use of restrict
\end_layout

\begin_layout Standard
We can provide additional information to the compiler's optimizer by using
 the restrict keyword for the input and output arrays.
 This keyword was added in the C99 standard.
 It functions as a type qualifier for pointers, specifying that no pointer
 aliases exists.
 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},language=C"
inline false
status open

\begin_layout Plain Layout

void convolve(int size, const float * restrict input, float * restrict output)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
By marking input and output as restrict, we guarantee they are the only
 pointers to their respective memory areas, and not accesses through any
 other (aliased) pointers.
 This results in much more efficient code.
 We find that the following compile parameters for gcc provide the best
 code.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small}"
inline false
status open

\begin_layout Plain Layout

cc -O3 -std=c99 -march=native
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We see that the cycle count is drastically reduced, down to about 3.5 million.
 However, we still have over 1 million resource stalls, and 250 thousand
 alias events, which might indicate that even providing restrict is not
 enough.
 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small}"
inline false
status open

\begin_layout Plain Layout

         3,565,704 cycles:u                  #    0.000 GHz             
         ( +-  0.20% )
\end_layout

\begin_layout Plain Layout

           258,469 r0107:u                                             
          ( +-  0.05% )
\end_layout

\begin_layout Plain Layout

         1,065,207 r01a2:u                                             
          ( +-  0.59% )
\end_layout

\begin_layout Plain Layout

         3,299,634 instructions:u            #    0.93  insns per cycle 
         ( +-  0.00% )
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

       0.002281839 seconds time elapsed                                 
         ( +-  0.76% )
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Again, we test the hypothesis by incrementing an offset to the ouput pointer
 before calling convolve.
 At 0x30, we find the optimal configuration.
 We reduce the number of alias effects to a neglegtible amount, and numberof
 resource stalls is cut in half.
 Even with every opportunity for optimization given to the compiler, we
 are still able to squeeze out a speedup of 1.16x just by changing memory
 addresses.
 This speedup is consistent through input sizes, similar for 0x1000000.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small}"
inline false
status open

\begin_layout Plain Layout

         3,070,418 cycles:u                  #    0.000 GHz             
         ( +-  0.32% )
\end_layout

\begin_layout Plain Layout

               206 r0107:u                                             
          ( +- 27.26% )
\end_layout

\begin_layout Plain Layout

           580,203 r01a2:u                                             
          ( +-  1.82% )
\end_layout

\begin_layout Plain Layout

         3,299,634 instructions:u            #    1.07  insns per cycle 
         ( +-  0.00% )
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

       0.002118936 seconds time elapsed                                 
         ( +-  0.67% )
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that the resulting binaries, providing no offset and offset of 0x30,
 were checked with 'diff'.
 They only differ in two lines in main, where a leaq is used instead of
 move (for addition), and different register for another movq instruction.
\end_layout

\begin_layout Subsubsection*
Other Compilers
\end_layout

\begin_layout Standard
The alias effects on this particular example is most prominent on GNU's
 cc.
 We have tested on clang and icc as well -- with varying results.
 
\end_layout

\begin_layout Description
clang behaves similar to cc with respect to offsets to minimize alias.
 However, we only need to add 0x10 to get rid of aliasing.
 The change in cycle count is not as clear (Need more controlled benchmark).
 A lot less efficient code is generated, almost ten times as many dynamic
 instructions executed.
\end_layout

\begin_layout Description
icc produces code that performs reasonably well with respect to alias count
 on no additional offset.
 Interestingly, a very similar count of address alias events are recorded
 for code compiled with cc, about 260,000 for N = 0x100000.
 Alias can be eliminated almost completely, but that requires an offset
 of 0xa0.
 Performance actually worsenes with smaller offsets, increasing alias count
 significantly.
\end_layout

\begin_layout Subsection
Libraries as Environment Bias
\end_layout

\begin_layout Standard
The previous example does not show measurement bias per se, but rather an
 artifact of the particular implementation of malloc.
 A perfectly legal implementation of malloc could insert offsets on every
 other large request.
 Bottom line is: dynamically linked libraries are part of the execution
 environment.
 
\end_layout

\begin_layout Standard
In the case of memory allocators alone, there are several options: The one
 used in GNU's libc is 
\series bold
ptmalloc
\series default

\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset CommandInset href
LatexCommand href
name "http://www.malloc.de/en/"
target "http://www.malloc.de/en/"

\end_inset


\end_layout

\end_inset

, which is based on Doug Lea's malloc
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset CommandInset href
LatexCommand href
name "http://g.oswego.edu/dl/html/malloc.html"
target "http://g.oswego.edu/dl/html/malloc.html"

\end_inset


\end_layout

\end_inset

, Hoard
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset CommandInset href
LatexCommand href
name "http://www.hoard.org/"
target "http://www.hoard.org/"

\end_inset


\end_layout

\end_inset

, nedmalloc 
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset CommandInset href
LatexCommand href
name "http://www.nedprod.com/programs/portable/nedmalloc/"
target "http://www.nedprod.com/programs/portable/nedmalloc/"

\end_inset


\end_layout

\end_inset

 and tcmalloc
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset CommandInset href
LatexCommand href
name "http://google-perftools.googlecode.com/svn/trunk/doc/tcmalloc.html"
target "http://google-perftools.googlecode.com/svn/trunk/doc/tcmalloc.html"

\end_inset


\end_layout

\end_inset

.
 Many allocators try to battle lock contention for multithreaded programs,
 where each thread share a common heap space.
 Allocating and freeing dynamic memory from a shared pool must be synchronized
 in some way.
 Testing multiple allocators might be worthwile, particularly for multithreaded
 applications.
 A potential cause of producing 
\begin_inset Quotes eld
\end_inset

bad data
\begin_inset Quotes erd
\end_inset

 is optimizing around a bad allocator, or one that perform sub-optimally
 on a particular usage pattern.
\end_layout

\begin_layout Standard
Need some measurements to support this claim ...
 Pretty easy to test malloc replacements, just change LD_PRELOAD apparently.
 Question: Does any of the implementations of malloc optimize for parallell
 sequential array access, reducing alias effects? Probably not, which is
 cool! Could suggest fix.
 (Heuristic, or static analysis, etc).
\end_layout

\begin_layout Description
Hoard Same behaviour on large allocations.
 Returned addresses always ends in 0x070.
 Significantly larger cycle count, but same number of address alias events.
 Could not compile from source, linked with dynamic library.
\end_layout

\begin_layout Description
nedmalloc Did not compile -- no prebuilt binary.
\end_layout

\begin_layout Description
tcmalloc Aligns at page boundary, ending in 0x000.
 Uses low addresses, 0xa49000 etc.
 Returns page-aligned areas for smaller allocations as well -- possible
 environment bias.
\end_layout

\begin_layout Standard
We did some testing with three of the libraries, allocating two arrays of
 equal length for different sizes.
 The libraries produce very different results.
 The default implementation alternates between using the brk segment (low
 addresses and non-aligned, and mmap on higher segments.
 Tcmalloc tends to put variables on page boundaries, also for small sizes,
 returning addresses ending in 0x000.
 Hoard tends to align on page boundaries for larger requests, with addresses
 ending in 0x070.
 
\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="9" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Size
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Default (libc)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
tcmalloc
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Hoard
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="3" alignment="left" valignment="middle" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0xf00
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x603010
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x695
\series bold
000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x2aaaac000070
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x606c20
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x699
\series bold
000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x2aaaac004000
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="3" alignment="left" valignment="middle" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x1234
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x603010
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x69d
\series bold
000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x2aaaac010070
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x6078f0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x6a2
\series bold
000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x2aaaac014d38
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="3" alignment="left" valignment="middle" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0xffff
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x2aaaaaad1
\series bold
010
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x6a7
\series bold
000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x2aaaac020
\series bold
070
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x2aaaaab12
\series bold
010
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x6e7
\series bold
000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x2aaaac070
\series bold
070
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="3" alignment="left" valignment="middle" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x10000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x603010
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x6a7
\series bold
000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x2aaaac020
\series bold
070
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x643020
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x6e7
\series bold
000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x2aaaac070
\series bold
070
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:malloc-impl-tuples"

\end_inset

Addresses returned when allocating two float arrays of the same size, examples
 of possible sources for alias conflicts.
 Tests were run with ASLR disabled for reproducible results, but we get
 similar results with randomization enabled.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:malloc-impl-tuples"

\end_inset

 shows that potential for address alias conflicts depends on the particular
 implementation of malloc used.
 We see several examples of cases where switching library can eliminate
 alias by changing suffix on pointers.
 Note that tcmalloc aligns to page boundary in all cases.
 
\end_layout

\begin_layout Standard
Most allocators focus on efficiency in a multithreaded environment, and
 we find that none of the alternatives tested attempts to solve the aliasing
 problem for aligned arrays.
\end_layout

\begin_layout Section
The Loop Stream Detector
\end_layout

\begin_layout Standard
The Loop Stream Detector (LSD) is a front-end hardware optimization introduced
 in the intel Core microarchitecture.
 Measuring the utilization of LSD is supported by the LSD.UOPS and LSD.OVERFLOW
 performance counters.
 Note that this counter is not listed in Table 19-5.
\end_layout

\begin_layout Standard
The requirements for a loop to fit into the LSD cache is stated in the manual
 as the following:
\end_layout

\begin_layout Itemize
Up to eight chunk fetches of 32 (0x20) instruction-bytes (0x100).
 Online docs for 32 nm i7 states four 16-byte fetches.
\end_layout

\begin_layout Itemize
Up to 28 micro-ops (~28 instructions).
 For Ivy Bridge with HT disabled, each core gets 56 entries in micro-op
 queue.
 
\end_layout

\begin_layout Itemize
All micro-ops are also resident in the Decoded ICache.
\end_layout

\begin_layout Itemize
Can contain no more than eight taken branches and none of them can be a
 CALL or RET.
 Online docs for 32 nm i7 states 4 branches.
\end_layout

\begin_layout Itemize
Cannot have mismatched stack operations.
 For example, more PUSH than POP instructions.
 
\end_layout

\begin_layout Itemize
Loops should have at least 64 iterations.
\end_layout

\begin_layout Subsection
Properties Of The Loop Stream Detector
\end_layout

\begin_layout Standard
Creating simple loops and compiling with gcc.
 Binary is inspected to check what instructions are executed, and their
 address layout.
 
\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="left" valignment="top" width="50text%">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
HT off
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
HT on
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Comment
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Chunk fetches
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Executed chunks of instruction addresses must fit in at most 12 chunks aligned
 to 0x20 (32 byte).
 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Micro-ops
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
56
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
28
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Overflows after 52 addl 0x1 instructions.
 4 extra instructions for text/compare as well, before the jump instruction.
 56 entries seems to be correct for Ivy Bridge as well as Sandy Bridge.
\end_layout

\begin_layout Plain Layout
With HT on, the LSD_OVERFLOW counter becomes non-zero on 27 instructions,
 then zero on 28, and nonzero from there.
 28 is probably the right value -- half of 56.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Taken branches
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
17 (+1)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Handles up to 17 branches (+1 for loop) with a single statement 
\begin_inset Quotes eld
\end_inset

a++, b++
\begin_inset Quotes erd
\end_inset

.
 Triggers LSD_OVERFLOW event.
\end_layout

\begin_layout Plain Layout
Some weird things with HT on, but it seems like 12 is right.
 Might be too many instructions though..
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Experimental LSD properties of i7 Ivy Bridge
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Relatively easy to test limit of taken branches and number of micro-ops.
 For mops, we created a loop of 
\begin_inset Quotes eld
\end_inset

addl
\begin_inset Quotes erd
\end_inset

 instructions, incrementing until LSD_OVERFLOW indicated that the limit
 is reached.
\end_layout

\begin_layout Subsection
Bias from Chunk Fetch Limit
\end_layout

\begin_layout Standard
The stated limit of 8*32B of instructions is way too much for consecutive
 live loop statements.
 To test this limit we have to space out the executed instructions with
 lots of branches.
 In the following program, the macro expands to 9*3B of mov instructions.
 The cmp and jump instructions generated by the branch makes up another
 5 bytes, making every statement a total of 32B.
 Every branch is not taken -- thus the instructions actually executed in
 each iteration is just the compare and branch.
 
\end_layout

\begin_layout Standard
\noindent
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},showstringspaces=false"
inline false
status open

\begin_layout Plain Layout

#define B27 a=b,a=b,a=b,a=b,a=b,a=b,a=b,a=b,a=b
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int loop() {
\end_layout

\begin_layout Plain Layout

    register int i = 0, a = 1, b = 1;
\end_layout

\begin_layout Plain Layout

    while (i++ < 0x12345678) {
\end_layout

\begin_layout Plain Layout

        if (a != b) B27;
\end_layout

\begin_layout Plain Layout

        if (a != b) B27;
\end_layout

\begin_layout Plain Layout

        if (a != b) B27;
\end_layout

\begin_layout Plain Layout

        if (a != b) B27;
\end_layout

\begin_layout Plain Layout

        if (a != b) B27;
\end_layout

\begin_layout Plain Layout

        if (a != b) B27;
\end_layout

\begin_layout Plain Layout

        if (a != b) B27;
\end_layout

\begin_layout Plain Layout

        if (a != b) B27;
\end_layout

\begin_layout Plain Layout

        if (a != b) B27;
\end_layout

\begin_layout Plain Layout

        if (a != b) B27;
\end_layout

\begin_layout Plain Layout

        if (a != b) B27;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    return i;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main() {
\end_layout

\begin_layout Plain Layout

    loop();
\end_layout

\begin_layout Plain Layout

    return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Loop spanning up to 13 chunks of 32 bytes when compiled with gcc
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Compiling this using gcc and no optimization, we see that the loop stream
 detector is not applied to this loop.
 The address of the first instruction is 0x4004d3, and the last 0x400643.
 If instructions are buffered in chunks of 32B, then chunks must be a multiple
 of 0x20.
 The first instruction is pretty far into the 0x4004
\series bold
c0
\series default
 chunk, while the last instruction is just inside the 0x4006
\series bold
40
\series default
 chunk.
 A total of 13 chunks of 32 bytes is executed -- apparently too much for
 the LSD.
 We use the perf utility to measure total number of un-halted cycles, as
 well as the LSD_OVERFLOW and LSD_UOPS events.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily}"
inline false
status open

\begin_layout Plain Layout

     7,640,342,761 cycles:u                  #    0.000 GHz             
       
\end_layout

\begin_layout Plain Layout

                 0 r0120:u                                             
        
\end_layout

\begin_layout Plain Layout

            10,974 r01a8:u                                             
        
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

       2.249628298 seconds time elapsed
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Observe that by carefully aligning the first instruction, we can fit the
 code into only 12 instruction chunks.
 By inserting 13 nop instruction in the assembly code before the loop, addresses
 of the first and last instructions are offset to, respectively, 0x4004e0
 and 0x400650.
 0xe0 is at the very beginning of a chunk, and 0x50 leaves room for another
 16 bytes (6 of which are occupied by the very last jump instruction).
 Running the same program with these 13 nop instructions results in a dramatic
 improvement in performance.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily}"
inline false
status open

\begin_layout Plain Layout

     3,669,478,538 cycles:u                  #    0.000 GHz             
       
\end_layout

\begin_layout Plain Layout

                 0 r0120:u                                             
        
\end_layout

\begin_layout Plain Layout

     4,579,426,057 r01a8:u                                             
        
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

       1.080381834 seconds time elapsed
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To further strengthen the hypothesis that twelve 32B chunks is the limit,
 we can add another 10 bytes at the very end of the loop and get similar
 results.
 With 11 extra bytes -- spilling instructions over to the next chunk --
 LSD_UOPS is back at 11k.
 
\end_layout

\begin_layout Paragraph
Hyper-threading
\end_layout

\begin_layout Standard
Experiments were repeated with hyperthreading turned on -- and we got the
 same results.
 It seems like HT does not affect the chunk fetch limit of the LSD.
\end_layout

\begin_layout Subsection
Optimization
\end_layout

\begin_layout Standard
\begin_inset Quotes eld
\end_inset

These results are irrelevant, any sensible compiler will fix it when using
 optimizations
\begin_inset Quotes erd
\end_inset

, you might say.
 Interestingly, this is not the case -- with a few modifications we can
 produce the exact same effects on gcc with -O3.
\end_layout

\begin_layout Standard
align-loops option in gcc (which is enabled by default in O2 and O3) does
 in fact align loops -- by inserting 
\begin_inset Quotes eld
\end_inset

.palign x,y,z
\begin_inset Quotes erd
\end_inset

 directives into the assembly.
 In front of the first loop instruction, the following assembly directives
 are printed.
\begin_inset listings
lstparams "basicstyle={\small\ttfamily}"
inline false
status open

\begin_layout Plain Layout

.p2align 4,,10
\end_layout

\begin_layout Plain Layout

.p2align 3
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The first directive tries to align to four bits, inserting at most 10 bytes
 for padding.
 If that does not work, the next directive forces loops to be aligned to
 three bytes -- meaning addresses ends in 0x0 or 0x8.
 Within a 32B instruction block, the first loop instruction can end up having
 one of the four suffixes 0x00, 0x08, 0x10 or 0x18.
 Using this knowledge, we can construct another example that overflows the
 12 blocks for certain alignment.
 
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "49col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\emph on
fact.c:
\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\ttfamily}"
inline false
status open

\begin_layout Plain Layout

int fact(int n)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    int a = 1;
\end_layout

\begin_layout Plain Layout

    return a;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Plain Layout

\emph on
lsd.c:
\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\ttfamily}"
inline false
status open

\begin_layout Plain Layout

#include <stdio.h>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    int i = loop(10);
\end_layout

\begin_layout Plain Layout

    int f = fact(10);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    printf("Loop: %d
\backslash
n", i);
\end_layout

\begin_layout Plain Layout

    printf("Fact: %d
\backslash
n", f);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "50col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\emph on
loop.c:
\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\ttfamily}"
inline false
status open

\begin_layout Plain Layout

#define B22(n) b += i*i*a + 1
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

volatile int i = 42;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int loop(int a)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    register int b = i==42 ? 1 : 0;
\end_layout

\begin_layout Plain Layout

    do {
\end_layout

\begin_layout Plain Layout

        if (!i) B22(1);
\end_layout

\begin_layout Plain Layout

        if (!i) B22(2);
\end_layout

\begin_layout Plain Layout

        if (!i) B22(3);
\end_layout

\begin_layout Plain Layout

        if (!i) B22(4);
\end_layout

\begin_layout Plain Layout

        if (!i) B22(5);
\end_layout

\begin_layout Plain Layout

        if (!i) B22(6);
\end_layout

\begin_layout Plain Layout

        if (!i) B22(7);
\end_layout

\begin_layout Plain Layout

        if (!i) B22(8);
\end_layout

\begin_layout Plain Layout

        if (!i) B22(9);
\end_layout

\begin_layout Plain Layout

        if (!i) B22(10);
\end_layout

\begin_layout Plain Layout

        if (!i) B22(11);
\end_layout

\begin_layout Plain Layout

   } while (i++ < 0x12345678);
\end_layout

\begin_layout Plain Layout

    return b;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Program that differ by 2x in cycle count depending on link order.
 Works on optimization level O3 on GCC.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Compiling these using two different link orders yields the same speedup
 of 2x for the one with fact.c linked before loop.c.
 
\end_layout

\begin_layout Subsection
Bias effects from trivial source code changes
\end_layout

\begin_layout Standard
If we consider link order to be a possible source of bias, then what about
 other seemingly trivial changes to the program source itself? Keeping in
 mind that alignment and memory address of instructions can have huge impacts
 on performance -- in what ways can this be altered?
\end_layout

\begin_layout Standard
Useful commands for analysing binary files: 
\end_layout

\begin_layout Standard
ldd a.out : Print shared library dependencies
\end_layout

\begin_layout Standard
nm (-u) a.out : List symbols
\end_layout

\begin_layout Standard
readelf -a a.out : List ELF info
\end_layout

\begin_layout Standard
objdump -D a.out : Disassemble
\end_layout

\begin_layout Standard
strip a.out : Removes .symtab and .strtab.
 See thread for more info: http://stackoverflow.com/questions/9401217/is-the-elf-
notes-section-really-needed
\end_layout

\begin_layout Standard
elfedit: GNU utility to edit some fields.
 Very limited properties, doesn't look like arbitrary big strings can be
 inserted.
\end_layout

\begin_layout Standard
ht: Downloaded and built from source.
 Too complex :p
\end_layout

\begin_layout Standard
patchelf: Works for changing dynamic linker.
 Nice explanation on homepage.
 
\end_layout

\begin_layout Subsubsection*
The order of functions within a source file
\end_layout

\begin_layout Standard
Given a program with functions foo and bar, listing foo before bar and vice
 versa generates two 
\begin_inset Quotes eld
\end_inset

different
\begin_inset Quotes erd
\end_inset

 programs given that equality is based on absolute memory layout.
 Gcc prints functions to the text segment in the order they appear in the
 source code.
\end_layout

\begin_layout Paragraph*
Long function names
\end_layout

\begin_layout Standard
Function names are placed in the .strtab section in the ELF file.
 When running readelf or objdump, the names are used to print nice output.
 However, function names of external symbols resolved at run-time does affect
 code layout.
 Longer function names (or more external dependencies) will offset the text
 segment because of allocable segments related to dynamic linking is placed
 before text.
 This includes dynsym, dynstr, gnu.version and rela sections in an executable
 made with GCC.
\end_layout

\begin_layout Paragraph
Using strip
\end_layout

\begin_layout Standard
Various sections of the ELF binary is not necessarily needed for normal
 execution.
 Quite a lot of extra information is included to aid in debugging etc.
 The strip command gets rid of symbol table and stringtable.
 These sections are non-allocable, so itdoes not affect code layout.
 Printing with objdump for example will not be as nice.
 Text segment is not marked with functions (internally resolved symbols).
 
\end_layout

\begin_layout Standard
It is possible to specify specific segments to remove using the -R parameter.
 Removing the .note sections for example, will probably not prevent the program
 from running correctly.
 Even though they are located (and allocated) before the .text segment, stripping
 them out will not offset code.
 This makes sense, as any reordering would require offseting every jump
 address accordingly.
\end_layout

\begin_layout Subsubsection*
Changing Interpreter
\end_layout

\begin_layout Standard
In principle, anything that can change the memory layout of the code or
 data in a program can cause bias.
 Looking at the ELF file generated with cc, we find several segments that
 preceeds .text, where code is.
 By altering the size of any of thezse increasing the size of 
\end_layout

\begin_layout Standard
Details for each of the ELF sections on GNU platform can be found in the
 man pages 
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset CommandInset href
LatexCommand href
name "http://linux.die.net/man/5/elf"
target "http://linux.die.net/man/5/elf"

\end_inset


\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
TODO: Create example with injecting loader triggers lsd.
\end_layout

\begin_layout Description
.interp ELF interpreter/linker to be loaded.
 Default on our system is 
\begin_inset Quotes eld
\end_inset

/lib64/ld-linux-x86-64.so.2
\begin_inset Quotes erd
\end_inset

.
 This can indeed vary, and there are tools for changing interpreter in compiled
 binaries (patchelf).
 It can be changed with a compile flag to the GCC linker with -Wl,-dynamic-linke
r,/home/lars/very/long/path/to/another/loader.symlink.so.2.
 This does indeed move everything, a plausible way to change code layout.
\end_layout

\begin_layout Description
.note.ABI-tag Formatted as comment section from ELF standard.
 Specifies OS (0 for Linux), and earliest compatible Linux kernel 
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset CommandInset href
LatexCommand href
name "http://refspecs.linuxfoundation.org/LSB_1.2.0/gLSB/noteabitag.html"
target "http://refspecs.linuxfoundation.org/LSB_1.2.0/gLSB/noteabitag.html"

\end_inset


\end_layout

\end_inset

.
 Example from ELF output.
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily}"
inline false
status open

\begin_layout Plain Layout

Notes at offset 0x00000254 with length 0x00000020:
\end_layout

\begin_layout Plain Layout

  Owner                 Data size	Description
\end_layout

\begin_layout Plain Layout

  GNU                  0x00000010	NT_GNU_ABI_TAG (ABI version tag)
\end_layout

\begin_layout Plain Layout

    OS: Linux, ABI: 2.6.24
\end_layout

\end_inset


\end_layout

\begin_layout Description
.note.gnu.build-id Bitstring with some kind of hash to identify the build.
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily}"
inline false
status open

\begin_layout Plain Layout

Notes at offset 0x00000274 with length 0x00000024:
\end_layout

\begin_layout Plain Layout

  Owner                 Data size	Description
\end_layout

\begin_layout Plain Layout

  GNU                  0x00000014	NT_GNU_BUILD_ID (unique build ID bitstring)
\end_layout

\begin_layout Plain Layout

    Build ID: a449e580b52059227cbefd8d4454a9c6f16b9cde
\end_layout

\end_inset


\end_layout

\begin_layout Description
.gnu.hash Some hash value.
 28 bytes on our machine.
 An 
\begin_inset Quotes eld
\end_inset

old
\begin_inset Quotes erd
\end_inset

 hash method can be used by providing linker options, but that might break
 libc compatibility.
\end_layout

\begin_layout Description
.dynsym As explained very well here 
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset CommandInset href
LatexCommand href
name "https://blogs.oracle.com/ali/entry/inside_elf_symbol_tables"
target "https://blogs.oracle.com/ali/entry/inside_elf_symbol_tables"

\end_inset


\end_layout

\end_inset

, there are two symbol tables in ELF files; 
\begin_inset Quotes eld
\end_inset

.dynsym
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

.symtab
\begin_inset Quotes erd
\end_inset

.
 Only dynsym is allocable (marked with 'A' in readelf) -- meaning it will
 occupy virtual address space in the running process.
 This is needed for global external symbols, references that needs to be
 resolved at runtime.
 References to library functions such as 
\begin_inset Quotes eld
\end_inset

printf
\begin_inset Quotes erd
\end_inset

 appears in dynsym, and is resolved at runtime after libc (or whatever standard
 library) is loaded.
 The symtab section is not allocable, and contains all symbols (including
 those in dynsym).
 
\end_layout

\begin_layout Description
.dynstr The string table associated with dynamically linked symbols.
 Probably indexed into by dynsym.
 
\end_layout

\begin_layout Description
.gnu.version A table of version numbers.
 Increasing with more external references to library functions.
\end_layout

\begin_layout Description
.gnu.version_r More version table stuff.
\end_layout

\begin_layout Description
.rela.dyn Relocation stuff, for 
\begin_inset Quotes eld
\end_inset

'dyn
\begin_inset Quotes erd
\end_inset

 section? These also change with more external references.
\end_layout

\begin_layout Description
.rela.plt Relocation stuff for plt section.
\end_layout

\begin_layout Description
.init Executable instructions that are done before main is called.
\end_layout

\begin_layout Description
.plt Procedure Linkage Table.
 Also changes with more external references.
 Manual says attributes are processor specific.
\end_layout

\begin_layout Description
.text Executable code.
 This is the interesting part -- if changes to any other section offsets
 this, we might experience bias effects.
\end_layout

\begin_layout Description
.fini
\end_layout

\begin_layout Description
.rodata Read-only data ?
\end_layout

\begin_layout Description
.eh_frame_hdr
\end_layout

\begin_layout Description
.eh_frame
\end_layout

\begin_layout Description
.ctors
\end_layout

\begin_layout Description
.dtors
\end_layout

\begin_layout Description
.jcr
\end_layout

\begin_layout Description
.dynamic
\end_layout

\begin_layout Description
.got
\end_layout

\begin_layout Description
.got.plt ?
\end_layout

\begin_layout Description
.data 
\end_layout

\begin_layout Description
.bss Uninitialized data.
 Will be initialized to zero once program is loaded.
 Occupies no space in ELF file.
\end_layout

\begin_layout Description
.comment 
\begin_inset Quotes eld
\end_inset

Version control information
\begin_inset Quotes erd
\end_inset

 from the documentation.
 Contains the compiler version used: 
\begin_inset Quotes eld
\end_inset

GCC: (Ubuntu Linaro 4.6.3-1ubuntu5) 4.6.3
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Description
.shstrtab Section names, such as 
\begin_inset Quotes eld
\end_inset

.text
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

.dtors
\begin_inset Quotes erd
\end_inset

 etc.
 Each section listed in the ELF file contains an index to its name in this
 section.
\end_layout

\begin_layout Description
.symtab Symbol table.
 Nice printout in readelf.
 Entries point to .strtab and .dynstr for names.
\end_layout

\begin_layout Description
.strtab Symbol names used in the source file.
 Function names are placed here.
\end_layout

\begin_layout Chapter
Case Studies
\end_layout

\begin_layout Standard
In this chapter we show how bias effects illustrated in the previous chapter
 is present in real software, and poses a significant challenge for performance
 benchmarks.
 In addition to pointing out problems, also show how measures can be taken
 to handle bias, and obtain a speedup on average over the space of possible
 contexts.
 
\end_layout

\begin_layout Section
FFTW
\end_layout

\begin_layout Standard
As an integral part of applications such as signal and image processing,
 a huge amount of work has been done over the years to optimize and tweak
 the performance of the Fast Fourier Transform (FFT).
 Today, there are a plethora of excellent implementations available, among
 them FFTW
\begin_inset Foot
status open

\begin_layout Plain Layout
FFTW Home Page,
\begin_inset CommandInset href
LatexCommand href
name "http://www.fftw.org/"
target "http://www.fftw.org/"

\end_inset


\end_layout

\end_inset

, an acronym for 
\begin_inset Quotes eld
\end_inset

Fastest Fourier Transform in the West
\begin_inset Quotes erd
\end_inset

.
 Its design goal is to be portable, yet achieve close to optimal performance
 across a wide variety of platforms 
\begin_inset CommandInset citation
LatexCommand cite
key "Frigo:2005:FFTW3"

\end_inset

.
 The library is not optimized specifically for any processor or architecture,
 but uses 
\emph on
automatic tuning
\emph default
 to adapt to the underlying hardware 
\begin_inset CommandInset citation
LatexCommand cite
key "Vuduc:2000:CodegenFFTW"

\end_inset

.
 Provided that a speedup on average can be achieved, explicitly handling
 of context bias could be a realistic addition to FFTW.
\end_layout

\begin_layout Paragraph
Installation and Configuration
\end_layout

\begin_layout Standard
We used the latest version 3.3.3 of FFTW in all our tests, compiled from source
 and built as a shared library.
 For optimal performance on our machine, we explicitly enable support for
 sse2 and avx instruction set.
 In addition, we set the 
\begin_inset Quotes eld
\end_inset

march
\begin_inset Quotes erd
\end_inset

 compiler flag to 
\begin_inset Quotes eld
\end_inset

native
\begin_inset Quotes erd
\end_inset

, allowing the GCC to specifically tune generated code to our architecture.
 The configure script is invoked with the following parameters:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},breaklines=true"
inline false
status open

\begin_layout Plain Layout

./configure CC="gcc -march=native" --enable-shared --enable-sse2 --enable-avx
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph*
Test Setup
\end_layout

\begin_layout Standard
FFTW is a very comprehensive library with lots of functionality.
 Our approach will be to engineer simple use cases where bias is easily
 measurable.
 We create a small C program with two parameters; the number of elements
 to transform, and the number of times to repeat the transform.
 This way, slight bias in smaller input sizes can be amplified.
 The API calls from Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:fft-alias-program"

\end_inset

 are explained below.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},breaklines=true,language=C"
inline false
status open

\begin_layout Plain Layout

int main() 
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    fftw_complex *in  = fftw_malloc(sizeof(fftw_complex) * N);
\end_layout

\begin_layout Plain Layout

    fftw_complex *out = fftw_malloc(sizeof(fftw_complex) * N);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    for (int i = 0; i < N; ++i)
\end_layout

\begin_layout Plain Layout

        in[i][0] = i, in[i][1] = i;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    fftw_plan p = fftw_plan_dft_1d(N, in, out, FFTW_FORWARD, FFTW_ESTIMATE);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    for (int i = 0; i < X; ++i)
\end_layout

\begin_layout Plain Layout

        fftw_execute(p);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    fftw_destroy_plan(p);
\end_layout

\begin_layout Plain Layout

    fftw_free(in), fftw_free(out);
\end_layout

\begin_layout Plain Layout

    return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:fft-alias-program"

\end_inset

C program snippet for computing the Fourier transform of N double precision
 complex numbers X times.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Description
fftw_malloc A wrapper around the standard malloc, returning heap-allocated
 data.
 This is supposed to provide a stronger alignment guarantee than malloc
 does, needed for vectorized code.
 The system's default malloc might not align data on wide enough boundaries,
 although reasonable implementations do.
\end_layout

\begin_layout Description
fftw_plan_dft_1d This creates a 
\emph on
plan
\emph default
 for how to most efficiently compute a discrete fourier transform of size
 
\begin_inset Formula $N$
\end_inset

.
 This step encapsules the auto-tuning part of FFTW, as plans can be constructed
 based on actual measurements and benchmarks done on the current machine.
 Knowledge of well performing plans is stored as 
\emph on
wisdom
\emph default
, which is used to construct other plans later.
\end_layout

\begin_layout Description
fftw_execute Perform the computations specified by the given plan, calculating
 the Fourier tranform of 
\begin_inset Quotes eld
\end_inset

in
\begin_inset Quotes erd
\end_inset

 and writing the result to 
\begin_inset Quotes eld
\end_inset

out
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Subsection
Impact of Stack Position for Small Transforms
\end_layout

\begin_layout Standard
After attempting a couple of different configurations for tranform size
 and iteration count, we find that computing transforms of size 16 have
 noticeable bias to stack position.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Img/fft/default.eps
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:fftw-stack-bias"

\end_inset

Performance counter measurements for computing complex DFT of size 
\begin_inset Formula $N=16$
\end_inset

, repeated 
\begin_inset Formula $X=200{,}000$
\end_inset

 times.
 Address aliasing under some stack offsets negatively impacts cycle count.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:fftw-stack-bias"

\end_inset

 shows the relation between address alias and cycle count for repeated benchmark
s under increasing environment size.
 The same program is run 8192 times, adding one byte to the environment
 between each execution.
 This covers two 4KiB segments of lower order virtual address bits for stack
 position.
 As suspected, we get a graph with the same pattern repeating twice.
 As shown by the cycle count, position of stack significantly impacts performanc
e.
\end_layout

\begin_layout Subsection
Eliminating Bias by Modifying Kernels
\end_layout

\begin_layout Standard
Knowing address aliasing being the cause of bias, we can try to modify FFTW
 to detect and possibly avoid situations with abnormally high cycle count
 from Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:fftw-stack-bias"

\end_inset

.
 
\end_layout

\begin_layout Standard
An overview of what kernels are used to execute a plan can be found by calling
 fftw_print_plan.
 In our case, the plan reads 
\begin_inset Quotes eld
\end_inset

(dft-direct-16 "n1fv_16_avx")
\begin_inset Quotes erd
\end_inset

, specifying that the transform is computed directly by the n1fv_16 kernel,
 compiled with AVX instructions enabled.
 We use Valgrind 
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset CommandInset href
LatexCommand href
name "http://valgrind.org/"
target "http://valgrind.org/"

\end_inset


\end_layout

\end_inset

 to analyze the call graph from fftw_execute, showing a chain of calls eventuall
y leading to the kernel invocation.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Img/fft/callgraph.eps

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Call graph showing the actions taken after calling fftw_execute for the
 16 element transform.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The kernel itself is located in the file dft/simd/common/n1fv_16.c, which
 contains an automatically generated C program for computing a 16 element
 DFT
\begin_inset Foot
status open

\begin_layout Plain Layout
There are actually two separate implementations provided, one specifically
 optimized for architectures supporting fused multiply-add instructions.
 FFTW is compiled with FMA disabled in our case, as there are no such instructio
ns on the Ivy Bridge.
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},breaklines=true,language=C"
inline false
status open

\begin_layout Plain Layout

void n1fv_16(const R *ri, const R *ii, R *ro, R *io, stride is, stride os,
 INT v, INT ivs, INT ovs)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Conflicting memory accesses within n1fv_16 are causing bias effects.
 Looking at the generated assembly, we find three areas of memory whose
 address suffixes can potentially overlap.
 
\end_layout

\begin_layout Itemize
Heap allocated input and output buffers, parameters 
\begin_inset Quotes eld
\end_inset

ri
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

ro
\begin_inset Quotes erd
\end_inset

 respectively.
 These are pointers previously returned by calls to fftw_malloc, addresses
 in general unpredictable by the kernel, except for some alignment constraints.
\end_layout

\begin_layout Itemize
Stack allocated function parameters and local automatic variables.
 Although the six first arguments reside in registers 
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},breaklines=true"
inline true
status open

\begin_layout Plain Layout

%rdi
\end_layout

\end_inset

, 
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},breaklines=true"
inline true
status open

\begin_layout Plain Layout

%rsi
\end_layout

\end_inset

, 
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},breaklines=true"
inline true
status open

\begin_layout Plain Layout

%rdx
\end_layout

\end_inset

, 
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},breaklines=true"
inline true
status open

\begin_layout Plain Layout

%rcx
\end_layout

\end_inset

, 
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},breaklines=true"
inline true
status open

\begin_layout Plain Layout

%r8
\end_layout

\end_inset

 and 
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},breaklines=true"
inline true
status open

\begin_layout Plain Layout

%r9
\end_layout

\end_inset

, the remaining three are pushed on stack.
 
\end_layout

\begin_layout Itemize
Statically allocated constants in memory.
 Three floating point constants are statically built into the object file,
 their positions in virtual address space will be determined at runtime
 by the dynamic linker.
 
\end_layout

\begin_layout Standard
Under synthetic testing with address randomization (ASLR) disabled, all
 parameters are fixed and deterministic.
 For our particular test, the heap allocated input and output buffers always
 reside in virtual addresses 0x602040 and 0x601c0 respectively -- on the
 low end of a 4K segment of suffixes between 0x000 and 0xfff.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Img/fft/collision-random-rsp.eps

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Position of stack can be aligned anywhere within the space of virtual addresses
 
\begin_inset Formula $\bmod$
\end_inset

 0x1000.
 With ASLR disabled, the last 12 bits of ri and ro are 0x040 and 0x1c0 respectiv
ely.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The stack pointer at kernel invocation is difficult to observe without introduci
ng observer effects.
 However, it is a fair assumption that address alias happens when stack
 accesses collide with heap addresses, because most memory access instructions
 are either to temporary stack variables or to heap.
 The static constants are loaded initially, using only a few load instructions.
 
\end_layout

\begin_layout Subsubsection*
Adjusting Stack Placement at Runtime
\end_layout

\begin_layout Standard
The position of stack is unknown to the kernel at runtime.
 It can execute with a 
\begin_inset Quotes eld
\end_inset

good
\begin_inset Quotes erd
\end_inset

 configuration with few collisions, or a 
\begin_inset Quotes eld
\end_inset

bad
\begin_inset Quotes erd
\end_inset

 configuration as in one of the periodic peaks illustrated in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:fftw-stack-bias"

\end_inset

.
 Once fftw_execute is called, the only thing we can control is placement
 of stack allocated variables.
 
\end_layout

\begin_layout Standard
An interesting observation is that stack addresses are often specified relative
 to the stack pointer, as opposed to base pointer.
 Some examples include 
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},breaklines=true"
inline true
status open

\begin_layout Plain Layout

vmovapd %ymm14, -120(%rsp)
\end_layout

\end_inset

 and 
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},breaklines=true"
inline true
status open

\begin_layout Plain Layout

vaddpd -56(%rsp), %ymm7, %ymm12
\end_layout

\end_inset

.
 This suggests that merely offseting the rsp register within the n1fv_16
 kernel itself should impact the placement of local temporary variables.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Img/fft/collision-fixed-rsp.eps

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Collisions can be avoided by reseting the stack pointer to an address that
 does not conflict with the heap allocated pointers.
 With heap allocated ri and ro occupying 
\begin_inset Quotes eld
\end_inset

low
\begin_inset Quotes erd
\end_inset

 addresses, a reasonable placement of stack is in the other side of the
 spectrum, close to 0xfff and expanding towards lower addresses.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Looking at the call graph again, we have several options for where to programmat
ically align stack on a suitable address.
 In the end, we found that aligning in apply_extra_iter made the most sense,
 and also provided a slight gain compared to doing it within the kernel
 itself.
 As the name suggests, this function actually calls the kernel twice.
 
\end_layout

\begin_layout Standard
\noindent
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},breaklines=true"
inline false
status open

\begin_layout Plain Layout

static void apply_extra_iter(const plan *ego_, R *ri, R *ii, R *ro, R *io)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    void *rsp;
\end_layout

\begin_layout Plain Layout

    asm volatile (
\end_layout

\begin_layout Plain Layout

        "movq  %%rsp, %0;"
\end_layout

\begin_layout Plain Layout

        "andq  $-4096, %%rsp;"
\end_layout

\begin_layout Plain Layout

        : "=r"(rsp) : : );
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    (...)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    asm volatile (
\end_layout

\begin_layout Plain Layout

        "movq  %0, %%rsp;"
\end_layout

\begin_layout Plain Layout

        : : "r"(rsp) : );
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:apply-extra-iter"

\end_inset

Modified apply_extra_iter, aligning stack to a 4K boundary.
 The hidden function body makes two calls to the n1fv_16 kernel.
 Implementation is located in the file dft/direct.c.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The andq instruction from Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:apply-extra-iter"

\end_inset

 will zero out the last 12 bits of the %rsp register, effectively subtracting
 some number between 0 and 0xfff.
 Recall that the stack grows downwards, thus subtracting any (reasonably
 small) amount will not overwrite other data.
 We run the same benchmark again, results shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:fftw-modified"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Img/fft/modified.eps
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:fftw-modified"

\end_inset

Performance after stack fix is added to apply_extra_iter
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Over two 4K periods, the modified version is much less sensitive to stack
 placement, removing almost all the bias from previously.
 We also gain a 
\emph on
very
\emph default
 slight speedup on average, with mean cycle count reduced from 31,051,690
 to 30,947,460.
 More interestingly however, is the worst case performance, where we see
 a reduction in cycle count by 11.8 %.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="5">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Min
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Median
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Mean
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Max
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Default version
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
30,337,010
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
30,445,740
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
31,051,690
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
37,349,700
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Modified apply_extra_iter
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
30,760,320
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
30,885,300
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
30,947,460
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
32,909,300
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Cycle count statistics over 512 runs, sampling uniformly over two 4KiB periods
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Even though we are able to remove most of the alias effects, performance
 did not improve as much as we had hoped.
 The constant overhead added by inserting the extra instructions in apply_extra_
iter appears to be significant.
 Measuring instructions:u using perf, we see that about 1 million additional
 dynamic instructions are executed in the modified version, an increase
 of 1.3 %.
 
\end_layout

\begin_layout Subsubsection*
Creating the Worst Case
\end_layout

\begin_layout Standard
Let's draw a picture of the 4K memory map when running this function.
 Allocating another buffer of 7400B using regular malloc before calling
 fftw_malloc, pushing in and out to 0x604da0 and 0x604f00 respectively.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Img/fft/collision-overlap.eps

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:fftw-worstcase-4k"

\end_inset

Offseting heap addresses; with fixed stack from before, stack and heap accesses
 will always overlap -- regardless of environment size.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Img/fft/worstcase.eps
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:fftw-worstcase"

\end_inset

Bad heap alignment combined with stack fix results in aliasing consistently
 across all environment sizes.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
A General Solution
\end_layout

\begin_layout Standard
The static rule of aligning stack to page boundary only works with ASLR
 disabled, and because our fftw_malloc happens to place 
\begin_inset Quotes eld
\end_inset

ri
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

ro
\begin_inset Quotes erd
\end_inset

 close to the lower end of a 4KiB range of address suffixes.
 In general however, all the parameters are unknown.
 A hypothetical complete solution would require a function at least these
 three parameters to calculate the optimal stack offset.
\begin_inset Formula 
\[
f\left(\text{ri},\text{ro},\text{\%rsp}\right)\rightarrow\text{offset}
\]

\end_inset


\end_layout

\begin_layout Standard
A plausible solution to the previous 
\begin_inset Quotes eld
\end_inset

worst case
\begin_inset Quotes erd
\end_inset

 scenario from Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:fftw-worstcase-4k"

\end_inset

 would be to align stack to 
\begin_inset Quotes eld
\end_inset

ri
\begin_inset Quotes erd
\end_inset

, no longer overlapping the heap segments.
 Given the somewhat discouraging results from our simple static fix, we
 did not attempt to implement a function like this for the n1fv_16 kernel.
 The added cost of additional dynamic instructions will quickly cancel out
 any speedup we might get.
 
\end_layout

\begin_layout Subsubsection*
Heap-Heap Conflicts
\end_layout

\begin_layout Standard
In addition to heap addresses overlaping with stack, there is also a possibility
 of input and output arrays overlapping themselves.
 We suspected that additional address conflicts would be generated when
 the last 12 bits of 
\begin_inset Quotes eld
\end_inset

ri
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

ro
\begin_inset Quotes erd
\end_inset

 were close.
 However, we found that aligning input and output buffers did not cause
 any conflicts in itself for the n1fv_16 kernel.
 All alias seems to come from conflicting accesses between input/output
 and stack.
 
\end_layout

\begin_layout Subsection
Bias in Other Kernels
\end_layout

\begin_layout Standard
So far we have only looked at one particular kernel, although FFTW in fact
 consists of a quite large collection of automatically generated codelets.
 In fact, we find that alias effects are apparent in all kernels we tried,
 a collection of them shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:fftw-kernels"

\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Img/fft/kernels.eps

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:fftw-kernels"

\end_inset

Cycle and alias counts for four additional kernels, for 8, 15, 20 and 32
 element complex DFTs respectively.
 Plot shows 
\begin_inset Formula $N=200{,}000$
\end_inset

 iterations of the kernel, incrementing stack offset between each run, up
 to 4096 bytes.
 Vertical axis is given in millions.
 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Each kernel shows a different pattern, with clear bias towards some stack
 positions that performs noticably better than others.
\end_layout

\begin_layout Subsection
Ways to Account for Address Alias
\end_layout

\begin_layout Standard
The main problem we faced when trying to do anything about aliasing within
 FFTW itself, was that too many dynamic instructions are added in the process.
 The problem is of course that the hack is implemented inside the hot loop,
 where fftw_execute is called repeatedly.
 However, we can also align stack 
\emph on
before
\emph default
 the loop, adding only a neglegtible overhead.
 The relevant parts of our modified main function is shown in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:fftw-stackfix-main"

\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},language=C,showstringspaces=false"
inline false
status open

\begin_layout Plain Layout

    void *rsp;
\end_layout

\begin_layout Plain Layout

    __asm__ volatile (
\end_layout

\begin_layout Plain Layout

        "movq  %%rsp, %0;"
\end_layout

\begin_layout Plain Layout

        "andq  $-4096, %%rsp;"
\end_layout

\begin_layout Plain Layout

        : "=r"(rsp) : : );
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    for (int i = 0; i < X; ++i)
\end_layout

\begin_layout Plain Layout

        fftw_execute(p);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    __asm__ volatile (
\end_layout

\begin_layout Plain Layout

        "movq   %0, %%rsp;"
\end_layout

\begin_layout Plain Layout

        : : "r"(rsp) : );
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:fftw-stackfix-main"

\end_inset

Modified test program with forced stack alignment in main.
 Stack pointer is saved to a temporary variable before aligned to a 4KiB
 boundary, then restored once we are done.
 Only a couple additional instructions are executed, with a significant
 performance increase on average over all environment sizes.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
With ASLR disabled, keeping the heap addresses constant through all runs,
 we are now able to avoid 
\emph on
all
\emph default
 alias effects for the n1fv_16 kernel.
 If we were to plot the results, the graph for cycle count and alias events
 would be completely flat.
 As shown in Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:fftw-stackfix-main"

\end_inset

, the average cycle count is reduced from 31,051,690 to 30,425,240, a speedup
 of 1.02x.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="5">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Min
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Median
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Mean
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Max
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Default
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
30,337,010
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
30,445,740
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
31,051,690
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
37,349,700
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Modified main
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
30,350,120
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
30,427,600
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
30,425,240
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
30,585,470
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:fftw-stackfix-main"

\end_inset

Cycle count statistics over 512 runs, sampling uniformly over two 4KiB stack
 position periods.
 Notice a significant improvement on average with stack alignment in main.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
There is clearly a potential for speedup of FFTW kernels by accounting for
 aliasing in some way.
 However, requiring users of the library to fiddle with the stack before
 calling fftw_execute is not a satifactory solution.
 A more reasonable approach would be to encorporate these ideas in the steps
 performed 
\emph on
prior
\emph default
 to executing a plan.
 
\end_layout

\begin_layout Subsubsection*
Planning for Alias
\end_layout

\begin_layout Standard
A more realistic solution is to give this responsibility to the 
\emph on
planner
\emph default
.
 Note that the heap addresses are already required when computing a plan.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},language=C"
inline false
status open

\begin_layout Plain Layout

fftw_plan_dft_1d(N, in, out, FFTW_FORWARD, FFTW_ESTIMATE);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As we have shown, the optimal stack position for each kernel depends on
 the memory addresses of input and output arrays.
 
\end_layout

\begin_layout Standard
Note that aliasing is still an issue when using a more thorough planner,
 for example using 
\begin_inset listings
lstparams "basicstyle={\small\ttfamily}"
inline true
status open

\begin_layout Plain Layout

FFTW_MEASURE
\end_layout

\end_inset

.
 FFTW then actually measures the performance for different plans empirically,
 optimizing automatically for the underlying hardware.
 This would cancel out bias if the following were true:
\end_layout

\begin_layout Enumerate
Multiple alternative kernels with varying alias characteristcs exists.
\end_layout

\begin_layout Enumerate
The call chain are the same during benchmarking in the planner as when the
 plan is later executed.
 Stack addresses during planning must be the same.
\end_layout

\begin_layout Standard
The planner can not know the stack depth of which a user calls fftw_execute
 with a given plan, thus simply benchmarking multiple alternative implementation
 to find which one does not suffer from bias will not work.
\end_layout

\begin_layout Standard
Realistic alternative: compiler can generate better assembly that checks
 for alias conflict on O3 and -march=native.
\end_layout

\begin_layout Subsubsection*
Allocating Alias-free
\end_layout

\begin_layout Standard
Even though we did not find any apparent heap-heap conflicts, fftw_malloc
 could help by ?
\end_layout

\begin_layout Section
BLAS
\end_layout

\begin_layout Standard
Find one example of alias (best case: pairwise alignment of heap areas).
 Speculate wildly about cause -- providing motivation for further investigation.
\end_layout

\begin_layout Chapter
Conclusions and Future Work
\end_layout

\begin_layout Standard
Sure this is an easy section.
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
btprint "btPrintAll"
bibfiles "references"
options "bibtotoc,acm"

\end_inset


\end_layout

\begin_layout Chapter
\start_of_appendix
List of Performance Counters
\end_layout

\begin_layout Standard
A collection of hardware performance counters is listed in Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:performance-counters"

\end_inset

.
 A complete reference
\begin_inset Foot
status open

\begin_layout Plain Layout
We suspect that the reference for Ivy Bridge provided by Intel (as of <version>)
 is in fact not complete.
 For instance, no counter concerning the loop stream detector is listed
 in 19-5, but events listed for previous generations seems to work anyway.
\end_layout

\end_inset

 can be found in Volume 3B of the Architectures Software Developer's Manual
 
\begin_inset CommandInset citation
LatexCommand cite
key "Intel:2013:Volume3B"

\end_inset

.
 A handy online reference is also available
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset CommandInset href
LatexCommand href
name "http://software.intel.com/sites/products/documentation/doclib/stdxe/2013/amplifierxe/win/ug_docs/reference/hh_goto.htm#ivb/events/about_events.html"
target "http://software.intel.com/sites/products/documentation/doclib/stdxe/2013/amplifierxe/win/ug_docs/reference/hh_goto.htm#ivb/events/about_events.html"

\end_inset


\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\noindent
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begingroup
\backslash
tabcolsep=3pt
\backslash
begin{small}
\end_layout

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="4">
<features tabularvalignment="middle" tabularwidth="100text%">
<column alignment="center" valignment="top" width="8text%">
<column alignment="center" valignment="top" width="8text%">
<column alignment="left" valignment="top" width="34text%">
<column alignment="left" valignment="top" width="44text%">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Event num.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Umask value
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Event Mask Mnemonic
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Description
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
03H
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
02H
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
LD_BLOCKS.
 STORE_FORWARD
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
07H
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
01H
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
LD_BLOCKS_PARTIAL.
 ADDRESS_ALIAS
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
20H
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
01H
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
LSD_OVERFLOW
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{small}
\backslash
endgroup
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:performance-counters"

\end_inset

Interesting hardware performance counters available on the Intel Core i7
 architecture.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Using perf
\end_layout

\begin_layout Standard
Perf only supports a small subset of counters by mnemonics, such as 
\emph on
cycles
\emph default
, instructions, and 
\emph on
branch-misses
\emph default
.
 To use counters from the manual, simply concatenate Umask value and Event
 num, using only the numeric value.
 To count cycles and LD_BLOCKS_PARTIAL.ADDRESS_ALIAS:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

perf stat -e cycles:u,r0203:u ./a.out
\end_layout

\end_inset


\end_layout

\end_body
\end_document
