#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass report
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman lmodern
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 12
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 2
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Analyzing Context Bias of Program Execution on Modern CPUs
\end_layout

\begin_layout Author
Lars Kirkholt Melhus
\end_layout

\begin_layout Standard
Supervisor: Anne C.
 Elster
\end_layout

\begin_layout Standard
Co-supervisor: Rune E.
 Jensen
\end_layout

\begin_layout Abstract
This is the empty abstract.
 Fin.
 Test citation 
\begin_inset CommandInset citation
LatexCommand cite
key "ProdWrongData,PCDeterministic"

\end_inset


\end_layout

\begin_layout Section*
Problem Description
\end_layout

\begin_layout Standard
Variations in execution context has been shown to affect performance of
 programs on recent CPUs.
 Previous work has looked at offsetting the stack and changing link order
 -- biasing performance measurements towards certain configurations.
 Variables such as the placement of stack, heap and text segments in memory,
 combined with memory access instructions, can impact program performance
 quite significantly.
 
\end_layout

\begin_layout Standard
The goal of this project is to model some of these effects for common use
 cases, and methods for avoiding them, in order to avoiding bias and achieving
 peak performance.
 These effects might be highly platform dependent, so to limit the scope
 we will focus on a particular architecture, the Intel Core i7 "Ivy Bridge".
 Case studies will include small isolated programs, and ideally also "real"
 applications such as FFT algorithms.
\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Chapter
Introduction
\end_layout

\begin_layout Standard
Catchy introduction about the blissful ignorance currently employed by the
 scientific comunity.
 
\end_layout

\begin_layout Section
Observation Effect
\end_layout

\begin_layout Section
Measurement Bias
\end_layout

\begin_layout Standard
Papers exploring measurement bias.
 Fancy graphic of memory layout.
 Conclusion that this is an unsolved problem.
 
\end_layout

\begin_layout Standard
Execution environment
\end_layout

\begin_layout Itemize
Environment variables
\end_layout

\begin_layout Itemize
Link order (affecting static area layout and address of global variables)
\end_layout

\begin_layout Itemize
Page sizeof system
\end_layout

\begin_layout Section
Outline
\end_layout

\begin_layout Standard
The purpose of this report is to explore ways to tackle the effects of measureme
nt bias.
 Previous work has focused mostly on ways to eliminate the effects in order
 to produce reliable measurements -- working towards a more statistically
 valid methodology employed in the computer science community.
 Our approach is slightly different.
 If bias could be controlled in certain situations, we could change program
 or environment to enhance performance -- essentially control the bias to
 work in our favor.
 
\end_layout

\begin_layout Description
Chapter
\begin_inset space ~
\end_inset

2 begins by looking at some of the previous work done.
 Most of this is documenting measurement bias.
\end_layout

\begin_layout Description
Chapter
\begin_inset space ~
\end_inset

3 hopefully contains some actual smart stuff, we'll see :)
\end_layout

\begin_layout Chapter
Background and Related Work
\end_layout

\begin_layout Standard
Background from papers
\end_layout

\begin_layout Section
Performance Counters
\end_layout

\begin_layout Standard
The most powerful tools available for assessing performance on real hardware
 is hardware performance coutners.
\end_layout

\begin_layout Subsection
Accuracy of Performance Counters
\end_layout

\begin_layout Standard
Unfortunately, performance counters are not necessarily accurate or predictable.
 Several papers have looked at the relationship between measured counts
 and the 
\begin_inset Quotes eld
\end_inset

right answer
\begin_inset Quotes erd
\end_inset

.
 For certain metrics it is quite easy to verify wether the reported counts
 are accurate.
 One example is the number of retired instructions, for the perf utility
 reported as instructions:u.
 At least for small programs, we can easily count the number of dynamic
 intructions and compare to reported counts.
 
\end_layout

\begin_layout Subsection
Details from Intel Manual
\end_layout

\begin_layout Standard
The current generations of Intel microarchitectures are called, from earliest
 to newest, Sandy Bridge, Ivy Bridge and Haswell.
 In the official documentation on hardware performance monitoring, Ivy Bridge
 is 
\begin_inset Quotes eld
\end_inset

generally the same
\begin_inset Quotes erd
\end_inset

 as described for Sandy Bridge.
 Ref 18.9 in Part 3B.
 
\end_layout

\begin_layout Standard
Another note: Ivy Bridge is 
\begin_inset Quotes eld
\end_inset

3rd generation Core
\begin_inset Quotes erd
\end_inset

, while Haswell is 
\begin_inset Quotes eld
\end_inset

Next generation
\begin_inset Quotes erd
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sandy/Ivy Bridge
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Number of fixed counters per thread
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Number of general-purpose counters per core
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Number of programmable counters per thread
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4 (8 if a core is not shared by two threads)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
PMU (Performance Monitoring Unit) capabilities for 2nd and 3rd generation
 Intel Core microarchitectures (Sandy Bridge and Ivy Bridge).
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Quote from 18.11.5.2
\end_layout

\begin_layout Quote
The performance-monitoring events listed in Chapter 19, “Performance-Monitoring
 Events,” are intended to be used as guides for performance tuning.
 The counter values reported are not guaranteed to be absolutely accurate
 and should be used as a relative guide for tuning.
 Known discrepancies are documented where applicable.
 
\end_layout

\begin_layout Paragraph
Fixed counters
\end_layout

\begin_layout Standard
Can only count one event (?)
\end_layout

\begin_layout Paragraph*
Generic counters
\end_layout

\begin_layout Standard
Can count any event
\end_layout

\begin_layout Standard
In case there are more events than counters, OS will multiplex and perf
 do scaling (inaccurate).
\end_layout

\begin_layout Paragraph
Software events
\end_layout

\begin_layout Standard
Things like context switches.
 (How is this counted?)
\end_layout

\begin_layout Paragraph
Hardware events
\end_layout

\begin_layout Standard
Cycles
\end_layout

\begin_layout Paragraph
PMI
\end_layout

\begin_layout Standard
Performance Monitor Interrupt
\end_layout

\begin_layout Paragraph
At Retirement Events
\end_layout

\begin_layout Standard
At-retirement counting provides a means counting only events that represent
 work committed to architectural state and ignoring work that was performed
 speculatively and later discarded.
 (Quote from 18.11.6)
\end_layout

\begin_layout Standard
Tagging of micro-operations enables counting at retirement.
 Ex from manual: A micro-op can have several cache-misses during execution.
 Tag to get counted only once.
\end_layout

\begin_layout Subsection
Precise Event Based Sampling (PEBS) 
\end_layout

\begin_layout Standard
Same support as Sandy Bridge, with events listed in Table 18-21.
\end_layout

\begin_layout Standard
Allows PMU to collect architectural state and Instruction Pointer (IP) 
\emph on
after
\emph default
 instruction that caused event is completed.
 Only 
\begin_inset Quotes eld
\end_inset

at-retirement
\begin_inset Quotes erd
\end_inset

 events.
 PEBS buffer can contain all general purpose registers + IP for analyzing
 later.
 Used in V-tune.
\end_layout

\begin_layout Standard
Supported in perfmon2 for some version number > x.
 
\end_layout

\begin_layout Standard
Quote from forum post: http://software.intel.com/en-us/forums/topic/277553
\end_layout

\begin_layout Quote
PEBS (Precise Event Based Sampling) is a feature available to a subset of
 events which allows the hardware to collect additionalinformation very
 close to the exact time the configured event overflowed.
 This presents theanalysis tools whith susbstantially more accurate information
 since the alternative is to wait for a software interrupt to collect this
 information, typically hundreds of cycles later.The additional collected
 information are stored in a special PEBS buffer and retrieved by the tool
 (in this case perf_events) later.
\end_layout

\begin_layout Standard
For use in perf: append :pp to event.
 Needs to be used with perf record.
\end_layout

\begin_layout Section
Intel Microarchitecture
\end_layout

\begin_layout Standard
Information in Intel 64 and IA-32 Architectures Optimization Reference Manual.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
Image of memory system, showing MOB etc.
 Might be useful.
\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Intel Core Microarchitecture
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
MOB
\end_layout

\begin_layout Standard
The Intel architecure enables speculative loads and stores based on predictions.
 Separate buffers are used to provide speculative memory operations, and
 instructions are restarted if conflicts are discovered at retirement.
 
\end_layout

\begin_layout Standard
Memory disambiguation: Information in 2.2.4.5.
 Predicts conflict of loads, issue speculatively.
\end_layout

\begin_layout Subsection
Store Forwarding
\end_layout

\begin_layout Section
Memory in Linux
\end_layout

\begin_layout Standard
ELF format
\end_layout

\begin_layout Standard
Memory map, addresses, layout.
 Stack placement.
 How processes are loaded.
 
\end_layout

\begin_layout Standard
Segments: Look up memory maps of running processes by reading file /proc/<id>/ma
ps.
\end_layout

\begin_layout Standard
Reference: 
\begin_inset Quotes eld
\end_inset

Introduction to x64 Assembly
\begin_inset Quotes erd
\end_inset

.
 Effectively, only 48 out of 64 available bits are used for addressing.
 The lower 0x00000000'00000000 through 0x00007f'ffffffff is addressable
 to user programs, i.e.
 the virtual address space.
 The upper segment of addresses 0xffff80'00000000 through 0xffffffff'ffffffff
 is used by the operating system.
 A process image under Linux consists of several 
\begin_inset Quotes eld
\end_inset

segments
\begin_inset Quotes erd
\end_inset

or areas:
\end_layout

\begin_layout Description
Text Starts at ox40000 ? Lower addresses not used.
 Address 0 needs to be invalid, or there might be confusion with null pointers
 and such.
\end_layout

\begin_layout Description
Data Initialized data
\end_layout

\begin_layout Description
BSS Uninitialized data.
\end_layout

\begin_layout Standard
The stack starts at the high end of addresses, and grows downwards.
 
\end_layout

\begin_layout Chapter
Exploration
\end_layout

\begin_layout Standard
Create a cool performance model, and programs to replicate the effect.
 Suggest empirical solutions.
\end_layout

\begin_layout Section
Partial Address Alias Effects
\end_layout

\begin_layout Standard
An interesting micro-kernel example from the paper 
\begin_inset Quotes eld
\end_inset

Producing Wrong Data Without Doing Anything Obviously Wrong!
\begin_inset Quotes erd
\end_inset

 is shown in Figure 1.
 They show that by adding bytes to the Unix environment, the cycle count
 (when compiled with no optimization flags) periodically increased by about
 33%, and once by almost 300%.
 We tested the same program on the i7 Ivy Bridge and were able to reproduce
 very similar results.
 
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

static int i = 0, j = 0, k = 0;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main() {
\end_layout

\begin_layout Plain Layout

	int g = 0, inc = 1;
\end_layout

\begin_layout Plain Layout

	for (; g < 65536; g++) {
\end_layout

\begin_layout Plain Layout

		i += inc;
\end_layout

\begin_layout Plain Layout

		j += inc;
\end_layout

\begin_layout Plain Layout

		k += inc;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
C code for micro-kernel
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Heap address conflicts
\end_layout

\begin_layout Standard
Dynamic memory allocation can also trigger alias effects.
 Observations:
\end_layout

\begin_layout Standard
Malloc appears to be deterministic, once the ASLR has placed heap start
 address somewhere.
 On x86_64, the heap is typically located around virtual address 0x600000,
 right above program text and data segments (see illustration).
 Some metadata for each allocated area is used to handle free requests etc.
 The pointer returned from malloc seems to be aligned to a single byte,
 meaning returned addresses always end with 0x0.
\end_layout

\begin_layout Standard
For slightly larger requests, malloc uses mmap, which aligns to page size;
 i.e.
 0x1000.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

#define N 0x7ffa // 65536 = 0x10000
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

static int inc = 0;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main(int argc, char **argv)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    int offset  = atoi(argv[1]), i;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    float *a    = malloc(N*sizeof(float));
\end_layout

\begin_layout Plain Layout

    float *fill = malloc(offset*sizeof(float));
\end_layout

\begin_layout Plain Layout

    float *b    = malloc(N*sizeof(float));
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    for (i = 0; i < N; ++i)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        b[i] += inc;
\end_layout

\begin_layout Plain Layout

        b[i]++;
\end_layout

\begin_layout Plain Layout

        b[i]++;
\end_layout

\begin_layout Plain Layout

        b[i]++;
\end_layout

\begin_layout Plain Layout

        b[i]++;
\end_layout

\begin_layout Plain Layout

        a[i]++;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Micro-kernel with a simple loop reading and writing to arrays a and b.
 With the correct input argument, a and b will alias and the cycle count
 noticeably spikes.
 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Internals of malloc
\end_layout

\begin_layout Standard
For the previous example, adding a single byte to the b array, suddently
 malloc will begin using mmap instead of brk after some amount of offset
 (fill array).
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Img/heap-step.svg
	scale 30

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Adding a single float causes mmap to be called after a certain amount of
 offset.
 Very weird.
 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
mmap is a posix system call for mapping a file to contiguous memory.
 Using the ANONYMOUS parameter, memory can be mapped without a backing file.
 malloc uses mmap instead of brk for large allocations -- although the rules
 seems kind of complicated.
\end_layout

\begin_layout Section
Loop Stream Detector
\end_layout

\begin_layout Standard
The Loop Stream Detector (LSD) is a front-end hardware optimization introduced
 in the intel Core microarchitecture.
 Measuring the utilization of LSD is supported by the LSD.UOPS performance
 counter.
 Note that this counter is not listed in Table 19-5.
\end_layout

\begin_layout Standard
The requirements for a loop to fit into the LSD cache is stated in the manual
 as the following:
\end_layout

\begin_layout Itemize
Up to eight chunk fetches of 32 (0x20) instruction-bytes (0x100).
 Online docs for 32 nm i7 states four 16-byte fetches.
\end_layout

\begin_layout Itemize
Up to 28 micro-ops (~28 instructions).
 For Ivy Bridge with HT disabled, each core gets 56 entries in micro-op
 queue.
 
\end_layout

\begin_layout Itemize
All micro-ops are also resident in the Decoded ICache.
\end_layout

\begin_layout Itemize
Can contain no more than eight taken branches and none of them can be a
 CALL or RET.
 Online docs for 32 nm i7 states 4 branches.
\end_layout

\begin_layout Itemize
Cannot have mismatched stack operations.
 For example, more PUSH than POP instructions.
 
\end_layout

\begin_layout Itemize
Loops should have at least 64 iterations.
\end_layout

\begin_layout Subsection
Experiments
\end_layout

\begin_layout Standard
Creating simple loops and compiling with gcc.
 Binary is inspected to check what instructions are executed, and their
 address layout.
 
\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="left" valignment="top" width="60text%">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Comment
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Chunk fetches
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Executed chunks of instruction addresses must fit in at most 12 chunks aligned
 to 0x20 (32 byte).
 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Micro-ops
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
56
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Overflows after 52 addl 0x1 instructions.
 4 extra instructions for text/compare as well, before the jump instruction.
 56 entries seems to be correct for Ivy Bridge as well as Sandy Bridge.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Taken branches
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
17 (+1)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Handles up to 17 branches (+1 for loop) with a single statement 
\begin_inset Quotes eld
\end_inset

a++, b++
\begin_inset Quotes erd
\end_inset

.
 Triggers LSD_OVERFLOW event.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Experimental LSD properties of i7 Ivy Bridge (HT off)
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Chunk Fetches
\end_layout

\begin_layout Standard
The stated limit of 8*32B of instructions is way too much for consecutive
 live loop statements.
 To test this limit we have to space out the executed instructions with
 lots of branches.
 In the following program, the macro expands to 9*3B of mov instructions.
 The cmp and jump instructions generated by the branch makes up another
 5 bytes, making every statement a total of 32B.
 Every branch is not taken -- thus the instructions actually executed in
 each iteration is just the compare and branch.
 
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},showstringspaces=false"
inline false
status open

\begin_layout Plain Layout

#define B27 a = b, a = b, a = b, a = b, 
\backslash

\end_layout

\begin_layout Plain Layout

     a = b, a = b, a = b, a = b, a = b
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int loop()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    register int i = 0, a = 1, b = 1;
\end_layout

\begin_layout Plain Layout

    while (i++ < 0x12345678)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        if (a != b) B27;
\end_layout

\begin_layout Plain Layout

        if (a != b) B27;
\end_layout

\begin_layout Plain Layout

        if (a != b) B27;
\end_layout

\begin_layout Plain Layout

        if (a != b) B27;
\end_layout

\begin_layout Plain Layout

        if (a != b) B27;
\end_layout

\begin_layout Plain Layout

        if (a != b) B27;
\end_layout

\begin_layout Plain Layout

        if (a != b) B27;
\end_layout

\begin_layout Plain Layout

        if (a != b) B27;
\end_layout

\begin_layout Plain Layout

        if (a != b) B27;
\end_layout

\begin_layout Plain Layout

        if (a != b) B27;
\end_layout

\begin_layout Plain Layout

        if (a != b) B27;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    return i;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    loop();
\end_layout

\begin_layout Plain Layout

    return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Loop spanning up to 13 chunks of 32 bytes when compiled with gcc -O0.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Compiling this using gcc and no optimization, we see that the loop stream
 detector is not applied to this loop.
 The address of the first instruction is 0x4004d3, and the last 0x400643.
 If instructions are buffered in chunks of 32B, then chunks must be a multiple
 of 0x20.
 The first instruction is pretty far into the 0x4004
\series bold
c0
\series default
 chunk, while the last instruction is just inside the 0x4006
\series bold
40
\series default
 chunk.
 A total of 13 chunks of 32 bytes is executed -- apparently too much for
 the LSD.
 We use the perf utility to measure total number of un-halted cycles, as
 well as the LSD_OVERFLOW and LSD_UOPS events.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily}"
inline false
status open

\begin_layout Plain Layout

     7,640,342,761 cycles:u                  #    0.000 GHz             
       
\end_layout

\begin_layout Plain Layout

                 0 r0120:u                                             
        
\end_layout

\begin_layout Plain Layout

            10,974 r01a8:u                                             
        
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

       2.249628298 seconds time elapsed
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Observe that by carefully aligning the first instruction, we can fit the
 code into only 12 instruction chunks.
 By inserting 13 nop instruction in the assembly code before the loop, addresses
 of the first and last instructions are offset to, respectively, 0x4004e0
 and 0x400650.
 0xe0 is at the very beginning of a chunk, and 0x50 leaves room for another
 16 bytes (6 of which are occupied by the very last jump instruction).
 Running the same program with these 13 nop instructions results in a dramatic
 improvement in performance.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily}"
inline false
status open

\begin_layout Plain Layout

     3,669,478,538 cycles:u                  #    0.000 GHz             
       
\end_layout

\begin_layout Plain Layout

                 0 r0120:u                                             
        
\end_layout

\begin_layout Plain Layout

     4,579,426,057 r01a8:u                                             
        
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

       1.080381834 seconds time elapsed
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To further strengthen the hypothesis that twelve 32B chunks is the limit,
 we can add another 10 bytes at the very end of the loop and get similar
 results.
 With 11 extra bytes -- spilling instructions over to the next chunk --
 LSD_UOPS is back at 11k.
 
\end_layout

\begin_layout Subsection
Optimization
\end_layout

\begin_layout Standard
\begin_inset Quotes eld
\end_inset

These results are irrelevant, any sensible compiler will fix it when using
 optimizations
\begin_inset Quotes erd
\end_inset

, you might say.
 Interestingly, this is not the case -- with a few modifications we can
 produce the exact same effects on gcc with -O3.
\end_layout

\begin_layout Standard
align-loops option in gcc (which is enabled by default in O2 and O3) does
 in fact align loops -- by inserting 
\begin_inset Quotes eld
\end_inset

.palign x,y,z
\begin_inset Quotes erd
\end_inset

 directives into the assembly.
 In front of the first loop instruction, the following assembly directives
 are printed.
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily}"
inline false
status open

\begin_layout Plain Layout

.p2align 4,,10
\end_layout

\begin_layout Plain Layout

.p2align 3
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The first directive tries to align to four bits, inserting at most 10 bytes
 for padding.
 If that does not work, the next directive forces loops to be aligned to
 three bytes -- meaning addresses ends in 0x0 or 0x8.
 Within a 32B instruction block, the first loop instruction can end up having
 one of the four suffixes 0x00, 0x08, 0x10 or 0x18.
 Using this knowledge, we can construct another example that overflows the
 12 blocks for certain alignment.
 
\end_layout

\begin_layout Standard
\noindent
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "33col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
lsd.c
\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\tiny\ttfamily}"
inline false
status open

\begin_layout Plain Layout

#include <stdio.h>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    int i = loop(10);
\end_layout

\begin_layout Plain Layout

    int f = fact(10);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    printf("Loop: %d
\backslash
n", i);
\end_layout

\begin_layout Plain Layout

    printf("Fact: %d
\backslash
n", f);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "33col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
loop.c
\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\tiny\ttfamily}"
inline false
status open

\begin_layout Plain Layout

#define B22(n) b += i*i*a + 1
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

volatile int i = 42;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int loop(int a)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    register int b = i == 42 ? 1 : 0;
\end_layout

\begin_layout Plain Layout

    do {
\end_layout

\begin_layout Plain Layout

        if (!i) B22(1);
\end_layout

\begin_layout Plain Layout

        if (!i) B22(2);
\end_layout

\begin_layout Plain Layout

        if (!i) B22(3);
\end_layout

\begin_layout Plain Layout

        if (!i) B22(4);
\end_layout

\begin_layout Plain Layout

        if (!i) B22(5);
\end_layout

\begin_layout Plain Layout

        if (!i) B22(6);
\end_layout

\begin_layout Plain Layout

        if (!i) B22(7);
\end_layout

\begin_layout Plain Layout

        if (!i) B22(8);
\end_layout

\begin_layout Plain Layout

        if (!i) B22(9);
\end_layout

\begin_layout Plain Layout

        if (!i) B22(10);
\end_layout

\begin_layout Plain Layout

        if (!i) B22(11);
\end_layout

\begin_layout Plain Layout

   } while (i++ < 0x12345678);
\end_layout

\begin_layout Plain Layout

    return b;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "33col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
fact.c
\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\tiny\ttfamily}"
inline false
status open

\begin_layout Plain Layout

int fact(int n)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    int a = 1;
\end_layout

\begin_layout Plain Layout

    return a;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Compiling these using two different link orders yields the same speedup
 of 2x for the one with fact.c linked before loop.c.
 
\end_layout

\begin_layout Section
Bias effects from trivial source code changes
\end_layout

\begin_layout Standard
If we consider link order to be a possible source of bias, then what about
 other seemingly trivial changes to the program source itself? Keeping in
 mind that alignment and memory address of instructions can have huge impacts
 on performance -- in what ways can this be altered?
\end_layout

\begin_layout Standard
Useful commands for analysing binary files: 
\end_layout

\begin_layout Standard
nm a.out : List symbols
\end_layout

\begin_layout Standard
readelf -a a.out : List ELF info
\end_layout

\begin_layout Standard
objdump -D a.out : Disassemble
\end_layout

\begin_layout Standard
strip a.out : Removes .symtab and .strtab
\end_layout

\begin_layout Paragraph
The order of functions within a source file
\end_layout

\begin_layout Standard
Given a program with functions foo and bar, listing foo before bar and vice
 versa generates two 
\begin_inset Quotes eld
\end_inset

different
\begin_inset Quotes erd
\end_inset

 programs given that equality is based on absolute memory layout.
 Gcc prints functions to the text segment in the order they appear in the
 source code.
\end_layout

\begin_layout Paragraph*
Long function names
\end_layout

\begin_layout Standard
Function names are placed in the .strtab section in the ELF file.
 When running readelf or objdump, the names are used to print nice output.
 The question is: Does .strtab, or any other section, affect program layout
 at execution time?
\end_layout

\begin_layout Description
.interp Interpreter.
 
\begin_inset Quotes eld
\end_inset

/lib64/ld-linux-x86-64.so.2
\begin_inset Quotes erd
\end_inset

 This might vary I guess...
\end_layout

\begin_layout Description
.note.ABI-tag
\end_layout

\begin_layout Description
.note.gnu.build-i
\end_layout

\begin_layout Description
.gnu.hash
\end_layout

\begin_layout Description
.dynsym
\end_layout

\begin_layout Description
.dynstr
\end_layout

\begin_layout Description
.gnu.version
\end_layout

\begin_layout Description
.gnu.version_r
\end_layout

\begin_layout Description
.rela.dyn
\end_layout

\begin_layout Description
.rela.plt
\end_layout

\begin_layout Description
.init
\end_layout

\begin_layout Description
.plt
\end_layout

\begin_layout Description
.text
\end_layout

\begin_layout Description
.fini
\end_layout

\begin_layout Description
.rodata Read-only data ?
\end_layout

\begin_layout Description
.eh_frame_hdr
\end_layout

\begin_layout Description
.eh_frame
\end_layout

\begin_layout Description
.ctors
\end_layout

\begin_layout Description
.dtors
\end_layout

\begin_layout Description
.jcr
\end_layout

\begin_layout Description
.dynamic
\end_layout

\begin_layout Description
.got
\end_layout

\begin_layout Description
.got.plt ?
\end_layout

\begin_layout Description
.data 
\end_layout

\begin_layout Description
.bss Uninitialized data.
 Will be initialized to zero once program is loaded.
 Occupies no space in ELF file.
\end_layout

\begin_layout Description
.comment 
\begin_inset Quotes eld
\end_inset

Version control information
\begin_inset Quotes erd
\end_inset

 from the documentation.
 Contains the compiler version used: 
\begin_inset Quotes eld
\end_inset

GCC: (Ubuntu Linaro 4.6.3-1ubuntu5) 4.6.3
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Description
.shstrtab Section names, such as 
\begin_inset Quotes eld
\end_inset

.text
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

.dtors
\begin_inset Quotes erd
\end_inset

 etc.
 Each section listed in the ELF file contains an index to its name in this
 section.
\end_layout

\begin_layout Description
.symtab ?
\end_layout

\begin_layout Description
.strtab Symbol names used in the source file.
 Function names are placed here.
\end_layout

\begin_layout Chapter
Results
\end_layout

\begin_layout Standard
Graphs illustrating the effect in generated or constructed examples.
 Effects of applying heuristics.
 Ideally some results from applying this to FFT.
\end_layout

\begin_layout Chapter
Conclusions and Future Work
\end_layout

\begin_layout Standard
Sure this is an easy section.
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "references"
options "bibtotoc,plain"

\end_inset


\end_layout

\end_body
\end_document
