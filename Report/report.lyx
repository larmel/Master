#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass report
\begin_preamble
\usepackage{float}
\floatname{algorithm}{Listing}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman lmodern
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 12
\spacing single
\use_hyperref false
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks true
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize a4paper
\use_geometry true
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 2
\paperpagestyle headings
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Analyzing Context Bias on Modern Architectures
\end_layout

\begin_layout Author
Lars Kirkholt Melhus
\end_layout

\begin_layout Date
Supervisor: Anne C.
 Elster
\begin_inset Newline newline
\end_inset

Co-supervisor: Rune E.
 Jensen
\end_layout

\begin_layout Quotation
\begin_inset Quotes eld
\end_inset

None really knows what is happening inside the CPU...
 It follows heisenburg uncertainity principle...
 lol..
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Quotation
k_sarnath - Intel forums.
\end_layout

\begin_layout Abstract
Performance analysis of software is subject to measurement bias.
 Seemingly innocious properties of the environment, such as the location
 of variables in memory, or even room temperature, can impact the performance
 of computer programs.
 Features and restrictions of the underlying hardware introduces performance
 cliffs; on one machine a piece of code might fit within a single cache
 line, while on another the alignment in memory fragments it in two.
 Effects like these have been shown to be significant, but unpredictable
 and difficult to deal with.
\end_layout

\begin_layout Abstract
In this thesis we will study bias effects that can be experienced by changing
 the Unix environment variables, or altering the program link order.
 In effect, both of these leads to different virtual memory layouts, which
 is what actually triggers the performance cliffs.
 Through experimentation and careful measurement using hardware performance
 counters, we identify several potential sources of bias.
 Limitations imposed by the Loop Stream Detector hardware optimization is
 modeled, along with effects from 4K address aliasing.
 We show that environment bias is in fact not completely unpredictable,
 and discuss measures can be made to try to avoid it.
\end_layout

\begin_layout Abstract
Finally, we show that even highly optimized FFT and linear algebra libraries
 are prone to bias.
 
\end_layout

\begin_layout Standard

\lang norsk
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\end_inset


\end_layout

\begin_layout Abstract

\lang norsk
Sammendrag paa norsk
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\end_inset


\end_layout

\begin_layout Section*
Problem Description
\end_layout

\begin_layout Standard
Variations in execution context has been shown to affect performance of
 programs on recent CPUs.
 Previous work has looked at offsetting the stack and changing link order
 -- biasing performance measurements towards certain configurations.
 Variables such as the placement of stack, heap and text segments in memory,
 combined with memory access instructions, can impact program performance
 quite significantly.
 
\end_layout

\begin_layout Standard
The goal of this project is to model some of these effects for common use
 cases, and methods for avoiding them, in order to avoiding bias and achieving
 peak performance.
 These effects might be highly platform dependent, so to limit the scope
 we will focus on a particular architecture, the Intel Core i7 'Ivy Bridge'.
 Case studies will include small isolated programs, and ideally also 
\begin_inset Quotes eld
\end_inset

real
\begin_inset Quotes erd
\end_inset

 applications such as FFT algorithms.
\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Chapter
Introduction
\end_layout

\begin_layout Standard
Analyzing performance is common activity for people in the field of conputer
 science.
 
\end_layout

\begin_layout Standard
This problem is known as measurement bias.
\end_layout

\begin_layout Section
Motivation
\end_layout

\begin_layout Standard
In the paper appropriately named 
\begin_inset Quotes eld
\end_inset

Producing Wrong Data Without Doing Anything Obviously Wrong
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "Mytkowicz:2009:WrongData"

\end_inset

, the authors show how simple changes to the execution environment can heavily
 impact program performance.
 Two variables are studied; size of the Unix environment variables, and
 link order of object files.
 Both are found to be significant with respect to measured performance of
 standardized benchmarks.
 This paper is getting old however, thus it is unclear whether measurement
 bias is an issue on newer CPUs.
 A quick reproduction of one of their tests however, clearly shows that
 measurement bias is still an issue on the -- at the time of writing --
 most recent Intel Core i7 Ivy Bridge architecture.
\end_layout

\begin_layout Standard
\noindent
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "35col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},language=C"
inline false
status open

\begin_layout Plain Layout

static int i, j, k;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main() {
\end_layout

\begin_layout Plain Layout

  int g = 0, inc = 1;
\end_layout

\begin_layout Plain Layout

  for(;g<65536;g++){
\end_layout

\begin_layout Plain Layout

    i += inc;
\end_layout

\begin_layout Plain Layout

    j += inc;
\end_layout

\begin_layout Plain Layout

    k += inc;
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "57col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\noindent
\align right
\begin_inset Graphics
	filename Img/loop/motivation.eps

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:motivation"

\end_inset

A simple C program with significant performance variations under different
 environment sizes.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:motivation"

\end_inset

 shows the micro-kernel presented in 
\begin_inset CommandInset citation
LatexCommand cite
key "Mytkowicz:2009:WrongData"

\end_inset

, together with measurements from our machine.
 The graph shows the number of cycles over a large number of runs, where
 characters are appended to a dummy environment variable between each.
 Cycle counts were measured with hardware performance counters using perf
 to obtain accurate results.
 The program is compiled with GCC
\begin_inset Foot
status open

\begin_layout Plain Layout
GCC, the GNU Compiler Collection.
 
\begin_inset CommandInset href
LatexCommand href
name "http://gcc.gnu.org/"
target "http://gcc.gnu.org/"

\end_inset


\end_layout

\end_inset

 using all default options.
 The code should not appear particularly extraordinary, yet its performance
 characteristics are quite peculiar.
 Even though the exact same binary executable file is run multiple times,
 the performance is clearly not the same for every environment size.
 Measurement bias is still an issue on the most recent architectures, and
 worth investigating.
\end_layout

\begin_layout Section
Outline
\end_layout

\begin_layout Standard
The purpose of this thesis is to explore ways to tackle the effects of measureme
nt bias.
 Previous work has focused mostly on ways to statistically eliminate the
 effects in order to produce reliable measurements -- working towards a
 more statistically valid methodology employed in the computer science community.
 Our approach is slightly different.
 If bias could be controlled in certain situations, we could change program
 or environment to enhance performance -- essentially control the bias to
 work in our favor.
 
\end_layout

\begin_layout Description
Chapter
\begin_inset space ~
\end_inset

2 presents some of the previous work done on measurement bias, showing its
 severity as well as proposed solutions to mitigate or compensate for it.
 A discussion of what actually constitutes the 
\emph on
environment
\emph default
 is discussed.
 
\end_layout

\begin_layout Description
Chapter
\begin_inset space ~
\end_inset

3 investigates various performance metrics acquired from simple programs,
 trying to identify potential 
\emph on
sources
\emph default
 of measurement bias.
 We will focus on two different bias effects; memory address aliasingthe
 first has to with memory address aliasing between variables, that can cause
 problems for the out-of-order scheduling.
 Next we will look at Loop Stream Detector, another hardware optimization
 that sometimes can give bad performance.
\end_layout

\begin_layout Description
Chapter
\begin_inset space ~
\end_inset

4 applies knowledge of bias effects from Chapter 3 in an attempt to speed
 up real-world applications.
 We take an in-depth look at FFTW, a high performance and automatically
 tuned implementation of the fourier transform.
 
\end_layout

\begin_layout Description
Chapter
\begin_inset space ~
\end_inset

5 summarizes results from previous chapters, and provides directions for
 future work.
 
\end_layout

\begin_layout Chapter
Background and Related Work
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "chap:Background"

\end_inset

In this chapter, we begin by presenting some of the previous work done on
 measurement bias in performance analysis.
 An introduction to virtual memory, linking and loading on 64 bit Linux
 architectures is provided as background material -- explaining what we
 mean by the program environment.
 A brief overview of the Intel Core 
\begin_inset Quotes eld
\end_inset

Ivy Bridge
\begin_inset Quotes erd
\end_inset

 architecture is included, introducing performance counters, and highlighting
 some of the features and hardware optimizations that can cause performance
 cliffs.
 
\end_layout

\begin_layout Section
Observer Effect and Measurement Bias
\end_layout

\begin_layout Standard
Several papers dealing with bias in performance analysis have been published.
 Mytkowitcz et.
 al.
 provide an excellent introduction to measurement bias, together with the
 closely related phenomenon of observer effect, in the paper 
\begin_inset Quotes eld
\end_inset

Observer Effect and Measurement Bias in Performance Analysis
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "Mytkowicz:2008:OE&MB"

\end_inset

, and 
\begin_inset Quotes eld
\end_inset

We have it easy, but do we have it right?
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "Mytkowicz:2008:Easy"

\end_inset

.
 The authors draw parallels to the social and natural sciences, scientific
 fields where considerable care is taken to avoid observer effect and bias
 in experimental setups.
 They argue that the methodology currently employed in performance analysis
 for software is lacking, if not flawed.
 In a literature survey, they find that very few authors even considers
 potential effects of bias when evaluating results.
 
\end_layout

\begin_layout Subsubsection*
Observer effect 
\end_layout

\begin_layout Standard
The set of relevant metrics in performance analysis is diverse; a database
 application might be interested in the number of transactions per second,
 while the cycle count and cache misses might be more relevant for a sorting
 algorithm implementation.
 Many low level metrics such as cycle count and cache misses, can be aquired
 with minimal overhead by performance counters in hardware.
 In other cases we might need to add instrumentation to the program being
 measured, for example in the form of counter variables incremented for
 each function call.
 
\end_layout

\begin_layout Standard
Mytkowitcz et al.
 show that both strict use of hardware counters, as well as adding any form
 of software instrumentation, is vulnerable to observer effects.
 Even in standardized benchmark suites such as SPEC 2006, they find that
 change in performance due to observer effect is significant, enough to
 draw invalid conclusions if not properly considered.
\end_layout

\begin_layout Subsubsection*
Measurement bias
\end_layout

\begin_layout Standard
The performance characteristics of software changes not only from observer
 effects, but also from external properties of the experimental setup.
 Two, seemingly innocious, properties of the environment are discussed:
\end_layout

\begin_layout Itemize
Link order of object files: The order of which the .o files are provided
 to the linker, usually more than one valid permutations exist.
\end_layout

\begin_layout Itemize
Shell state, specifically environment variables.
 The content of environment variables on a given system depends on many
 factors, such as the user currently logged in (stored as 
\begin_inset Quotes eld
\end_inset

USER
\begin_inset Quotes erd
\end_inset

 in Linux), or which programs are currently installed, adding directories
 to the 
\begin_inset Quotes eld
\end_inset

PATH
\begin_inset Quotes erd
\end_inset

 variable.
\end_layout

\begin_layout Standard
The authors study how different compiler optimization levels is affected
 by adding characters to environment variables or changing program link
 order.
 Their results show that SPEC benchmarks are sensitive to this as well.
 Different conclusions about O2's efficiency versus O3 can be drawn depending
 on the environment.
\end_layout

\begin_layout Subsection
Causes of Measurement Bias
\end_layout

\begin_layout Standard
In a following paper by the same authors 
\begin_inset CommandInset citation
LatexCommand cite
key "Mytkowicz:2009:WrongData"

\end_inset

, the effects previously presented are reiterated, along with a more detailed
 analysis of measurement bias.
 In addition to pointing out sensitivity in large benchmark programs from
 the SPEC suite, the authors also present a small, isolated C program with
 very high sensitivity to change in environment size.
 We discuss this particular program in the Introduction chapter, showing
 that similar bias effects appear on newer architectures as well.
\end_layout

\begin_layout Standard
For both changing environment variables and link order, the authors point
 to changes to the virtual memory layout being the real cause of bias.
\end_layout

\begin_layout Itemize
Changing environment variables has an effect on where the stack is placed
 in memory at runtime.
 A copy of the environment is loaded into virtual address space before the
 call stack starts, thus increasing the environment size offsets the stack
 start address.
 The authors suggests that altering the stack addresses of variables at
 runtime can have an impact on things like alignment in cache and accuracy
 of branch predictors.
\end_layout

\begin_layout Itemize
Changing link order can change the virtual addresses of instructions.
 Using hardware simulators, the authors show that performance also depends
 on code alignment in memory.
 For instance, when a hot loop fits entirely in a single cache line, the
 number of accesses to instruction cache can be reduced.
 The authors speculate that the 
\begin_inset Quotes eld
\end_inset

Loop Stream Detector
\begin_inset Quotes erd
\end_inset

 might cause bias on the Core 2, a hardware optimization that is supposed
 to speed up instruction fetching of hot loops.
\end_layout

\begin_layout Standard
Dispite demystifying the causes of bias to some degree, this paper provides
 no satisfactory explanation of exactly how or what hardware mechanisms
 causes bias.
 
\end_layout

\begin_layout Subsection
Dealing with Bias
\end_layout

\begin_layout Standard
The conclusion reached in both papers is that measurement bias is unpredictable
 and difficult to avoid.
 Instead, measures have to be made to ensure the results obtained by performance
 analysis are valid.
 The authors provide some guidelines for how to conduct sound experiments:
\end_layout

\begin_layout Itemize
Diversify benchmarks, using statistical methods over a set of diverse benchmarks
 will help cancel out bias.
 
\end_layout

\begin_layout Itemize
Randomize experimental setup, performing multiple measurements under different
 configurations of variables that are known to cause bias.
\end_layout

\begin_layout Standard
In literature survays, the authors find that almost no papers account for
 measurement bias.
 This is problematic, because conclusions reached from running biased experiment
s can easily be misleading, or even outright wrong.
 
\end_layout

\begin_layout Section
Exploiting Bias for Optimization
\end_layout

\begin_layout Standard
So far we have pointed out the problems bias causes for performance analysis.
 A different perspective on bias effects is to look at it as a potential
 for optimization.
 
\end_layout

\begin_layout Subsection
Blind Optimization
\end_layout

\begin_layout Standard
An optimizing compiler needs to have some sort of abstract model of the
 target processor or machine, in order to emit an 
\begin_inset Quotes eld
\end_inset

optimal
\begin_inset Quotes erd
\end_inset

 set of instructions.
 As CPUs become more and more sophisticated, creating a good model for optimizat
ion is difficult.
 Additionally, with bias effects deemed 
\emph on
unpredictable
\emph default
, creating an accurate model becomes impossible.
 In 
\begin_inset Quotes eld
\end_inset

Blind Optimization for Exploiting Hardware Features
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "Knights:2009:BlindOpt"

\end_inset

, the authors takes a different approach to optimization, disregarding the
 model altogether.
 Using automatically generated 
\emph on
program variants
\emph default
, finding an optimal program can be reduced to a searching problem within
 a 
\emph on
variant space
\emph default
.
 
\end_layout

\begin_layout Standard
The authors considers instruction alignment of functions and global variables
 as the variant space.
 New program variants are generated by inserting alignment directives in
 the assembly, changing the memory address of each function or variable
 independently.
 A subset of program variants are generated, and evaluated by measuring
 execution time.
 Using blind optimization, the authors are able to achieve up to 12.6 % speedup
 on some SPEC benchmarks, compared to compiler optimized code.
 
\end_layout

\begin_layout Standard
Blind optimization is really just a variant of a well known concept known
 as Feedback directed optimization 
\begin_inset CommandInset citation
LatexCommand cite
key "Smith:2000:FeedbackDirectedOptimization"

\end_inset

.
 The idea behind this technique is for compilers to use empirical data to
 determine the optimal optimization parameters to apply.
 Parameters are determined through multiple iterations of compiling and
 profiling.
 This is useful for instance in determining the number of loop iterations
 to unroll, different register allocations, and code layout.
 
\end_layout

\begin_layout Subsection
Assembly-Level Optimizations
\end_layout

\begin_layout Standard
Recognizing that current hardware models are lacking, Hundt et al.
 
\begin_inset CommandInset citation
LatexCommand cite
key "Hundt:2011:MAO"

\end_inset

 presents MAO, an 
\begin_inset Quotes eld
\end_inset

Extensible Micro-Architectural Optimizer
\begin_inset Quotes erd
\end_inset

.
 This is an assembly-to-assembly translator, containing architecture-specific
 rules to optimize machine code emitted by the compiler for x86 and x86-64
 architectures.
 Many rules attempt to fix 
\begin_inset Quotes eld
\end_inset

sloppy
\begin_inset Quotes erd
\end_inset

 code generated by GCC (or other compilers), for instance redundant test
 instructions.
 The following example can be shortened by removing the last instruction,
 as condition flags are set implicitly by the sub instruction.
 
\end_layout

\begin_layout Quote
\begin_inset listings
lstparams "basicstyle={\ttfamily},language={[x86masm]Assembler}"
inline false
status open

\begin_layout Plain Layout

sub   16, %rax
\end_layout

\begin_layout Plain Layout

test  %rax, %rax
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Many more of these rules are encoded in MAO, resulting in reduced code size
 and use of more efficient instructions.
 
\end_layout

\begin_layout Standard
In addition to optimizing for the ISA, the code is also tuned for specific
 properties of Intel microarchitectures.
 As an example, MAO considers instruction address alignment for hot loops,
 inserting additional alignment directives if neccessary.
 By aligning frequently executed code segments to 16 byte boundaries, the
 instructions are more likely to fit in decode 
\begin_inset Quotes eld
\end_inset

chunks
\begin_inset Quotes erd
\end_inset

, which are 16 B on the Intel Core 2.
 In previous work on measurement bias by Mytkowitcz et al, the 
\begin_inset Quotes eld
\end_inset

loop stream detector
\begin_inset Quotes erd
\end_inset

 is suggested as a potential cause of bias.
 The authors identifies that this hardware optimization depends on 16 byte
 instruction alignment on the Core 2 architecture.
 MAO uses this knowledge to align code to fit in as few decode chunks as
 possible, allowing the LSD to kick in and avoid instruction fetch for some
 hot loops.
 Another interesting architecture specific optimization considers available
 execution ports in the Core 2 when scheduling instructions.
 
\end_layout

\begin_layout Standard
Inspired by the blind optimization technique introduced by Knights et al.
 
\begin_inset CommandInset citation
LatexCommand cite
key "Knights:2009:BlindOpt"

\end_inset

, MAO attempts to insert 
\family typewriter
nop
\family default
 instructions at random.
 This has the effect of moving surrounding code around, possibly hitting
 
\begin_inset Quotes eld
\end_inset

performance cliffs
\begin_inset Quotes erd
\end_inset

 not modeled or caught by any of the other optimizations.
 
\end_layout

\begin_layout Standard
This paper is particularly interesting because it shows that modeling, and
 successfully optimize for, complex hardware mechanisms is in fact feasible.
 
\end_layout

\begin_layout Section
Hardware and Performance Monitoring
\end_layout

\begin_layout Standard
Bias effects often depend on specific processor features, and 
\begin_inset Quotes eld
\end_inset

performance cliffs
\begin_inset Quotes erd
\end_inset

 caused by them.
 A rudimentary understanding of the underlying hardware is necessary to
 be able to understand why performance varies during different execution
 contexts.
 We limit our study to the Intel Core 
\begin_inset Quotes eld
\end_inset

Ivy Bridge
\begin_inset Quotes erd
\end_inset

, but the architecture borrows many features from previous CPU generations
 as well.
 Of course, a comprehensive introduction to the inner working of any processor
 is way beyond the scope of this thesis.
 Instead, we will provide a brief overview of some architectural features,
 and in particular those that migth cause bias due to differences in virtual
 memory layout.
 
\end_layout

\begin_layout Standard
To gain accurate measurements and diagnostics, we will use hardware performance
 counters.
 The Intel architecture has comprehensive monitoring capabilities, and we
 give a brief overview of how it can be used.
\end_layout

\begin_layout Subsection
\begin_inset Quotes eld
\end_inset

Ivy Bridge
\begin_inset Quotes erd
\end_inset

 Microarchitecture
\end_layout

\begin_layout Standard
The name 
\begin_inset Quotes eld
\end_inset

Ivy Bridge
\begin_inset Quotes erd
\end_inset

 is a code name for what is also referred to as the 
\begin_inset Quotes eld
\end_inset

3rd Generation Intel Core Microarchitecture
\begin_inset Quotes erd
\end_inset

, or alternatively 
\begin_inset Quotes eld
\end_inset

Intel Core Microarchitecture Code Name Ivy Bridge
\begin_inset Quotes erd
\end_inset

.
 These are the terms that are used in the manuals, but we will refer to
 architectures mostly by code name throughout the rest of the thesis.
 Preceeding Ivy Bridge is 
\begin_inset Quotes eld
\end_inset

2nd Generation Intel Core Microarchitecture
\begin_inset Quotes erd
\end_inset

 with code name 
\begin_inset Quotes eld
\end_inset

Sandy Bridge
\begin_inset Quotes erd
\end_inset

.
 Many of the architectural features found in Ivy Bridge can also be found
 in Sandy Bridge and earlier Core architectures.
 
\end_layout

\begin_layout Standard
For our purposes, a general overview and idea of what happens during program
 execution is sufficient.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:pipeline"

\end_inset

 shows a high level view of the processor pipeline, consisting of a front
 end, out of order engine, and execution core component, in addition to
 memory subsystem.
 We will give a brief overview of each component, while a comprehensive
 reference can be found in the vendor manuals 
\begin_inset CommandInset citation
LatexCommand cite
key "Intel:2013:Volume1,Intel:2012:OptimizationManual"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Img/intel/pipeline.eps

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:pipeline"

\end_inset

Ivy Bridge pipeline, adapted from 
\begin_inset CommandInset citation
LatexCommand cite
key "Intel:2012:OptimizationManual"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Front End
\end_layout

\begin_layout Standard
The front end is responsible for fetching and decoding instructions, feeding
 the execution pipeline with a constant stream of micro-operations.
 The branch predictor is used to fetch instructions speculatively, along
 the most likely path of execution.
 
\end_layout

\begin_layout Standard
There is an important distinction between IA-32 or Intel 64
\begin_inset Foot
status open

\begin_layout Plain Layout
Intel uses IA-32 and Intel 64 for what is also commonly known as x86 and
 x86-64 instruction set architectures.
 We will use these terms interchangeably.
\end_layout

\end_inset

 instructions and a micro-operations (
\begin_inset Quotes eld
\end_inset

micro-ops
\begin_inset Quotes erd
\end_inset

): Assembly instructions emitted by a compiler are decoded into micro-operations
 used internally in the processor.
 There are many reasons for this, some of it being the incredible complexity
 of the instruction set.
 Decoding assembly instructions is a costly operation in hardware, and a
 lot of logic in the front end is dedicated to avoid this stage as much
 as possible.
 The Decoded ICache is a cache holding recently executed micro-operations,
 containing up to 1526 entries.
 When the next block of code to execute is determined by the branch predictor,
 the micro-op cache is searched first.
 Intel claims that typical hit rates exceed 80 %, and approaching 100 %
 for hot spots 
\begin_inset CommandInset citation
LatexCommand cite
key "Intel:2012:OptimizationManual"

\end_inset

.
 If not found in the micro-op cache, the 
\begin_inset Quotes eld
\end_inset

legacy
\begin_inset Quotes erd
\end_inset

 fetch-decode pipeline is used.
 New blocks of instruction memory goes through several decode stages, before
 finally being ready to execute as micro-ops.
 To fill 
\begin_inset Quotes eld
\end_inset

holes
\begin_inset Quotes erd
\end_inset

 in the instruction stream, a queue of micro-ops sits between the front
 end and the rest of the pipeline.
 
\end_layout

\begin_layout Paragraph
Macro-Fusion
\end_layout

\begin_layout Standard
To increase the number of instructions that can be executed each cycle,
 pairs of instructions can sometimes be fused by the front-end into one
 equivalent, more complex, operation.
 With macro-fusion, certain pairs of assembly instructions can be combined
 to a single micro-operation.
 This is restricted to pairs where the first instruction modifies condition
 flags (such as 
\family typewriter
test
\family default
 or 
\family typewriter
cmp
\family default
), and the other is a conditional jump.
 Pairs like these appear often in practice, increasing the instructions-per-cycl
e of common code.
 
\end_layout

\begin_layout Paragraph
Loop Stream Detector
\end_layout

\begin_layout Standard
The Loop Stream Detector is, with some restrictions, able to detect software
 loops in the micro-op stream.
 It analyzes micro-ops delivered to the queue, and identifies chains of
 repeatedly executed operations.
 When a loop is detected, the LSD locks the micro-ops in the queue, disabling
 any further ICache lookup as well as the whole decode pipeline.
 Micro-ops are streamed directly from the queue, until a branch mispredict
 causes normal operation to resume.
 This optimization can save power by disabling logic, but also give a performanc
e gain in cases where the front end is a bottleneck.
\end_layout

\begin_layout Subsubsection
Out-of-Order Engine and Execution Core
\end_layout

\begin_layout Standard
One of the key features of modern processors is instruction level parallelism.
 A great amount of logic is dedicated to be able to issue multiple instructions
 per cycle, increasing the throughput.
 The out-of-order engine analyzes dependencies between micro-operations,
 issuing them to the execution core accordingly.
 There are six execution ports, giving a maximum of six micro-operations
 issued by the scheduler each cycle.
 
\end_layout

\begin_layout Subsubsection
Cache Hierarchy
\end_layout

\begin_layout Standard
There are three levels of cache; Each processor core has an L1 data and
 instruction cache of 32 KiB each, and a unified L2 cache of 256 KiB holding
 both data and instructions.
 An L3 cache, also known as last level cache (LLC), is shared among all
 cores via a ring connection.
 
\end_layout

\begin_layout Paragraph
Prefetching
\end_layout

\begin_layout Standard
Prefecthing is used to mask memory latency, by loading data that is soon
 to be accessed into cache.
 Several prefetchers operate on different levels and between different levels
 of cache.
 
\end_layout

\begin_layout Paragraph
Store Forwarding
\end_layout

\begin_layout Standard
A load that happens after a store which is not yet committed, can have the
 store data forwarded directly from the store operations.
\end_layout

\begin_layout Paragraph
Memory Disambiguation
\end_layout

\begin_layout Standard
Loads are scheduled speculatively, even if there are potential conflicts
 with preceeding stores 
\begin_inset CommandInset citation
LatexCommand cite
key "Intel:2006:InsideICM:SmartMemoryAccess,Intel:2006:InsideICM:EnergyEfficientPerformance"

\end_inset

.
 A load coming after a store with unresolved address can potentially have
 a dependency, and must wait until the store is complete.
 With memory disambiguation, the hardware makes a prediction on wether a
 conflict will occur.
 Loads that are predicted not to have any dependencies are allowed to read
 data from L1 cache, before previous stores are resolved.
 The predictions are later verified before retirement, re-executing instructions
 that were affected by actual conflicts.
\end_layout

\begin_layout Standard
Load and store buffers hold the values of speculatively executed memory
 operations, sometimes collectively referred to as 
\begin_inset Quotes eld
\end_inset

Memory Order Buffer
\begin_inset Quotes erd
\end_inset

.
 
\end_layout

\begin_layout Subsection
Performance Counters
\end_layout

\begin_layout Standard
Intel architectures has supported extensive hardware performance monitoring
 for several processor generations.
 Dedicated Performance Monitoring Unit (PMU) hardware can be programmed
 to count various hardware statistics.
 Some examples include cycle count, cache misses, branch mispredicts, and
 number of retired instructions.
 
\end_layout

\begin_layout Standard
\noindent
\begin_inset Float table
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begingroup
\backslash
tabcolsep=3pt
\backslash
begin{small}
\end_layout

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="4">
<features booktabs="true" tabularvalignment="middle" tabularwidth="100text%">
<column alignment="center" valignment="bottom" width="7text%">
<column alignment="center" valignment="bottom" width="10text%">
<column alignment="left" valignment="bottom" width="45text%">
<column alignment="left" valignment="top" width="28text%">
<row>
<cell alignment="center" valignment="bottom" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Event
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="bottom" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Umask
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="bottom" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Mnemonic
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Description
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x3C
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x00
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CPU_CLK_UNHALTED.THREAD_P
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
UnHalted Core Cycles
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
C0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
00
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
INST_RETIRED.ANY_P
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Instruction Retired
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
A2 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
01
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
RESOURCE_STALLS.ANY
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Cycles Allocation is stalled due to resource related reason
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{small}
\backslash
endgroup
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Some performance counters available on Ivy Bridge
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The set of performance counters is divided into two categories; 
\emph on
architectural
\emph default
 counters, which are defined across families of microarchitectures, and
 
\emph on
non-architectural
\emph default
 counters, which are specific for each architecture.
 The official documentation of available performance counters and their
 usage can be found in Volume 3B of the Software Developer's Manual 
\begin_inset CommandInset citation
LatexCommand cite
key "Intel:2013:Volume3B"

\end_inset

.
 Table 19-5 contains all the non-architectural counters supported by Ivy
 Bridge.
 A shorter reference is included in Appendix 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:list-of-performance-counters"

\end_inset

, listing only counters that are relevant to the discussion throughout the
 thesis.
 
\end_layout

\begin_layout Subsubsection
Accuracy of Performance Counters
\end_layout

\begin_layout Subsection
Using 
\family typewriter
perf
\end_layout

\begin_layout Standard
There are multiple ways of accessing the processor's performance monitoring
 facilities from software.
 Support is needed from the operating system, as kernel mode previliges
 are needed to manage the low level PMU hardware.
 Linux systems provide a kernel interface called perf_events, which can
 be used along with the perf
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
perf
\family default
: Linux profiling with performance counters, 
\begin_inset CommandInset href
LatexCommand href
name "https://perf.wiki.kernel.org"
target "https://perf.wiki.kernel.org/index.php/Main_Page"

\end_inset


\end_layout

\end_inset

 tool.
\end_layout

\begin_layout Standard
Perf is a utility program for interfacing performance counters from user
 code on Linux.
 It is included in linux-tools-{version} from the package repository for
 Ubuntu, substituting for the correct kernel version.
 Perf is relatively easy to use, with support for many performance counters
 by mnemonics such as 
\begin_inset Quotes eld
\end_inset

cycles
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

instructions
\begin_inset Quotes erd
\end_inset

, and 
\begin_inset Quotes eld
\end_inset

branch-misses
\begin_inset Quotes erd
\end_inset

.
 We will mostly use the 
\family typewriter
stat
\family default
 command, which takes a list of performance counters and a program to benchmark
 as arguments.
 As an example, the following command reports the total cycle count from
 executing ls (listing files and directories).
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

perf stat -e cycles ls
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As output, we see something like the following.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily}"
inline false
status open

\begin_layout Plain Layout

 Performance counter stats for 'ls':
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

                 0 cycles                    #    0.000 GHz             
       
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

       0.010666675 seconds time elapsed
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Accessing arbitrary counters
\end_layout

\begin_layout Standard
Not all counters are available as mnemonics.
 Arbitrary performance counters can be used by specifying their respective
 
\begin_inset Quotes eld
\end_inset

unit mask
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

event code
\begin_inset Quotes erd
\end_inset

, available in the documentation.
 To get some intuition as to how this works exactly, it is worthwile to
 point out how performance counters are configured under the hood in hardware.
 Counters are set up by writing to special 32 bit model specific registers
 (MSR), Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:msr"

\end_inset

 illustrates the bit field for initializing counters on Ivy Bridge.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Img/intel/msr.eps

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:msr"

\end_inset

Performance event select register.
 Adapted from 
\begin_inset CommandInset citation
LatexCommand cite
key "Intel:2013:Volume3B"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset

In addition to unit mask and event code, the remaining bits can be set to
 impose various constraints on what is counted.
 We will typically toggle OS mode and user mode such that statistics is
 reported from code executing in user mode only.
 
\end_layout

\begin_layout Standard
Perf uses this bit-format fairly explicitly, meaning we can provide a hexadecima
l number corresponding to the desired register value to specify which counter
 to use.
 Let's say we want to count RESOURSE_STALLS.ANY in user mode for ls.
 This corresponds to a bitfield containing 1 for User mode, followed by
 0x01, 0xA2 for unit mask and event code respectively, resulting in the
 number 0x101A2.
 Instead of manually setting the user mode bit, we can append :u to the
 perf code.
 The syntax for invoking perf with this counter becomes
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

perf stat -e r01a2:u ls
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Simply concatenating unit mask and event code and appending a trailing :u
 is what we want to do in most cases.
 There are additional constraints and special cases for various counters.
 Refer to the manual for additional details.
\end_layout

\begin_layout Section
The Execution Context
\end_layout

\begin_layout Standard
The operating system is a vital part of the execution environment.
 Running tests on a particular operating system might very well result in
 big performance differences.
 Because of time limitations we have not considered bias effects due to
 specific variations in OS-es, but rather specific variations within the
 execution context provided by the operating system.
 For all our results, we have used the latest stable release of Ubuntu,
 version 12.04, updated with the latest kernel updates.
\end_layout

\begin_layout Standard
To understand why some of the bias effects occur, it is necessary to understand
 some of the low-level aspects of how processes and memory is managed by
 the operating system.
 In particular, we will see that changes to memory layout in virtual address
 space can lead to performance variations.
 
\end_layout

\begin_layout Subsection
Object Files
\end_layout

\begin_layout Subsection
Virtual Memory
\end_layout

\begin_layout Standard
Before a program can be run, it needs to be loaded into memory in some way.
 The ELF file includes the path to an interpreter, a program that is responsible
 for loading code and data, setting up a stack, and loading any dependencies.
 Files compiled for execution on a 64 bit Linux platform will point to a
 loader in 
\family typewriter
/lib64/ld-linux-x86-64.so.2
\family default
.
 This file can be a symbolic link to the actual program.
 The loader then places each 
\emph on
allocable
\emph default
 section of the object file in virtual address space.
 The most important sections include the stack, heap, bss, data and text,
 as shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:virtual-address-space"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Img/unix-vm-all.eps

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:virtual-address-space"

\end_inset

Organization of virtual memory on a typical 64 bit Linux system.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Effectively, only 48 out of 64 available bits are used for addressing.
 The lower 
\family typewriter
0x0
\family default
 through 
\family typewriter
0x7fff'ffffffff
\family default
 is addressable to user programs.
 The upper segment of addresses 
\family typewriter
0xffff8000'00000000
\family default
 through 
\family typewriter
0xffffffff'ffffffff
\family default
 is reserved for the operating system .
 Note that this leaves a large 
\begin_inset Quotes eld
\end_inset

hole
\begin_inset Quotes erd
\end_inset

 of unused addresses, as current hardware does not support addressing the
 whole 64 bit range 
\begin_inset CommandInset citation
LatexCommand cite
key "Lomont:2012:x64Assembly"

\end_inset

.
\end_layout

\begin_layout Standard
A running process is divided into several sections within the virtual address
 space:
\end_layout

\begin_layout Description
stack Stack frames with parameters and local variables for function calls.
 Allocated starting somewhere around the top address 
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

0x007fff'ffffffff
\end_layout

\end_inset

 and expanding downwards.
 
\end_layout

\begin_layout Description
heap Dynamically allocated memory, allocated above the text and data segments
 and growing upwards as programs request more memory.
 The start of heap is marked by 'brk'.
 A Linux system call to brk will request more memory, extending the current
 limit.
 
\end_layout

\begin_layout Description
bss Uninitialized data.
 This segment occupies no space in the object file, only the size is needed.
 Everything is initialized to zero.
 
\end_layout

\begin_layout Description
data Initialized data, variables that have some assigned value at compile
 time.
 
\end_layout

\begin_layout Description
text Executable binary code.
 This segment is placed at the lower end of virtual address space.
 
\end_layout

\begin_layout Standard
Dynamically loaded libraries are mapped into virtual memory as well.
 They typically end up with high addresses, located relatively close to
 the stack.
 
\end_layout

\begin_layout Subsubsection*
Address Space Layout Randomization (ASLR)
\end_layout

\begin_layout Standard
The process of loading segments to virtual memory is not necessarily determinist
ic.
 If virtual addresses can be known a priori, programs will be more vulnerable
 to buffer overflow attacks 
\begin_inset CommandInset citation
LatexCommand cite
key "Shackham:2004:ASLR"

\end_inset

.
 If an attacker manages to inject malicous code, he can use the known virtual
 addresses to access data or call any function.
 One technique known as 'return to libc' attacks uses this knowledge to
 call functions in the C standard library, which will be loaded in most
 scenarios.
\end_layout

\begin_layout Standard
Address space randomization is a technique employed by the operating system
 to make it more difficult to compromise programs.
 By default, the placement of stack, heap (initial position of brk) and
 location of dynamically linked libraries will vary between each run of
 a program.
 For a controlled execution environment we will need to manually disable
 address randomization in many cases.
 This is done by overwriting the randomize_va_space file.
 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=bash"
inline false
status open

\begin_layout Plain Layout

bash -c 'echo 0 > /proc/sys/kernel/randomize_va_space'
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The default value is 2, indicating full randomization.
 For randomizing only (??), a value of 1 can be written instead.
 We will use zero to disable all randomization, making virtual memory layout
 completely deterministic between each run.
\end_layout

\begin_layout Subsubsection*
Environment Variables
\end_layout

\begin_layout Standard
As discussed in previous work on measurement bias 
\begin_inset CommandInset citation
LatexCommand cite
key "Mytkowicz:2009:WrongData"

\end_inset

, the size of a user's Unix environment variable can affect the placement
 of stack.
 Environment variables are allocated above the stack, pushing the first
 possible stack starting address downwards.
 With ASLR disabled, the initial stack address can be manipulated by manually
 changing environment variables.
\end_layout

\begin_layout Subsection
Memory Context of C Programs
\end_layout

\begin_layout Standard
Recognizing that the location of variables in virtual memory is significant,
 it is useful to have an idea of where data might end up in actual programs.
 The program in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:c-context"

\end_inset

 contains four variables, utilizing both initialized and unitialized data,
 as well as dynamically allocated data on heap and automatic stack allocated
 variables.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},language=C,showstringspaces=false"
inline false
status open

\begin_layout Plain Layout

static int a;      // .bss
\end_layout

\begin_layout Plain Layout

static int b = 42; // .data
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main() {
\end_layout

\begin_layout Plain Layout

    int c = 0; // .stack
\end_layout

\begin_layout Plain Layout

    int *d = malloc(sizeof(int)); // .heap
\end_layout

\begin_layout Plain Layout

    printf("stack: %p
\backslash
nheap: %p
\backslash
nbss: %p
\backslash
ndata: %p
\backslash
n", &c, d, &a, &b);
\end_layout

\begin_layout Plain Layout

    return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:c-context"

\end_inset

Simple C program with data allocated in four different segments of virtual
 memory
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Variable c and d are 
\emph on
automatic
\emph default
 variables
\begin_inset CommandInset citation
LatexCommand cite
key "Kernighan:1988:CProgrammingLanguage"

\end_inset

, which are stack allocated.
 Their run-time address depends on where the stack segment is initialized
 in virtual memory, and can in general not be known ahead of time.
\end_layout

\begin_layout Itemize
The address returned by malloc and stored in variable d points to a location
 on the heap.
 The exact address depends on the implementation of malloc, as well as the
 initial position of the heap segment, and is also impossible to predict
 in general.
 
\end_layout

\begin_layout Itemize
Global variables a and b should be placed in bss and data segments respectively.
 Their virtual addresses are determined at compile time, and can be found
 in the ELF object file's symbol table 
\begin_inset CommandInset citation
LatexCommand cite
key "SystemVABI"

\end_inset

.
 
\end_layout

\begin_layout Standard
Executing the same program multiple times with ASLR enabled will yield different
 output for stack and heap addresses.
 Each variation constitutes a different execution context, with potentially
 different performance characteristics.
\end_layout

\begin_layout Standard
The actual memory map from running processes can be obtained by reading
 the file 
\family typewriter
/proc/$id/maps
\family default
 for some process id.
 A sample output from a run of the previous hello world example is shown
 below.
 Recognize [stack] located on high address, and [heap]
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\scriptsize\ttfamily}"
inline false
status open

\begin_layout Plain Layout

00400000-00401000 r-xp 00000000 08:01 161842             /home/lars/Master/Code/
Env/a.out
\end_layout

\begin_layout Plain Layout

00600000-00601000 r--p 00000000 08:01 161842             /home/lars/Master/Code/
Env/a.out
\end_layout

\begin_layout Plain Layout

00601000-00602000 rw-p 00001000 08:01 161842             /home/lars/Master/Code/
Env/a.out
\end_layout

\begin_layout Plain Layout

01027000-01048000 rw-p 00000000 00:00 0                  [heap]
\end_layout

\begin_layout Plain Layout

7f127e493000-7f127e646000 r-xp 00000000 08:01 266366     /lib/x86_64-linux-gnu/l
ibc-2.15.so
\end_layout

\begin_layout Plain Layout

7f127e646000-7f127e845000 ---p 001b3000 08:01 266366     /lib/x86_64-linux-gnu/l
ibc-2.15.so
\end_layout

\begin_layout Plain Layout

7f127e845000-7f127e849000 r--p 001b2000 08:01 266366     /lib/x86_64-linux-gnu/l
ibc-2.15.so
\end_layout

\begin_layout Plain Layout

7f127e849000-7f127e84b000 rw-p 001b6000 08:01 266366     /lib/x86_64-linux-gnu/l
ibc-2.15.so
\end_layout

\begin_layout Plain Layout

7f127e84b000-7f127e850000 rw-p 00000000 00:00 0 
\end_layout

\begin_layout Plain Layout

7f127e850000-7f127e872000 r-xp 00000000 08:01 266346     /lib/x86_64-linux-gnu/l
d-2.15.so
\end_layout

\begin_layout Plain Layout

7f127ea59000-7f127ea5c000 rw-p 00000000 00:00 0 
\end_layout

\begin_layout Plain Layout

7f127ea6f000-7f127ea72000 rw-p 00000000 00:00 0 
\end_layout

\begin_layout Plain Layout

7f127ea72000-7f127ea73000 r--p 00022000 08:01 266346     /lib/x86_64-linux-gnu/l
d-2.15.so
\end_layout

\begin_layout Plain Layout

7f127ea73000-7f127ea75000 rw-p 00023000 08:01 266346     /lib/x86_64-linux-gnu/l
d-2.15.so
\end_layout

\begin_layout Plain Layout

7fff47114000-7fff47135000 rw-p 00000000 00:00 0          [stack]
\end_layout

\begin_layout Plain Layout

7fff471ff000-7fff47200000 r-xp 00000000 00:00 0          [vdso]
\end_layout

\begin_layout Plain Layout

ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0  [vsyscall]
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Sources of Measurement Bias
\end_layout

\begin_layout Standard
Modern microprocessors are extremely complex in design and functionality.
 Some features of recent Intel processors includes several layers of cache
 to camouflage slow memory, multiple prefetchers, speculative out-of-order
 execution and complicated branch prediction, just to name a few.
 Optimizing for the common case, these hardware features sometimes behaves
 suboptimally, resulting in bias observed by performance analysts.
 In this chapter, we will unveil characteristics about two specific architectura
l features in Ivy Bridge, and show how they can bias performance towards
 certain memory layouts.
 
\end_layout

\begin_layout Section
Methodology and Experimental Setup
\end_layout

\begin_layout Standard
Measurement bias is by definition a product of variations in the environment.
 To produce reliable results, we need to properly control every variable
 that can affect mearurements.
 We make the following configuration to our experimental setup:
\end_layout

\begin_layout Itemize
Unless specified otherwise, address space layout randomization (ASLR) is
 kept disabled.
 This is necessary when testing effects from changing memory context, and
 often required to make results reproducible.
\end_layout

\begin_layout Itemize
Hyper threading is disabled, ensuring that only one thread runs simultaneously
 on each core.
 Two threads competing on hardware resources is another potential source
 of bias, which we will not be studying.
 
\end_layout

\begin_layout Itemize
System load is kept at a minimum to avoid interference with other processes
 and tasks.
 
\end_layout

\begin_layout Itemize
Automatic CPU frequency scaling is disabled, keeping the clock speed constant.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Processor
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Intel® Core™ i7-3770 @ 3.40GHz
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Memory
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16 GB
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Operating System
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
64bit Ubuntu 12.04 LTS (3.2.0-41)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Toolchain
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
GCC 4.6.3
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Experimental Setup
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
We use 
\family typewriter
perf stat
\family default
 to aquire hardware performance counter statistics, which should introduce
 minimal overhead and observer effect.
 Plots are generated using Python's matplotlib 
\begin_inset CommandInset citation
LatexCommand cite
key "Hunter:2007"

\end_inset

.
\end_layout

\begin_layout Section
Address Alias Effects (4K Aliasing)
\end_layout

\begin_layout Standard
Placement of code and data in virtual memory affect the performance of programs
 in various ways.
 In this section, we will look at a phenomenon related to the addresses
 of read and write operations.
 Effects known as 
\begin_inset Quotes eld
\end_inset

4K aliasing
\begin_inset Quotes erd
\end_inset

 occurs when the addresses of a store followed by a load differ by a multiple
 of 4 KiB.
 Consider the following example, first writing a value to the memory address
 stored in %rax, before reading from the address stored in %rbx
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily}"
inline false
status open

\begin_layout Plain Layout

mov %r10, (%rax)
\end_layout

\begin_layout Plain Layout

mov (%rbx), %r11
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If for example %rax is 0x601010 and %rbx is 0x604010, the memory accesses
 are said to be aliased.
 The difference between the two addresses is 0x3000, which is a multiple
 of 4096, or 0x1000 in hexadecimal.
 
\end_layout

\begin_layout Standard
The memory system issues load and store operations speculatively and out
 of order to increase throughput and parallelism.
 Some analysis is done to determine which operations are safe to issue out
 of order.
 In the above example, the processor could very well issue the load before
 the store, as they refer to different addresses.
 However, on recent Intel architectures only the last 12 address bits are
 used to determine if operations refer to the same address.
 The last twelve bits of 0x601010 is 0x010, or 0000'0001'0000 in binary
 -- the same as for 0x604
\series bold
010
\series default
.
 Only doing a partial address compare, dependencies between load and store
 operations are sometimes falsely detected.
 Issues with 4K aliasing have existed for many generations of micro-architecture
s, and discussed on several occations in the optimization manual 
\begin_inset CommandInset citation
LatexCommand cite
key "Intel:2012:OptimizationManual"

\end_inset

.
 The following quote is listed under section 3.6.8.2; 
\begin_inset Quotes eld
\end_inset

Alias Cases in the Pentium M, Intel Core Solo, Intel Core Duo and Intel
 Core 2 Duo Processors
\begin_inset Quotes erd
\end_inset

;
\end_layout

\begin_layout Quote
\begin_inset Quotes eld
\end_inset

Store forwarding -- If a store to an address is followed by a load from
 the same address, the load will not proceed until the store data is available.
 If a store is followed by a load and their addresses differ by a multiple
 of 4 KBytes, the load stalls until the store operation completes
\begin_inset Quotes erd
\end_inset

 
\end_layout

\begin_layout Standard
In earlier architectures, effects of 4K aliasing emerge as a case of failed
 store forwarding.
 The performance counter LOAD_BLOCK.OVERLAP_STORE counts instances where
 forwarding is blocked due to various reasons, including false dependency
 from address aliasing.
 Interestingly, there is no counter by that name (or event code) listed
 for Ivy Bridge.
 There is however, one performance counter that reports alias events only
 
\begin_inset CommandInset citation
LatexCommand cite
key "Intel:2013:Volume3B"

\end_inset

.
 
\end_layout

\begin_layout Description
LD_BLOCKS_PARTIAL.ADDRESS_ALIAS False dependency in the Memory Order Buffer
\end_layout

\begin_layout Standard
The 
\begin_inset Quotes eld
\end_inset

Memory Order Buffer
\begin_inset Quotes erd
\end_inset

 refers to a collection of read/write buffers within the L1 data cache.
 It buffers loads and stores of not yet retired instructions, enabling speculati
ve and out-of-order execution while ensuring that no dependencies are violated
 
\begin_inset CommandInset citation
LatexCommand cite
key "Doweck:InsideIntelCoreMicroarchitecture,Intel:2012:OptimizationManual"

\end_inset

.
 The optimization manual provides a more to-the-point explanation of the
 counter, stating it 
\begin_inset Quotes eld
\end_inset

Counts the number of loads that have partial address match with preceding
 stores, causing the load to be reissued.
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
False dependencies due to address aliasing can have a negative effect on
 processor performance.
 Through a series of examples, we show that bias effects due to address
 aliasing is both common and significant.
 
\end_layout

\begin_layout Subsection
Bias from Stack Alignment
\end_layout

\begin_layout Standard
As shown in previous work, changing the Unix environment variables can sometimes
 significantly affect program performance.
 It is typically not the content of environment variables that are important,
 but rather the effect their size has on stack position.
 Environment variables are allocated before the stack when programs are
 mapped into virtual memory, essentially offseting all the following call
 frames and stack allocated variables.
 
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},language=C"
inline false
status open

\begin_layout Plain Layout

static int i, j, k;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main() {
\end_layout

\begin_layout Plain Layout

    int g = 0, inc = 1;
\end_layout

\begin_layout Plain Layout

    for (; g < 65536; g++) {
\end_layout

\begin_layout Plain Layout

        i += inc;
\end_layout

\begin_layout Plain Layout

        j += inc;
\end_layout

\begin_layout Plain Layout

        k += inc;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:loop-micro-kernel"

\end_inset

C code with bias towards certain stack positions
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
We begin by showing how address aliasing can explain measurement bias for
 the micro kernel presented in 
\begin_inset CommandInset citation
LatexCommand cite
key "Mytkowicz:2009:WrongData"

\end_inset

, reproduced here in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:loop-micro-kernel"

\end_inset

.
 This example is interesting for several reasons:
\end_layout

\begin_layout Itemize
The bias effects are significant and easily reproducible
\end_layout

\begin_layout Itemize
The example code is simple and easy to analyze
\end_layout

\begin_layout Itemize
No satisfactory explanaition as to what causes bias was given in the original
 paper
\end_layout

\begin_layout Standard
We use perf and an automated script to collect performance counter statistics
 over a series of runs, with increasing environment size using a dummy variable
 between each execution.
 The program is compiled using GCC with all default options.
 Note that any optimization would likely disregard most of the function
 as redundant code, and reduce it to return zero immediately.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Img/loop/cycles.eps

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:loop-cycles-only"

\end_inset

Performance variations from offseting stack position by changing environment
 size
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Collecting the cycle count performance counter, we observe a distinct spike
 over a period of 16 (verify!) bytes under increasing environment size.
 As illustrated in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:loop-cycles-only"

\end_inset

, the difference is over 20 % between the worst and best case.
 
\end_layout

\begin_layout Standard
Even for such a simple program, it is far from obvious that stack position
 should have any impact on performance.
 As a starting point in trying to analyze the potential cause for these
 effects, we will look at data provided by various performance counters.
 With nearly 200 non-architectural performance counters available for Ivy
 Bridge, hopefully some of them can give some insight into what is happening.
 The set of counters that most closely follows the cycle count is shown
 in Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:loop-all-counters"

\end_inset

.
 We have used a simple linear correlation to filter out the metrics that
 most closely follows the cycle count.
 
\end_layout

\begin_layout Standard
\begin_inset Float table
placement t
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{small}
\end_layout

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="14" columns="3">
<features booktabs="true" tabularvalignment="middle" tabularwidth="100text%">
<column alignment="left" valignment="top" width="60text%">
<column alignment="center" valignment="top" width="0">
<column alignment="decimal" decimal_point="." valignment="top" width="0">
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Performance Counter
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Perf code
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Correlation
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
UnHalted Core Cycles
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
cycles:u
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
UnHalted Reference Cycles
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
bus-cycles:u
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0.9999957522
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
LD_BLOCKS_PARTIAL.ADDRESS_ALIAS
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
r0107:u
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0.9941211321
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
RESOURCE_STALLS.ANY
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
r01a2:u
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0.9922818774
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
CYCLE_ACTIVITY.CYCLES_LDM_PENDING
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
r02a3:u
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0.9879579406
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
CPL_CYCLES.RING123
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
r025c:u
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0.9844339013
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
CYCLE_ACTIVITY.CYCLES_NO_EXECUTE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
r04a3:u
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0.9200557425
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
UOPS_DISPATCHED_PORT.PORT_4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
r40a1:u
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0.7546588979
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
UOPS_DISPATCHED_PORT.PORT_5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
r80a1:u
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
-0.5346383723
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
UOPS_DISPATCHED_PORT.PORT_1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
r02a1:u
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
-0.9308766294
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
UOPS_DISPATCHED_PORT.PORT_0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
r01a1:u
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
-0.9707469127
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
RESOURCE_STALLS.RS
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
r04a2:u
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
-0.986720269
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{small}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:loop-all-counters"

\end_inset

Performance counters with more than 30% positive or negative correlation
 to cycle count
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Among all the performance counters supported on our architecture, only a
 few shows significant correlation to cycle count in this case.
 Other interesting counters include resource stalls and loads pending, both
 strongly correlating to cycle count.
 When presenting similar results for the Core 2, the authors mentions the
 performance counter LOAD_BLOCK.OVERLAP_STORE as a potential explanation.
 As mentioned, there is no counter by that name for the Ivy Bridge 
\begin_inset CommandInset citation
LatexCommand cite
key "Intel:2013:Volume3B"

\end_inset

.
 One that seems close in description is LD_BLOCKS.STORE_FORWARD, which counts
 the number of times loads are blocked by overlapping stores.
 Interestingly, this counter does not correlate with cycle count in our
 case.
 Instead we are looking at 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
LD_BLOCKS_PARTIAL.ADDRESS_ALIAS as the most likely indication of what happens.
 Plotting this counter, we see that it reports zero almost everywhere, and
 spiking in perfect correlation with cycle count.

\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 It appears that a read/write dependency is falsely detected, causing the
 pipeline to wait for previous memory operations to complete.
 A higher amount of resource stalls and pending loads seems like a natural
 consequence of stalling due to aliasing.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Img/loop/correlation.eps

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Cycle count correlating with resource stalls, pending memory loads and address
 alias performance counter events.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
To find out which memory accesses collide, we need to know the memory addresses
 of each variable at run time.
 
\end_layout

\begin_layout Subsubsection*
Static variables
\end_layout

\begin_layout Standard
Variables i, j and k are declared as 
\family typewriter
static
\family default
 in C, meaning they have a static storage class.
 Statically allocated variables have their virtual addresses determined
 at compile time, and are not affected by offseting stack address.
 Inspecting the symbol table section of the ELF object file
\begin_inset Foot
status open

\begin_layout Plain Layout
Output is generated using the readelf utility, part of GNU Binary Utilities
\end_layout

\end_inset

, reveals that the addresses of i, j and k are 
\family typewriter
0x601028
\family default
, 
\family typewriter
0x60102c
\family default
 and 
\family typewriter
0x601030
\family default
, respectively.
 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily}"
inline false
status open

\begin_layout Plain Layout

Symbol table '.symtab' contains 66 entries:
\end_layout

\begin_layout Plain Layout

   Num:    Value          Size Type    Bind   Vis      Ndx Name
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    42: 0000000000601028     4 OBJECT  LOCAL  DEFAULT   25 i
\end_layout

\begin_layout Plain Layout

    43: 000000000060102c     4 OBJECT  LOCAL  DEFAULT   25 j
\end_layout

\begin_layout Plain Layout

    44: 0000000000601030     4 OBJECT  LOCAL  DEFAULT   25 k
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Automatic variables
\end_layout

\begin_layout Standard
Variables g and inc are local automatic variables, which are allocated on
 stack.
 The addresses of these variables will be affected by changing initial stack
 position.
 However, it is very difficult to observe the correct addresses of g and
 inc without introducing observer effects.
 Simply adding a call to printf for instance, completely changes the program
 behaviour with repect to bias.
 Insted, we use a small amount of assembly code to calculate the addresses
 and print the numbers directly using system calls.
 
\end_layout

\begin_layout Standard
We find that the spike in cycle count occurs when the stack allocated variables
 have the following addresses:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily}"
inline false
status open

\begin_layout Plain Layout

 g   :   0x7fffffffe028
\end_layout

\begin_layout Plain Layout

 inc :   0x7fffffffe02c
\end_layout

\end_inset

Note that the last twelve bits (three hexadecimal digits) for 
\family typewriter
g
\family default
 and 
\family typewriter
inc
\family default
 are the same as 
\family typewriter
i
\family default
 and 
\family typewriter
j
\family default
.
\end_layout

\begin_layout Subsubsection
Run-time Solutions to Address Aliasing
\end_layout

\begin_layout Standard
Sddresses of automatic variables can not be determined statically, because
 the position of stack is unknown.
 In addition to being offset by environment variables, the stack address
 can also be perturbed by other factors such as address layout randomization.
 Although we can not easily know 
\emph on
if
\emph default
 a collision is going to happen for a given environment, we can try to change
 the program to account for possible alias effects.
 As a proof of concept, consider the following strategy.
\end_layout

\begin_layout Enumerate
Pointer addresses can be accessed in C, thus we can read out the addresses
 to check if there are any collisions between (
\family typewriter
g
\family default
, 
\family typewriter
i
\family default
) and (
\family typewriter
inc
\family default
, 
\family typewriter
j
\family default
).
\end_layout

\begin_layout Enumerate
If the addresses do alias, branch to an alternative but semantically equivalent
 code path.
 Allocate a new set of variables to avoid aliasing.
\end_layout

\begin_layout Standard
A complete implementation is shown in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:loop-micro-kernel-fixed"

\end_inset

.
 Note that only one pair of variables needs to be checked in this case,
 as both static and stack variables are allocated consecutively.
 If inc and j alias (which is checked), then g and i will alias as well.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement t
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},language=C"
inline false
status open

\begin_layout Plain Layout

static int i, j, k;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main() {
\end_layout

\begin_layout Plain Layout

    int g = 0, inc = 1;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    if ((((long)&inc) & 0xfff) == (((long)&j) & 0xfff)) {
\end_layout

\begin_layout Plain Layout

        int dummy = 0, t1 = g, t2 = inc;
\end_layout

\begin_layout Plain Layout

        for (; t1 < 65536; t1++) {
\end_layout

\begin_layout Plain Layout

            i += t2;
\end_layout

\begin_layout Plain Layout

            j += t2;
\end_layout

\begin_layout Plain Layout

            k += t2;
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        g = t1;
\end_layout

\begin_layout Plain Layout

        goto skip;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    for (; g < 65536; g++) {
\end_layout

\begin_layout Plain Layout

        i += inc;
\end_layout

\begin_layout Plain Layout

        j += inc;
\end_layout

\begin_layout Plain Layout

        k += inc;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

skip:
\end_layout

\begin_layout Plain Layout

    return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:loop-micro-kernel-fixed"

\end_inset

Modified code with explicit check for aliasing between inc and j.
 The alternative loop contains no aliasing.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Running the same set of tests again, we are now able to remove all aliasing
 from this particular program.
 In most cases, assuming a uniform random distrubution of initial stack
 addresses, the program performs slighly worse because of the additional
 overhead and extra instructions executed.
 On average over all initial stack positions however, adding this check
 yields a speedup.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Img/loop/fixed.eps

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
No change to performance based on environment size using the modified code
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Bias from Dynamic Memory
\end_layout

\begin_layout Standard
There are roughly speaking three areas of memory
\end_layout

\begin_layout Description
Stack Holding function parameters and local automatic variables
\end_layout

\begin_layout Description
Heap Dynamically allocated memory at runtime
\end_layout

\begin_layout Description
Static Data contained within the compiled binary
\end_layout

\begin_layout Standard
In the previous example, we saw aliasing between stack variables and static
 data.
 
\end_layout

\begin_layout Subsection
Heap address conflicts
\end_layout

\begin_layout Standard
Consider the following function, computing the convolution between an input
 array and a fixed kernel, disregarding endpoints for simplicity.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},language=C"
inline false
status open

\begin_layout Plain Layout

static float kernel[5] = {0.1, 0.25, 0.3, 0.25, 0.1};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void convolve(int size, float *input, float *output)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    int i, j;
\end_layout

\begin_layout Plain Layout

    for (i = 2; i < size - 2; ++i)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        output[i] = 0;
\end_layout

\begin_layout Plain Layout

        for (j = 0; j < 5; ++j)
\end_layout

\begin_layout Plain Layout

            output[i] += input[i-2+j] * kernel[j];
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Convolution kernel
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
We use malloc to allocate two reasonably sized arrays for input and output,
 skipping initialization before calling convolve to save some cycles.
 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},language=C"
inline false
status open

\begin_layout Plain Layout

    float *input  = malloc(N*sizeof(float));
\end_layout

\begin_layout Plain Layout

    float *result = malloc(N*sizeof(float));
\end_layout

\begin_layout Plain Layout

    convolve(N, input, result);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The program is compiled with GCC and optimization O3.
 Output from perf is shown below, measuring number of cycles, address alias,
 resource stalls and number of instructions.
 A large number of alias events and resource stalls are generated.
 Considering this is compiled with the highest optimization level, the instructi
on per cycle metric is not very impressive either.
 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily}"
inline false
status open

\begin_layout Plain Layout

        12,391,475 cycles:u
\end_layout

\begin_layout Plain Layout

         9,039,041 r0107:u
\end_layout

\begin_layout Plain Layout

         7,931,308 r01a2:u
\end_layout

\begin_layout Plain Layout

        11,163,873 instructions:u
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

       0.004906424 seconds time elapsed
\end_layout

\end_inset


\end_layout

\begin_layout Standard
For moderately large allocations, the input and output arrays will 
\emph on
always
\emph default
 be aligned to 12 bits.
 The likely cause of alias problems here is a conflict between input[i]
 and output[i].
 Although distinct memory locations, the out of order memory system detects
 conflicts.
 The hypothesis can be tested by offseting one of the arrays before calling
 convolve.
 We allocate some extra space for output, and use pointer arithmetic to
 offset the buffer sent to convolve.
 Offset is defined using a compile directive, adding no overhead in the
 generated source.
 The impact of a constant addition of allocated space is neglegtible.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},language=C"
inline false
status open

\begin_layout Plain Layout

    float *result = malloc((N + 0x100)*sizeof(float));
\end_layout

\begin_layout Plain Layout

    convolve(N, input, (result + OFFSET));
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="8">
<features tabularvalignment="middle" tabularwidth="100text%">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0pt">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
x
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x01
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x04
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x08
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x0c
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x10
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x14
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-O0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-O1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-O2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-O3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Performance statistics for 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=C"
inline true
status open

\begin_layout Plain Layout

convolve(input, (result + x), N)
\end_layout

\end_inset

, with varying offset x, and array size N of 0xffff.
 Measured using 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=C"
inline true
status open

\begin_layout Plain Layout

perf stat -e r0107:u -r 10
\end_layout

\end_inset

, counting number of partial address alias events averaged over 10 runs.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
TODO: Might want graph to visualize number of address alias per offset and/or
 cycles.
\end_layout

\begin_layout Standard
The best parameter is found to be at a 16 element difference in alignment
 between input and output.
 Adding 0x10 to the output pointer (allocating some extra space to compensate),
 we get much faster code.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily}"
inline false
status open

\begin_layout Plain Layout

         5,719,361 cycles:u
\end_layout

\begin_layout Plain Layout

             1,094 r0107:u
\end_layout

\begin_layout Plain Layout

         1,351,256 r01a2:u
\end_layout

\begin_layout Plain Layout

        11,163,873 instructions:u
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

       0.002919409 seconds time elapsed
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that the number of alias conflicts reduces with increasing offset.
 This is likely because adjacent indeces are accessed in the loop.
 If output is offset by 0x01, then output[i] is aliased with input[i-1].
 Intuitively, one could suspect that an offset of 3 floats would be enough
 to eliminate alias, as the maximum difference is 2.
 (Is this true for low optimization?) We find that as many as 16 is needed
 on the highest level of optimization, illustrating the depth of speculative
 execution of memory operations.
 
\end_layout

\begin_layout Standard
Interestingly, neither O1, O2 or O3 was able to do anything about this --
 yet a very simple change with no obvious significance gave a speedup of
 over 1.4x.
 
\end_layout

\begin_layout Subsubsection*
Architectural Optimization Flags
\end_layout

\begin_layout Standard
Because address aliasing is an artifact of intricacies in the Intel Core
 architecture, we could hope that GCC will help when provided this information.
 In the documentation
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset CommandInset href
LatexCommand href
name "http://gcc.gnu.org/onlinedocs/gcc-4.6.3/gcc/i386-and-x86_002d64-Options.html"
target "http://gcc.gnu.org/onlinedocs/gcc-4.6.3/gcc/i386-and-x86_002d64-Options.html#i386-and-x86_002d64-Options"

\end_inset


\end_layout

\end_inset

 we find four possible architecture specifications; 
\emph on
native
\emph default
, 
\emph on
core2
\emph default
, 
\emph on
corei7
\emph default
 and 
\emph on
corei7-avx
\emph default
.
 Native seems to produce code equivalent to corei7-avx.
 Using the -march=native flag does indeed prodice better code, but not as
 efficient as offseting arrays manually and not specifying any particular
 architecture.
 Note that code compiled with these flags are not guaranteed to work on
 other architectures, reducing portability.
\end_layout

\begin_layout Subsubsection*
Use of restrict
\end_layout

\begin_layout Standard
We can provide additional information to the compiler's optimizer by using
 the restrict keyword for the input and output arrays.
 This keyword was added in the C99 standard.
 It functions as a type qualifier for pointers, specifying that no pointer
 aliases exists.
 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},language=C"
inline false
status open

\begin_layout Plain Layout

void convolve(int size, const float * restrict input, float * restrict output)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
By marking input and output as restrict, we guarantee they are the only
 pointers to their respective memory areas, and not accesses through any
 other (aliased) pointers.
 This results in much more efficient code.
 We find that the following compile parameters for gcc provide the best
 code.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small}"
inline false
status open

\begin_layout Plain Layout

cc -O3 -std=c99 -march=native
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We see that the cycle count is drastically reduced, down to about 3.5 million.
 However, we still have over 1 million resource stalls, and 250 thousand
 alias events, which might indicate that even providing restrict is not
 enough.
 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small}"
inline false
status open

\begin_layout Plain Layout

         3,565,704 cycles:u                  #    0.000 GHz             
         ( +-  0.20% )
\end_layout

\begin_layout Plain Layout

           258,469 r0107:u                                             
          ( +-  0.05% )
\end_layout

\begin_layout Plain Layout

         1,065,207 r01a2:u                                             
          ( +-  0.59% )
\end_layout

\begin_layout Plain Layout

         3,299,634 instructions:u            #    0.93  insns per cycle 
         ( +-  0.00% )
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

       0.002281839 seconds time elapsed                                 
         ( +-  0.76% )
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Again, we test the hypothesis by incrementing an offset to the ouput pointer
 before calling convolve.
 At 0x30, we find the optimal configuration.
 We reduce the number of alias effects to a neglegtible amount, and numberof
 resource stalls is cut in half.
 Even with every opportunity for optimization given to the compiler, we
 are still able to squeeze out a speedup of 1.16x just by changing memory
 addresses.
 This speedup is consistent through input sizes, similar for 0x1000000.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small}"
inline false
status open

\begin_layout Plain Layout

         3,070,418 cycles:u                  #    0.000 GHz             
         ( +-  0.32% )
\end_layout

\begin_layout Plain Layout

               206 r0107:u                                             
          ( +- 27.26% )
\end_layout

\begin_layout Plain Layout

           580,203 r01a2:u                                             
          ( +-  1.82% )
\end_layout

\begin_layout Plain Layout

         3,299,634 instructions:u            #    1.07  insns per cycle 
         ( +-  0.00% )
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

       0.002118936 seconds time elapsed                                 
         ( +-  0.67% )
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that the resulting binaries, providing no offset and offset of 0x30,
 were checked with 'diff'.
 They only differ in two lines in main, where a leaq is used instead of
 move (for addition), and different register for another movq instruction.
\end_layout

\begin_layout Subsubsection*
Other Compilers
\end_layout

\begin_layout Standard
The alias effects on this particular example is most prominent on GNU's
 cc.
 We have tested on clang and icc as well -- with varying results.
 
\end_layout

\begin_layout Description
clang behaves similar to cc with respect to offsets to minimize alias.
 However, we only need to add 0x10 to get rid of aliasing.
 The change in cycle count is not as clear (Need more controlled benchmark).
 A lot less efficient code is generated, almost ten times as many dynamic
 instructions executed.
\end_layout

\begin_layout Description
icc produces code that performs reasonably well with respect to alias count
 on no additional offset.
 Interestingly, a very similar count of address alias events are recorded
 for code compiled with cc, about 260,000 for N = 0x100000.
 Alias can be eliminated almost completely, but that requires an offset
 of 0xa0.
 Performance actually worsenes with smaller offsets, increasing alias count
 significantly.
\end_layout

\begin_layout Subsection
Libraries as Environment Bias
\end_layout

\begin_layout Standard
The previous example does not show measurement bias per se, but rather an
 artifact of the particular implementation of malloc.
 A perfectly legal implementation of malloc could insert offsets on every
 other large request.
 Bottom line is: dynamically linked libraries are part of the execution
 environment.
 
\end_layout

\begin_layout Standard
In the case of memory allocators alone, there are several options: The one
 used in GNU's libc is 
\series bold
ptmalloc
\series default

\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset CommandInset href
LatexCommand href
name "http://www.malloc.de/en/"
target "http://www.malloc.de/en/"

\end_inset


\end_layout

\end_inset

, which is based on Doug Lea's malloc
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset CommandInset href
LatexCommand href
name "http://g.oswego.edu/dl/html/malloc.html"
target "http://g.oswego.edu/dl/html/malloc.html"

\end_inset


\end_layout

\end_inset

, Hoard
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset CommandInset href
LatexCommand href
name "http://www.hoard.org/"
target "http://www.hoard.org/"

\end_inset


\end_layout

\end_inset

, nedmalloc 
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset CommandInset href
LatexCommand href
name "http://www.nedprod.com/programs/portable/nedmalloc/"
target "http://www.nedprod.com/programs/portable/nedmalloc/"

\end_inset


\end_layout

\end_inset

 and tcmalloc
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset CommandInset href
LatexCommand href
name "http://google-perftools.googlecode.com/svn/trunk/doc/tcmalloc.html"
target "http://google-perftools.googlecode.com/svn/trunk/doc/tcmalloc.html"

\end_inset


\end_layout

\end_inset

.
 Many allocators try to battle lock contention for multithreaded programs,
 where each thread share a common heap space.
 Allocating and freeing dynamic memory from a shared pool must be synchronized
 in some way.
 Testing multiple allocators might be worthwile, particularly for multithreaded
 applications.
 A potential cause of producing 
\begin_inset Quotes eld
\end_inset

bad data
\begin_inset Quotes erd
\end_inset

 is optimizing around a bad allocator, or one that perform sub-optimally
 on a particular usage pattern.
\end_layout

\begin_layout Standard
Need some measurements to support this claim ...
 Pretty easy to test malloc replacements, just change LD_PRELOAD apparently.
 Question: Does any of the implementations of malloc optimize for parallell
 sequential array access, reducing alias effects? Probably not, which is
 cool! Could suggest fix.
 (Heuristic, or static analysis, etc).
\end_layout

\begin_layout Description
Hoard Same behaviour on large allocations.
 Returned addresses always ends in 0x070.
 Significantly larger cycle count, but same number of address alias events.
 Could not compile from source, linked with dynamic library.
\end_layout

\begin_layout Description
nedmalloc Did not compile -- no prebuilt binary.
\end_layout

\begin_layout Description
tcmalloc Aligns at page boundary, ending in 0x000.
 Uses low addresses, 0xa49000 etc.
 Returns page-aligned areas for smaller allocations as well -- possible
 environment bias.
\end_layout

\begin_layout Standard
We did some testing with three of the libraries, allocating two arrays of
 equal length for different sizes.
 The libraries produce very different results.
 The default implementation alternates between using the brk segment (low
 addresses and non-aligned, and mmap on higher segments.
 Tcmalloc tends to put variables on page boundaries, also for small sizes,
 returning addresses ending in 0x000.
 Hoard tends to align on page boundaries for larger requests, with addresses
 ending in 0x070.
 
\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="9" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Size
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Default (libc)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
tcmalloc
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Hoard
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="3" alignment="left" valignment="middle" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0xf00
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x603010
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x695
\series bold
000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x2aaaac000070
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x606c20
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x699
\series bold
000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x2aaaac004000
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="3" alignment="left" valignment="middle" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x1234
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x603010
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x69d
\series bold
000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x2aaaac010070
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x6078f0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x6a2
\series bold
000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x2aaaac014d38
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="3" alignment="left" valignment="middle" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0xffff
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x2aaaaaad1
\series bold
010
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x6a7
\series bold
000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x2aaaac020
\series bold
070
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x2aaaaab12
\series bold
010
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x6e7
\series bold
000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x2aaaac070
\series bold
070
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="3" alignment="left" valignment="middle" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x10000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x603010
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x6a7
\series bold
000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x2aaaac020
\series bold
070
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x643020
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x6e7
\series bold
000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x2aaaac070
\series bold
070
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:malloc-impl-tuples"

\end_inset

Addresses returned when allocating two float arrays of the same size, examples
 of possible sources for alias conflicts.
 Tests were run with ASLR disabled for reproducible results, but we get
 similar results with randomization enabled.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:malloc-impl-tuples"

\end_inset

 shows that potential for address alias conflicts depends on the particular
 implementation of malloc used.
 We see several examples of cases where switching library can eliminate
 alias by changing suffix on pointers.
 Note that tcmalloc aligns to page boundary in all cases.
 
\end_layout

\begin_layout Standard
Most allocators focus on efficiency in a multithreaded environment, and
 we find that none of the alternatives tested attempts to solve the aliasing
 problem for aligned arrays.
\end_layout

\begin_layout Subsection
Optimization Guidelines
\end_layout

\begin_layout Standard
User/Source Coding Rule 8.
 (H impact, ML generality) Consider using a special memory allocation library
 with address offset capability to avoid aliasing.
 ..
 3-76 
\end_layout

\begin_layout Standard
(Similar for LSD, compiler guideline).
\end_layout

\begin_layout Standard
\begin_inset Newpage clearpage
\end_inset


\end_layout

\begin_layout Section
The Loop Stream Detector
\end_layout

\begin_layout Standard
Typical software spends most of the time executing the same instructions
 repeatedly in a loop.
 For each iteration, the same branch predictions are made, and the same
 instructions are fetched and decoded.
 The Loop Stream Detector (LSD) is a front-end hardware optimization that
 is able to detect small software loops 
\begin_inset CommandInset citation
LatexCommand cite
key "Ramesh:i7PerformanceMonitoring"

\end_inset

.
 Instead of repeatedly fetching and decoding the same instructions, loops
 can be streamed directly from a queue of already decoded micro operations.
 Normal operations is resumed once the inevetable branch mispredict occurs.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Img/intel/lsd.eps

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Loop Stream Detector circumvents branch prediction, fetch and decode for
 hot loops, streaming directly from the micro-op queue
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
This optimization is affecting both performance and power efficiency.
 Power savings come from disabling the branch prediction, fetch and decode
 components when the LSD is active.
 In cases where instruction fetch is the bottleneck, streaming already decoded
 micro-operations can also increase performance.
 
\end_layout

\begin_layout Standard
In the documentation, we find two hardware performance counters that can
 measure the utilization of the LSD 
\begin_inset CommandInset citation
LatexCommand cite
key "Intel:2013:Volume3B"

\end_inset

.
\end_layout

\begin_layout Description
LSD.UOPS Counts the number of micro-ops delivered by loop stream detector.
\end_layout

\begin_layout Description
LSD_OVERFLOW Counts number of loops that can't stream from the instruction
 queue.
 
\end_layout

\begin_layout Standard
Note that none of these are listed in the non-architectural counters supported
 by Ivy Bridge.
 However, we find that using the event codes given for previous architectures
 seems to work regardless, and gives reasonable results.
 We suspect that the official reference is either not complete or misleading
 in this case.
\end_layout

\begin_layout Subsection
Properties of the Loop Stream Detector
\end_layout

\begin_layout Standard
A set of restrictions is given on what loops can be recognized by the loop
 stream detector.
 The Architectures Optimization Reference Manual 
\begin_inset CommandInset citation
LatexCommand cite
key "Intel:2012:OptimizationManual"

\end_inset

 states the following requirements for a loop to be recognized by the LSD:
\end_layout

\begin_layout Itemize
Up to eight chunk fetches of 32 instruction-bytes
\end_layout

\begin_layout Itemize
Up to 28 micro-ops (~28 instructions)
\end_layout

\begin_layout Itemize
All micro-ops are also resident in the Decoded ICache
\end_layout

\begin_layout Itemize
Can contain no more than eight taken branches and none of them can be a
 CALL or RET
\end_layout

\begin_layout Itemize
Cannot have mismatched stack operations.
 For example, more PUSH than POP instructions
\end_layout

\begin_layout Standard
The capabilities of the LSD is changing between processor generations.
 In particular, the limits to chunk fetches, maximum number of micro-ops
 and taken branches seems to continuously increase 
\begin_inset CommandInset citation
LatexCommand cite
key "Ramesh:i7PerformanceMonitoring,Intel:OnlinePCReference"

\end_inset

.
 It is not clear whether the stated limitations are valid for the Ivy Bridge,
 as it is not explicitly stated in the manual.
 We create a series of micro benchmarks to manually verify what the actual
 limitations are.
 
\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="3">
<features booktabs="true" tabularvalignment="middle">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
HT off
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
HT on
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Chunk fetches
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Micro-ops
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
56
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
28
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Taken branches
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Properties of the Ivy Bridge Loop Stream Detector, determined empirically
 by a series of micro benchmarks
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Chunk fetches
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement t
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},language=C"
inline false
status open

\begin_layout Plain Layout

    .section .text
\end_layout

\begin_layout Plain Layout

    .globl main
\end_layout

\begin_layout Plain Layout

main:
\end_layout

\begin_layout Plain Layout

    mov $0x1234567, %eax 
\end_layout

\begin_layout Plain Layout

    mov $0, %ebx
\end_layout

\begin_layout Plain Layout

    .p2align 5
\end_layout

\begin_layout Plain Layout

.l0:
\end_layout

\begin_layout Plain Layout

    cmp $0, %ebx
\end_layout

\begin_layout Plain Layout

    je .l1
\end_layout

\begin_layout Plain Layout

    lea 0x100(%rsp), %ecx
\end_layout

\begin_layout Plain Layout

    lea 0x100(%rsp), %ecx
\end_layout

\begin_layout Plain Layout

    lea 0x100(%rsp), %ecx
\end_layout

\begin_layout Plain Layout

    add $0x100, %ecx
\end_layout

\begin_layout Plain Layout

.l1:
\end_layout

\begin_layout Plain Layout

    (...)
\end_layout

\begin_layout Plain Layout

.l11:
\end_layout

\begin_layout Plain Layout

    cmp $0, %eax
\end_layout

\begin_layout Plain Layout

    jne .l0
\end_layout

\begin_layout Plain Layout

    ret
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:lsd-chunks"

\end_inset

Micro kernel for testing chunk fetch limit.
 Additional (
\family typewriter
cmp
\family default
, 
\family typewriter
je
\family default
, 
\family typewriter
lea
\family default
, 
\family typewriter
lea
\family default
, 
\family typewriter
lea
\family default
, 
\family typewriter
add
\family default
) blocks of exactly 32 bytes are inserted until LSD.UOPS shows the Loop Stream
 Detector is no longer active.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The documentation states that a maximum number of eight 32 byte 
\begin_inset Quotes eld
\end_inset

chunks
\begin_inset Quotes erd
\end_inset

 of instruction data can be fetched in each loop.
 Our interpretation of this is that instruction data is somehow organized
 into blocks of 32 bytes, aligned to multiples of 0x20 in virtual address
 space.
 
\end_layout

\begin_layout Standard
To test this limit, we need loops that execute instructions spanning a variable
 amount of chunks.
 The micro kernel we used is shown in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:lsd-chunks"

\end_inset

, written in GNU x86_64 assembly.
 The idea is to execute a minimal amount of instructions at the start of
 each block, and immediately jump on to the next.
 Blocks are labeled 
\family typewriter
.l0
\family default
, 
\family typewriter
.l1
\family default
, …, 
\family typewriter
.ln
\family default
, and the first block is explicitly forced to align on a 32 byte boundary
 (5 bits) by the 
\family typewriter
.p2align
\family default
 directive.
 Virtual addresses of code and static data can be read from the ELF binary
 after compilation.
 A disassembled portion of the code is shown below
\begin_inset Foot
status open

\begin_layout Plain Layout
Output shows disassembly generated by the objdump utility, part of GNU Binutils
\end_layout

\end_inset

.
 We see that the first compare instruction starts on address 
\family typewriter
0x400500
\family default
, aligned to 32 byte.
 Because 
\family typewriter
%ebx
\family default
 is always zero, the branch is taken every time.
 The remaining 
\family typewriter
lea
\family default
 and 
\family typewriter
add
\family default
 instructions are added to fill the remaining bytes in the chunk.
 Only the first 
\begin_inset Formula $3+2$
\end_inset

 instruction bytes occupied by 
\family typewriter
cmp
\family default
 and 
\family typewriter
je
\family default
 are executed, while the remaining 
\begin_inset Formula $27$
\end_inset

 bytes is dead code.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily}"
inline false
status open

\begin_layout Plain Layout

400500: 83 fb 00             cmp    $0x0,%ebx
\end_layout

\begin_layout Plain Layout

400503: 74 1b                je     400520 <.l1>
\end_layout

\begin_layout Plain Layout

400505: 8d 8c 24 00 01 00 00 lea    0x100(%rsp),%ecx
\end_layout

\begin_layout Plain Layout

40050c: 8d 8c 24 00 01 00 00 lea    0x100(%rsp),%ecx
\end_layout

\begin_layout Plain Layout

400513: 8d 8c 24 00 01 00 00 lea    0x100(%rsp),%ecx
\end_layout

\begin_layout Plain Layout

40051a: 81 c1 00 01 00 00    add    $0x100,%ecx
\end_layout

\end_inset


\end_layout

\begin_layout Standard
After some number of repeated blocks like these, the counter is incremented
 before jumping back to 
\family typewriter
.l0
\family default
.
 The final 
\family typewriter
sub
\family default
, 
\family typewriter
cmp
\family default
 and 
\family typewriter
jne
\family default
 instructions occupy 12 bytes, so we could potentially insert another 20
 bytes of padding to completely fill the last chunk as well.
 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily}"
inline false
status open

\begin_layout Plain Layout

400674: 83 e8 01             sub    $0x1,%eax
\end_layout

\begin_layout Plain Layout

400677: 83 f8 00             cmp    $0x0,%eax
\end_layout

\begin_layout Plain Layout

40067a: 0f 85 80 fe ff ff    jne    400500 <.l0>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
For every loop iteration, a total of 
\begin_inset Formula $2N+3$
\end_inset

 instructions are executed, spanning 
\begin_inset Formula $N+1$
\end_inset

 chunks of 32 bytes.
 The 
\family typewriter
cmp
\family default
 and 
\family typewriter
je
\family default
 instructions should be fused to a single micro-op, so we should not be
 hitting the micro-op limit.
 We find that the LSD.UOPS counter reports high values through 
\begin_inset Formula $N=11$
\end_inset

, meaning the Ivy Bridge Loop Stream Detector must supports at least 12
 chunk fetches.
 
\end_layout

\begin_layout Subsubsection*
Micro-operations
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},language=C"
inline false
status open

\begin_layout Plain Layout

    .section .text
\end_layout

\begin_layout Plain Layout

    .globl main
\end_layout

\begin_layout Plain Layout

main:
\end_layout

\begin_layout Plain Layout

    mov $0x1234567, %eax
\end_layout

\begin_layout Plain Layout

    .p2align 5
\end_layout

\begin_layout Plain Layout

.loop:
\end_layout

\begin_layout Plain Layout

    add %ebx, %ecx
\end_layout

\begin_layout Plain Layout

    add %ebx, %ecx
\end_layout

\begin_layout Plain Layout

    (...)
\end_layout

\begin_layout Plain Layout

    sub $1, %eax
\end_layout

\begin_layout Plain Layout

    cmp $0, %eax
\end_layout

\begin_layout Plain Layout

    jne .loop
\end_layout

\begin_layout Plain Layout

    ret
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:lsd-micro-ops"

\end_inset

Micro kernel for testing LSD micro-instruction limit.
 Additional 
\family typewriter
add
\family default
 instructions are inserted until LSD.UOPS shows the Loop Stream Detector
 becomes inactive.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The second requirement states that each loop can only contain a maximum
 of 28 micro-operations.
 This is no longer true for Ivy Bridge, because of changes to the Micro-op
 Queue.
 In previous generation(s), the micro-op queue was statically partitioned
 with 28 entries for each logical core.
 One of the Front-end enhancement in Ivy Bridge is that all 56 entries in
 the queue can be used when only a single logical core is active, i.e.
 hyperthreading is disabled 
\begin_inset CommandInset citation
LatexCommand cite
key "Intel:2012:OptimizationManual"

\end_inset

.
 We verify this restriction by measuring LSD_OVERFLOW and LSD.UOPS for loops
 of increasing size, adding instructions one by one until the performance
 counter statistics report the LSD is inactive.
 Our micro-kernel is shown in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:lsd-micro-ops"

\end_inset

.
\end_layout

\begin_layout Standard
We find that the LSD is active with as many as 54 
\family typewriter
add
\family default
 instructions.
 With macro-fusion of the last 
\family typewriter
cmp
\family default
 + 
\family typewriter
jne
\family default
, the total is exactly 56 micro-operations per loop.
 With hyperthreading enabled, the number is cut in half to 28, as expected.
\end_layout

\begin_layout Subsubsection*
Taken branches
\end_layout

\begin_layout Standard
The fourth requirement states that a loop can contain no more than eight
 taken branches.
 The chunk fetch limit example already uses 12 branches, so we can immediately
 conclude that at least 12 taken branches is supported.
 We experiment with more than one branch targets in each chunk, but are
 not able to increase the number any further.
 
\end_layout

\begin_layout Subsection
Hitting the Chunk Fetch Limit
\end_layout

\begin_layout Standard
Knowing the parameters, we can construct programs that are on the limit
 of what the Loop Stream Detector accepts.
 Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:lsd-chunks-c"

\end_inset

 shows a simple loop that generates code much like the micro kernel used
 to test chunk fetch limit.
 Each of the if statements occupies exacly 32 byte in instruction memory
 when compiled with gcc and no optimization.
 Including the instructions needed to compare and increment variable 
\family typewriter
i
\family default
, the loop code covers almost 12 chunks in the compiled binary.
 
\end_layout

\begin_layout Standard
\noindent
\begin_inset Float algorithm
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},showstringspaces=false"
inline false
status open

\begin_layout Plain Layout

#include <stdio.h>
\end_layout

\begin_layout Plain Layout

#define B27 a=b, a=b, a=b, a=b, a=b, a=b, a=b, a=b, a=b
\end_layout

\begin_layout Plain Layout

int main() {
\end_layout

\begin_layout Plain Layout

    register int i = 0, a = 1, b = 1;
\end_layout

\begin_layout Plain Layout

    //printf("What is going wrong?");
\end_layout

\begin_layout Plain Layout

    while (i++ < 0x12345678) {
\end_layout

\begin_layout Plain Layout

        if (a != b) B27;
\end_layout

\begin_layout Plain Layout

        if (a != b) B27;
\end_layout

\begin_layout Plain Layout

        if (a != b) B27;
\end_layout

\begin_layout Plain Layout

        if (a != b) B27;
\end_layout

\begin_layout Plain Layout

        if (a != b) B27;
\end_layout

\begin_layout Plain Layout

        if (a != b) B27;
\end_layout

\begin_layout Plain Layout

        if (a != b) B27;
\end_layout

\begin_layout Plain Layout

        if (a != b) B27;
\end_layout

\begin_layout Plain Layout

        if (a != b) B27;
\end_layout

\begin_layout Plain Layout

        if (a != b) B27;
\end_layout

\begin_layout Plain Layout

        if (a != b) B27;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:lsd-chunks-c"

\end_inset

Loop spanning 13 chunks of 32 bytes when compiled with gcc, but only 12
 chunks with the printf statement uncommented.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Even though we are within the limit, a quick test with 
\family typewriter
perf
\family default
 reveals that the Loop Stream Detector is not enabled.
 Only a neglegtible amount of micro-ops are delivered by the LSD, as reported
 by LSD.UOPS (r01a8).
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily}"
inline false
status open

\begin_layout Plain Layout

     7,636,871,921 cycles:u                                            
          
\end_layout

\begin_layout Plain Layout

            10,936 r01a8:u                                             
        
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

       2.254012765 seconds time elapsed
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Inspecting the compiled binary, we see that the loop instructions span virtual
 addresses 0x4004d3 through 0x400648.
 The first byte in a chunk have address ending in 0x00, 0x20, 0x40, 0x60,
 0x80, 0xa0, 0xc0 or 0xe0, meaning the first instruction belongs to the
 0x4004
\series bold
c0
\series default
 chunk, and the last is just within the 0x4006
\series bold
40
\series default
 chunk.
 Dispite covering less than 
\begin_inset Formula $12\times32$
\end_inset

 byte of instruction addresses, this specific alignment causes the code
 to span not 12 but 13 chunks, exceeding the limitation of the Loop Stream
 Detector.
 
\end_layout

\begin_layout Standard
We can try to create a different alignment by inserting some code before
 the loop.
 By uncommenting the printf statement, we see that the LSD is able to deliver
 micro-ops, giving a huge speedup.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily}"
inline false
status open

\begin_layout Plain Layout

     3,665,748,974 cycles:u                                    
\end_layout

\begin_layout Plain Layout

     4,581,313,440 r01a8:u                    
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

       1.078952880 seconds time elapsed
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Looking at the binary again, we find that the loop now only covers 12 chunks,
 spanning addresses 0x400529 through 0x40069e.
 The difference between the two configurations is illustrated in Figure
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:lsd-chunks-12-13"

\end_inset

.
 When no optimization flags are used, GCC does not try to align loops in
 any strict way, meaning that differences like these depend on surrounding
 code, i.e.
 essentially random.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Img/lsd/chunks-13.eps

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:lsd-chunks-12-13"

\end_inset

Depending on alignment, code can span either 12 or 13 chunks of 32 byte
 instruction memory
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Bias from Link Order
\end_layout

\begin_layout Standard
Link order of object files was discussed in the background as one of the
 potential sources of bias.
 Different link orders basically determines the relative position of code
 and static data within the final compiled binary file.
 The Loop Stream Detector is sensitive to alignment and address layout of
 code, which can explain bias effects triggered by link order in some cases.
 
\end_layout

\begin_layout Subsubsection
Chunk fetches
\end_layout

\begin_layout Standard
With a few modifications to our previous example, we can create a program
 that utilizes the LSD only for certain link orders.
 Our program is shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:lsd-link-O3"

\end_inset

, containing three files; main.c, foo.c and loop.c.
 
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\emph on
foo.c:
\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\ttfamily}"
inline false
status open

\begin_layout Plain Layout

int foo(int n)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    int a = 1;
\end_layout

\begin_layout Plain Layout

    return a;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Plain Layout

\emph on
main.c:
\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\ttfamily}"
inline false
status open

\begin_layout Plain Layout

#include <stdio.h>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    int i = loop(10);
\end_layout

\begin_layout Plain Layout

    int f = foo(10);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    printf("Loop: %d
\backslash
n",i);
\end_layout

\begin_layout Plain Layout

    printf("Foo : %d
\backslash
n",f);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "50col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\emph on
loop.c:
\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\ttfamily}"
inline false
status open

\begin_layout Plain Layout

#define B22(n) b += i*i*a + 1
\end_layout

\begin_layout Plain Layout

volatile int i = 42;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int loop(int a) {
\end_layout

\begin_layout Plain Layout

    register int b = i==42 ? 1 : 0;
\end_layout

\begin_layout Plain Layout

    do {
\end_layout

\begin_layout Plain Layout

        if (!i) B22(1);
\end_layout

\begin_layout Plain Layout

        if (!i) B22(2);
\end_layout

\begin_layout Plain Layout

        if (!i) B22(3);
\end_layout

\begin_layout Plain Layout

        if (!i) B22(4);
\end_layout

\begin_layout Plain Layout

        if (!i) B22(5);
\end_layout

\begin_layout Plain Layout

        if (!i) B22(6);
\end_layout

\begin_layout Plain Layout

        if (!i) B22(7);
\end_layout

\begin_layout Plain Layout

        if (!i) B22(8);
\end_layout

\begin_layout Plain Layout

        if (!i) B22(9);
\end_layout

\begin_layout Plain Layout

        if (!i) B22(10);
\end_layout

\begin_layout Plain Layout

        if (!i) B22(11);
\end_layout

\begin_layout Plain Layout

   } while (i++ < 0x12345678);
\end_layout

\begin_layout Plain Layout

    return b;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:lsd-link-O3"

\end_inset

Program with measurement bias from link order, favoring (main, foo, loop)
 over (main, loop, foo) when compiled with GCC and optimization level O3
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In the example from Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:lsd-chunks-c"

\end_inset

, we exploited weak alignment guarantees from GCC, sometimes spilling loop
 code over 13 chunks.
 One might hope that with the proper optimization flags, compilers will
 fix such alignment flaws.
 There is an 
\begin_inset Quotes eld
\end_inset

align-loops
\begin_inset Quotes erd
\end_inset

 flag in GCC
\begin_inset Foot
status open

\begin_layout Plain Layout
Optimize Options -- Using the GNU Compiler Collection (GCC), 
\begin_inset CommandInset href
LatexCommand href
name "http://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html"
target "http://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html"

\end_inset


\end_layout

\end_inset

, enabled by default in O2 and O3, which allows the assembler align loops
 by inserting necessary padding .
 On optimization O3, the following assembly directives
\begin_inset Foot
status open

\begin_layout Plain Layout
The GNU Assembler, 
\begin_inset CommandInset href
LatexCommand href
name "http://tigcc.ticalc.org/doc/gnuasm.html"
target "http://tigcc.ticalc.org/doc/gnuasm.html"

\end_inset


\end_layout

\end_inset

 are inserted before the first loop instruction, compiled with 
\family typewriter
cc -O3 -S loop.c
\family default
.
\begin_inset listings
lstparams "basicstyle={\small\ttfamily}"
inline false
status open

\begin_layout Plain Layout

.p2align 4,,10
\end_layout

\begin_layout Plain Layout

.p2align 3
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The first directive tries to align to four address bits, inserting at most
 10 bytes for padding.
 If that does not work, the next directive forces loops to be aligned to
 three bits -- meaning addresses ending in 0x0 or 0x8.
 Within a 32 byte instruction block, the first loop instruction can end
 up being offset by 0x00, 0x08, 0x10 or 0x18.
 The loop itself spans 379 instruction bytes when compiled in our example,
 just shy of the 
\begin_inset Formula $12\times32=384$
\end_inset

 bytes that can maximally fit in the LSD.
 Out of the four possible alignments, only zero offset into a chunk will
 work in our case.
 
\end_layout

\begin_layout Itemize
Link order 
\emph on
main.c, loop.c, foo.c
\emph default
: The first loop instruction is aligned to 
\family typewriter
0x400590
\family default
, an offset of 0x10 into the 0x4005
\series bold
80
\series default
 chunk.
 Covering 13 chunks, the Loop Stream Detector can not be utilized.
 
\begin_inset listings
lstparams "basicstyle={\small\ttfamily}"
inline false
status open

\begin_layout Plain Layout

7,636,791,251 cycles:u                                                 
   
\end_layout

\begin_layout Plain Layout

       10,946 r01a8:u 
\end_layout

\begin_layout Plain Layout

                              
\end_layout

\begin_layout Plain Layout

  2.251854012 seconds time elapsed
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Link order 
\emph on
main.c, foo.c, loop.c
\emph default
: The first loop instruction is aligned to 
\family typewriter
0x4005
\series bold
a0
\family default
\series default
, right at the start of a chunk.
 Cycle count is reduced by more than 50% from utilizing the LSD.
 
\begin_inset listings
lstparams "basicstyle={\small\ttfamily}"
inline false
status open

\begin_layout Plain Layout

3,665,879,867 cycles:u  
\end_layout

\begin_layout Plain Layout

8,246,353,284 r01a8:u 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  1.080532586 seconds time elapsed
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We see that measurement bias from link order can in some cases be explained
 by hitting the chunk fetch limit of the Loop Stream Detector.
 Even when compiling with sensible optimization flags, GCC does not always
 hit the optimal loop alignment, causing code to spill over additional chunks.
 A possible solution in this scenario could be to manually specify the loop
 alignment to 32 byte, with -falign-loops=32.
\end_layout

\begin_layout Subsubsection
Decoded ICache Limitations
\end_layout

\begin_layout Standard
Any property of the Loop Stream Detector that depends on the code layout
 in memory can potentially be triggered by different link orders.
 This is not limited to the number of chunk fetches, but also includes propertie
s of the Decoded ICache.
 One of the LSD requirements states that all micro-ops must be present in
 the Decoded ICache.
 The manual describes several restrictions to what micro-ops can be stored
 in this cache, imposing limitations to the number of branches per block,
 and other alignment properties 
\begin_inset CommandInset citation
LatexCommand cite
key "Intel:2012:OptimizationManual"

\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\ttfamily}"
inline false
status open

\begin_layout Plain Layout

#include <stdio.h>
\end_layout

\begin_layout Plain Layout

volatile static int color;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main() {
\end_layout

\begin_layout Plain Layout

    printf("Fixing colors");
\end_layout

\begin_layout Plain Layout

    for (int i = 0; i < 10000000; ++i) {
\end_layout

\begin_layout Plain Layout

        if (color == 0x000)
\end_layout

\begin_layout Plain Layout

            color = 0xaaa;
\end_layout

\begin_layout Plain Layout

        else if (color == 0xaaa)
\end_layout

\begin_layout Plain Layout

            color = 0xfff;
\end_layout

\begin_layout Plain Layout

        else if (color == 0xfff)
\end_layout

\begin_layout Plain Layout

            color = 0x000;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:lsd-color"

\end_inset

Loop using LSD only for certain alignments when compiled with GCC and no
 optimization, likely hitting limitations in Decoded ICache
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Consider the small C program from Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:lsd-color"

\end_inset

.
 Compiling with 
\family typewriter
cc -std=c99
\family default
 and no optimization, the binary code generated by this function clearly
 spans far less than 12 chunks.
 Counting LSD.UOPS, we see that the Loop Stream Detector is not in use.
 However, by removing the printf statement the loop alignment is moved from
 0x400517 to 0x4004c1, and the LSD is suddently working.
 We did not investigate the actual cause of this any further, but speculate
 that specific alignments prevents all micro-ops to reside in ICache simultaneou
sly.
 
\end_layout

\begin_layout Standard
On a final note, it is not too difficult to come up with smaller programs
 like this that hits some limitation of the LSD for certain alignments.
 It appears that this particular hardware feature is a very likely cause
 of bias from link order.
 
\end_layout

\begin_layout Subsection
Bias from Trivial Code Changes
\end_layout

\begin_layout Standard
The Loop Stream Detector can in some cases provide significant speedup.
 On the flip side, subtle changes to code layout sometimes prevents this
 optimization to be utilized.
 As we have seen, simply adding a printf statement or changing the link
 order, can result in wildly different performance characteristics.
 Programmers rarely care, or even know, about intricate details such as
 the addresses and alignment of code.
 We expect, and probably rightfully so, that sensible compilers and linkers
 will organize code somewhat optimally.
 In cases where this is not true, weird effects that might be categorized
 as 
\begin_inset Quotes eld
\end_inset

bias
\begin_inset Quotes erd
\end_inset

 occurs.
 For developers, it is useful to be aware of the fact that 
\emph on
any
\emph default
 change to instruction addresses can potentially have a huge impact on performan
ce.
 
\end_layout

\begin_layout Subsubsection*
The order of functions within a source file
\end_layout

\begin_layout Standard
As with link order, the order of functions within a source file usually
 determines their relative position in the text segment of the compiled
 binary.
 Given a program with functions foo and bar, listing foo before bar and
 vice versa generates two 
\begin_inset Quotes eld
\end_inset

different
\begin_inset Quotes erd
\end_inset

 programs with respect to memory layout.
 GCC prints functions to the text segment in the order they appear in the
 source code.
\end_layout

\begin_layout Subsubsection*
Length of external symbols
\end_layout

\begin_layout Standard
unction names are placed in the .strtab section in the ELF file.
 When running readelf or objdump, the names are used to print nice output.
 However, function names of external symbols resolved at run-time does affect
 code layout.
 Longer function names (or more external dependencies) will offset the text
 segment because of allocable segments related to dynamic linking is placed
 before text.
 This includes dynsym, dynstr, gnu.version and rela sections in an executable
 made with GCC.
 Details for each of the ELF sections on GNU platform can be found in the
 man pages 
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset CommandInset href
LatexCommand href
name "http://linux.die.net/man/5/elf"
target "http://linux.die.net/man/5/elf"

\end_inset


\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection*
Changing interpreter
\end_layout

\begin_layout Standard
When executing an ELF binary, the first thing that happens is to load and
 run an interpreter.
 The interpreter is responsible for unpacking the object file and map all
 the allocable sections to virtual memory.
 The path to the interpreter itself is located in the 
\begin_inset Quotes eld
\end_inset

interp
\begin_inset Quotes erd
\end_inset

 section, which is allocable and loaded first.
 On our system, this defaults to 
\begin_inset Quotes eld
\end_inset

/lib64/ld-linux-x86-64.so.2
\begin_inset Quotes erd
\end_inset

, which should be common on 64 bit Linux systems.
 Other loaders can be specified, either at compile time or by patching the
 object file [footnote, patchelf].
 Because the string is allocated to virtual memory before the text segment,
 the size (in characters) can offset code addresses.
 Consider experimenting with a custom loader, for example linking with 
\begin_inset Quotes eld
\end_inset

-Wl,-dynamic-linker,/home/me/very/long/path/to/another/loader.symlink.so.2
\begin_inset Quotes erd
\end_inset

.
 Doing this can actually offset text segment of ELF binaries.
 
\end_layout

\begin_layout Subsection
Optimization Guidelines
\end_layout

\begin_layout Chapter
Case Studies
\end_layout

\begin_layout Standard
In this chapter we show how bias effects illustrated in the previous chapter
 is present in real software, and poses a significant challenge for performance
 benchmarks.
 In addition to pointing out problems, also show how measures can be taken
 to handle bias, and obtain a speedup on average over the space of possible
 contexts.
 
\end_layout

\begin_layout Section
FFTW
\end_layout

\begin_layout Standard
As an integral part of applications such as signal and image processing,
 a huge amount of work has been done over the years to optimize and tweak
 the performance of the Fast Fourier Transform (FFT).
 Today, there are a plethora of excellent implementations available, among
 them FFTW
\begin_inset Foot
status open

\begin_layout Plain Layout
FFTW Home Page,
\begin_inset CommandInset href
LatexCommand href
name "http://www.fftw.org/"
target "http://www.fftw.org/"

\end_inset


\end_layout

\end_inset

, an acronym for 
\begin_inset Quotes eld
\end_inset

Fastest Fourier Transform in the West
\begin_inset Quotes erd
\end_inset

.
 Its design goal is to be portable, yet achieve close to optimal performance
 across a wide variety of platforms 
\begin_inset CommandInset citation
LatexCommand cite
key "Frigo:2005:FFTW3"

\end_inset

.
 The library is not optimized specifically for any processor or architecture,
 but uses 
\emph on
automatic tuning
\emph default
 to adapt to the underlying hardware 
\begin_inset CommandInset citation
LatexCommand cite
key "Vuduc:2000:CodegenFFTW"

\end_inset

.
 Provided that a speedup on average can be achieved, explicitly handling
 of context bias could be a realistic addition to FFTW.
\end_layout

\begin_layout Subsubsection*
Installation and Configuration
\end_layout

\begin_layout Standard
We used the latest version 3.3.3 of FFTW in all our tests, compiled from source
 and built as a shared library.
 For optimal performance on our machine, we explicitly enable support for
 sse2 and avx instruction set.
 In addition, we set the 
\begin_inset Quotes eld
\end_inset

arch
\begin_inset Quotes erd
\end_inset

 compiler flag to 
\begin_inset Quotes eld
\end_inset

native
\begin_inset Quotes erd
\end_inset

, allowing the GCC to specifically tune generated code to our architecture.
 The configure script is invoked with the following parameters:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},breaklines=true"
inline false
status open

\begin_layout Plain Layout

./configure CC="gcc -march=native" --enable-shared --enable-sse2 --enable-avx
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Test Setup
\end_layout

\begin_layout Standard
FFTW is a very comprehensive library with lots of functionality.
 Our approach will be to engineer simple use cases where bias is easily
 measurable.
 We create a small C program with two parameters; the number of elements
 to transform, and the number of times to repeat the transform.
 This way, slight bias in smaller input sizes can be amplified.
 The API calls from Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:fft-alias-program"

\end_inset

 are explained below.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},breaklines=true,language=C"
inline false
status open

\begin_layout Plain Layout

int main() 
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    fftw_complex *in  = fftw_malloc(sizeof(fftw_complex)*N);
\end_layout

\begin_layout Plain Layout

    fftw_complex *out = fftw_malloc(sizeof(fftw_complex)*N);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    fftw_plan p = fftw_plan_dft_1d(N, in, out, FFTW_FORWARD, FFTW_ESTIMATE);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    for (int i = 0; i < X; ++i)
\end_layout

\begin_layout Plain Layout

        fftw_execute(p);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    fftw_destroy_plan(p);
\end_layout

\begin_layout Plain Layout

    fftw_free(in), fftw_free(out);
\end_layout

\begin_layout Plain Layout

    return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:fft-alias-program"

\end_inset

C program snippet for computing the Fourier transform of N double precision
 complex numbers X times.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Description
fftw_malloc A wrapper around the standard malloc, returning heap-allocated
 data.
 This is supposed to provide a stronger alignment guarantee than malloc
 does, needed for vectorized code.
 The system's default malloc might not align data on wide enough boundaries,
 although reasonable implementations do.
\end_layout

\begin_layout Description
fftw_plan_dft_1d This creates a 
\emph on
plan
\emph default
 for how to most efficiently compute a discrete fourier transform of size
 
\begin_inset Formula $N$
\end_inset

.
 This step encapsules the auto-tuning part of FFTW, as plans can be constructed
 based on actual measurements and benchmarks done on the current machine.
 Knowledge of well performing plans is stored as 
\emph on
wisdom
\emph default
, which is used to construct other plans later.
\end_layout

\begin_layout Description
fftw_execute Perform the computations specified by the given plan, calculating
 the Fourier tranform of 
\begin_inset Quotes eld
\end_inset

in
\begin_inset Quotes erd
\end_inset

 and writing the result to 
\begin_inset Quotes eld
\end_inset

out
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Subsection
Impact of Stack Position for Small Transforms
\end_layout

\begin_layout Standard
After attempting a couple of different configurations for tranform size
 and iteration count, we find that computing transforms of size 16 have
 noticeable bias to stack position.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Img/fft/default.eps
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:fftw-stack-bias"

\end_inset

Performance counter measurements for computing complex DFT of size 
\begin_inset Formula $N=16$
\end_inset

, repeated 
\begin_inset Formula $X=200{,}000$
\end_inset

 times.
 Address aliasing under some stack offsets negatively impacts cycle count.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:fftw-stack-bias"

\end_inset

 shows the relation between address alias and cycle count for repeated benchmark
s under increasing environment size.
 The same program is run 8192 times, adding one byte to the environment
 between each execution.
 This covers two 4KiB segments of lower order virtual address bits for stack
 position.
 As suspected, we get a graph with the same pattern repeating twice.
 As shown by the cycle count, position of stack significantly impacts performanc
e.
\end_layout

\begin_layout Subsection
Eliminating Bias by Modifying Kernels
\end_layout

\begin_layout Standard
Knowing address aliasing being the cause of bias, we can try to modify FFTW
 to detect and possibly avoid situations with abnormally high cycle count
 from Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:fftw-stack-bias"

\end_inset

.
 
\end_layout

\begin_layout Standard
An overview of what kernels are used to execute a plan can be found by calling
 fftw_print_plan.
 In our case, the plan reads 
\begin_inset Quotes eld
\end_inset

(dft-direct-16 "n1fv_16_avx")
\begin_inset Quotes erd
\end_inset

, specifying that the transform is computed directly by the n1fv_16 kernel,
 compiled with AVX instructions enabled.
 We use Valgrind 
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset CommandInset href
LatexCommand href
name "http://valgrind.org/"
target "http://valgrind.org/"

\end_inset


\end_layout

\end_inset

 to analyze the call graph from fftw_execute, showing a chain of calls eventuall
y leading to the kernel invocation.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Img/fft/callgraph.eps

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Call graph showing the actions taken after calling fftw_execute for the
 16 element transform.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The kernel itself is located in the file dft/simd/common/n1fv_16.c, which
 contains an automatically generated C program for computing a 16 element
 DFT
\begin_inset Foot
status open

\begin_layout Plain Layout
There are actually two separate implementations provided, one specifically
 optimized for architectures supporting fused multiply-add instructions.
 FFTW is compiled with FMA disabled in our case, as there are no such instructio
ns on the Ivy Bridge.
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},breaklines=true,language=C"
inline false
status open

\begin_layout Plain Layout

void n1fv_16(const R *ri, const R *ii, R *ro, R *io, stride is, stride os,
 INT v, INT ivs, INT ovs)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Conflicting memory accesses within 
\family typewriter
n1fv_16
\family default
 are causing bias effects.
 Looking at the generated assembly, we find three areas of memory whose
 address suffixes can potentially overlap.
 
\end_layout

\begin_layout Itemize
Heap allocated input and output buffers, parameters 
\begin_inset Quotes eld
\end_inset


\family typewriter
ri
\family default

\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset


\family typewriter
ro
\family default

\begin_inset Quotes erd
\end_inset

 respectively.
 These are pointers previously returned by calls to 
\family typewriter
fftw_malloc
\family default
, addresses in general unpredictable by the kernel, except for some alignment
 constraints.
\end_layout

\begin_layout Itemize
Stack allocated function parameters and local automatic variables.
 Although the six first arguments reside in registers 
\family typewriter
%rdi
\family default
, 
\family typewriter
%rsi
\family default
, 
\family typewriter
%rdx
\family default
, 
\family typewriter
%rcx
\family default
, 
\family typewriter
%r8
\family default
 and 
\family typewriter
%r9
\family default
, the remaining three are pushed on stack.
 
\end_layout

\begin_layout Itemize
Statically allocated constants in memory.
 Three floating point constants are statically built into the object file,
 their positions in virtual address space will be determined at runtime
 by the dynamic linker.
 
\end_layout

\begin_layout Standard
Under synthetic testing with address randomization (ASLR) disabled, all
 parameters are fixed and deterministic.
 For our particular test, the heap allocated input and output buffers always
 reside in virtual addresses 
\family typewriter
0x602040
\family default
 and 
\family typewriter
0x601c0
\family default
 respectively -- on the low end of a 4K segment of suffixes between 
\family typewriter
0x000
\family default
 and 
\family typewriter
0xfff
\family default
.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Img/fft/collision-random-rsp.eps

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Position of stack can be aligned anywhere within the space of virtual addresses
 
\begin_inset Formula $\bmod$
\end_inset

 
\family typewriter
0x1000
\family default
.
 With ASLR disabled, the last 12 bits of 
\family typewriter
ri
\family default
 and 
\family typewriter
ro
\family default
 are 
\family typewriter
0x040
\family default
 and 
\family typewriter
0x1c0
\family default
 respectively.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The stack pointer at kernel invocation is difficult to observe without introduci
ng observer effects.
 However, it is a fair assumption that address alias happens when stack
 accesses collide with heap addresses, because most memory access instructions
 are either to temporary stack variables or to heap.
 The static constants are loaded initially, using only a few load instructions.
 
\end_layout

\begin_layout Subsubsection*
Adjusting Stack Placement at Runtime
\end_layout

\begin_layout Standard
The position of stack is unknown to the kernel at runtime.
 It can execute with a 
\begin_inset Quotes eld
\end_inset

good
\begin_inset Quotes erd
\end_inset

 configuration with few collisions, or a 
\begin_inset Quotes eld
\end_inset

bad
\begin_inset Quotes erd
\end_inset

 configuration as in one of the periodic peaks illustrated in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:fftw-stack-bias"

\end_inset

.
 Once 
\family typewriter
fftw_execute
\family default
 is called, the only thing we can control is placement of stack allocated
 variables.
 
\end_layout

\begin_layout Standard
An interesting observation is that stack addresses are often specified relative
 to the stack pointer, as opposed to base pointer.
\end_layout

\begin_layout Quote
\begin_inset listings
lstparams "basicstyle={\normalsize\ttfamily},breaklines=true"
inline true
status open

\begin_layout Plain Layout

vmovapd %ymm14, -120(%rsp)
\end_layout

\end_inset


\end_layout

\begin_layout Quote
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},breaklines=true"
inline true
status open

\begin_layout Plain Layout

vaddpd -56(%rsp), %ymm7, %ymm12
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This suggests that merely offseting the rsp register within the 
\family typewriter
n1fv_16
\family default
 kernel itself should impact the placement of local temporary variables.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Img/fft/collision-fixed-rsp.eps

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Collisions can be avoided by reseting the stack pointer to an address that
 does not conflict with the heap allocated pointers.
 With heap allocated ri and ro occupying 
\begin_inset Quotes eld
\end_inset

low
\begin_inset Quotes erd
\end_inset

 addresses, a reasonable placement of stack is in the other side of the
 spectrum, close to 
\family typewriter
0xfff
\family default
 and expanding towards lower addresses.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Looking at the call graph again, we have several options for where to programmat
ically align stack on a suitable address.
 In the end, we found that aligning in 
\family typewriter
apply_extra_iter
\family default
 made the most sense, and also provided a slight gain compared to doing
 it within the kernel itself.
 As the name suggests, this function actually calls the kernel twice.
 
\end_layout

\begin_layout Standard
\noindent
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},breaklines=true"
inline false
status open

\begin_layout Plain Layout

static void apply_extra_iter(const plan *ego_, R *ri, R *ii, R *ro, R *io)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    void *rsp;
\end_layout

\begin_layout Plain Layout

    asm volatile (
\end_layout

\begin_layout Plain Layout

        "movq  %%rsp, %0;"
\end_layout

\begin_layout Plain Layout

        "andq  $-4096, %%rsp;"
\end_layout

\begin_layout Plain Layout

        : "=r"(rsp) : : );
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    (...)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    asm volatile (
\end_layout

\begin_layout Plain Layout

        "movq  %0, %%rsp;"
\end_layout

\begin_layout Plain Layout

        : : "r"(rsp) : );
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:apply-extra-iter"

\end_inset

Modified 
\family typewriter
apply_extra_iter
\family default
, aligning stack to a 4K boundary.
 The hidden function body makes two calls to the 
\family typewriter
n1fv_16
\family default
 kernel.
 Implementation is located in the file 
\family typewriter
dft/direct.c
\family default
.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The andq instruction from Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:apply-extra-iter"

\end_inset

 will zero out the last 12 bits of the 
\family typewriter
%rsp
\family default
 register, effectively subtracting some number between 0 and 4096.
 Recall that the stack grows downwards, thus subtracting any (reasonably
 small) amount will not overwrite other data.
 We run the same benchmark again, results shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:fftw-modified"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Img/fft/modified.eps
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:fftw-modified"

\end_inset

Performance after stack fix is added to apply_extra_iter
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Over two 4K periods, the modified version is much less sensitive to stack
 placement, removing almost all the bias from previously.
 There is a reduction in cycle count for the worst case by 11.8 %, however
 there is no significant speedup on average.
 
\end_layout

\begin_layout Standard
\begin_inset Float table
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="5">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Min
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Median
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Mean
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Max
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Default version
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
30,337,010
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
30,445,740
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
31,051,690
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
37,349,700
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Modified 
\family typewriter
apply_extra_iter
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
30,760,320
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
30,885,300
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
30,947,460
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
32,909,300
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Cycle count statistics over 512 runs, sampling uniformly over two 4KiB periods
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Even though we are able to remove most of the alias effects, performance
 did not improve as much as we had hoped.
 The constant overhead added by inserting the extra instructions in apply_extra_
iter consumes any aliasing improvement.
 About 1 million additional dynamic instructions are added to our example
 in the modified version, an increase of 1.3 %.
\end_layout

\begin_layout Subsubsection*
Creating the Worst Case
\end_layout

\begin_layout Standard
With the static alignment in place, it is not hard to imagine where the
 modified version will fail.
 If input and ouput buffers happen to reside on the opposite of the 4 KiB
 segment, we should see consistently bad performance for all environment
 sizes.
 By allocating another buffer of 7400B using regular malloc before calling
 fftw_malloc, the input and output buffers are pushed to 
\family typewriter
0x604da0
\family default
 and 
\family typewriter
0x604f00
\family default
 respectively.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Img/fft/collision-overlap.eps

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:fftw-worstcase-4k"

\end_inset

Offseting heap addresses to always overlap with fixed stack pointer
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The effects of this forced overlap is illustrated in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:fftw-worstcase"

\end_inset

.
 As expected, we see that a constant number of alias events are added across
 all environment sizes.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Img/fft/worstcase.eps
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:fftw-worstcase"

\end_inset

Bad heap alignment combined with stack fix results in aliasing consistently
 across all environment sizes.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
A Generic Solution
\end_layout

\begin_layout Standard
The static rule of aligning stack to page boundary only works with ASLR
 disabled, and because our fftw_malloc happens to place 
\begin_inset Quotes eld
\end_inset

ri
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

ro
\begin_inset Quotes erd
\end_inset

 close to the lower end of a 4KiB range of address suffixes.
 A hypothetical complete solution would require a function at least these
 three parameters to calculate the optimal stack offset.
\begin_inset Formula 
\[
f\left(\text{ri},\text{ro},\text{\%rsp}\right)\rightarrow\text{offset}
\]

\end_inset


\end_layout

\begin_layout Standard
A plausible solution to the worst case scenario from Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:fftw-worstcase-4k"

\end_inset

 would be to align stack to start at 
\family typewriter
ri
\family default
, no longer overlapping any heap segments.
 However, given the somewhat discouraging results from our simple static
 fix, we did not attempt to implement a function like this for the 
\family typewriter
n1fv_16
\family default
 kernel.
 The added cost of additional dynamic instructions will quickly cancel out
 any speedup we might get.
 
\end_layout

\begin_layout Subsection
Bias in Other Kernels
\end_layout

\begin_layout Standard
So far we have only looked at one particular kernel, although FFTW in fact
 consists of a quite large collection of automatically generated codelets.
 In fact, we find that alias effects are apparent in all kernels we tried,
 a collection of them shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:fftw-kernels"

\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Img/fft/kernels.eps

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:fftw-kernels"

\end_inset

Cycle and alias counts for four additional kernels, for 8, 15, 20 and 32
 element complex DFTs respectively.
 Plot shows 
\begin_inset Formula $N=200{,}000$
\end_inset

 iterations of the kernel, incrementing stack offset between each run, up
 to 4096 bytes.
 Vertical axis is given in millions.
 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Each kernel shows a different pattern, with clear bias towards some stack
 positions that performs noticably better than others.
\end_layout

\begin_layout Subsection
Ways to Account for Address Alias
\end_layout

\begin_layout Standard
The main problem we faced when trying to do anything about aliasing within
 FFTW itself, was that too many dynamic instructions are added in the process.
 The problem is of course that the hack is implemented inside the hot loop,
 where fftw_execute is called repeatedly.
 However, we can also align stack 
\emph on
before
\emph default
 the loop, adding only a neglegtible overhead.
 The relevant parts of our modified main function is shown in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:fftw-stackfix-main"

\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},language=C,showstringspaces=false"
inline false
status open

\begin_layout Plain Layout

    void *rsp;
\end_layout

\begin_layout Plain Layout

    __asm__ volatile (
\end_layout

\begin_layout Plain Layout

        "movq  %%rsp, %0;"
\end_layout

\begin_layout Plain Layout

        "andq  $-4096, %%rsp;"
\end_layout

\begin_layout Plain Layout

        : "=r"(rsp) : : );
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    for (int i = 0; i < X; ++i)
\end_layout

\begin_layout Plain Layout

        fftw_execute(p);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    __asm__ volatile (
\end_layout

\begin_layout Plain Layout

        "movq   %0, %%rsp;"
\end_layout

\begin_layout Plain Layout

        : : "r"(rsp) : );
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:fftw-stackfix-main"

\end_inset

Modified test program with forced stack alignment in main.
 Stack pointer is saved to a temporary variable before aligned to a 4KiB
 boundary, then restored once we are done.
 Only a couple additional instructions are executed, with a significant
 performance increase on average over all environment sizes.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
With ASLR disabled, keeping the heap addresses constant through all runs,
 we are now able to avoid 
\emph on
all
\emph default
 alias effects for the n1fv_16 kernel.
 If we were to plot the results, the graph for cycle count and alias events
 would be completely flat.
 As shown in Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:fftw-stackfix-main"

\end_inset

, the average cycle count is reduced from 31,051,690 to 30,425,240, a speedup
 of 1.02x.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="5">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Min
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Median
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Mean
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Max
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Default
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
30,337,010
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
30,445,740
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
31,051,690
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
37,349,700
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Modified main
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
30,350,120
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
30,427,600
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
30,425,240
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
30,585,470
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:fftw-stackfix-main"

\end_inset

Cycle count statistics over 512 runs, sampling uniformly over two 4KiB stack
 position periods.
 Notice a significant improvement on average with stack alignment in main.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
There is clearly a potential for speedup of FFTW kernels by accounting for
 aliasing in some way.
 However, requiring users of the library to fiddle with the stack before
 calling fftw_execute is not a satifactory solution.
 A more reasonable approach would be to encorporate these ideas in the steps
 performed 
\emph on
prior
\emph default
 to executing a plan.
 
\end_layout

\begin_layout Subsubsection*
Planning for Alias
\end_layout

\begin_layout Standard
A more realistic solution is to give this responsibility to the 
\emph on
planner
\emph default
.
 Note that the heap addresses are already required when computing a plan.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},language=C"
inline false
status open

\begin_layout Plain Layout

fftw_plan_dft_1d(N, in, out, FFTW_FORWARD, FFTW_ESTIMATE);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As we have shown, the optimal stack position for each kernel depends on
 the memory addresses of input and output arrays.
 
\end_layout

\begin_layout Standard
Note that aliasing is still an issue when using a more thorough planner,
 for example using 
\begin_inset listings
lstparams "basicstyle={\small\ttfamily}"
inline true
status open

\begin_layout Plain Layout

FFTW_MEASURE
\end_layout

\end_inset

.
 FFTW then actually measures the performance for different plans empirically,
 optimizing automatically for the underlying hardware.
 This would cancel out bias if the following were true:
\end_layout

\begin_layout Enumerate
Multiple alternative kernels with varying alias characteristcs exists.
\end_layout

\begin_layout Enumerate
The call chain are the same during benchmarking in the planner as when the
 plan is later executed.
 Stack addresses during planning must be the same.
\end_layout

\begin_layout Standard
The planner can not know the stack depth of which a user calls fftw_execute
 with a given plan, thus simply benchmarking multiple alternative implementation
 to find which one does not suffer from bias will not work.
\end_layout

\begin_layout Standard
Realistic alternative: compiler can generate better assembly that checks
 for alias conflict on O3 and -march=native.
\end_layout

\begin_layout Subsubsection*
Allocating Alias-free
\end_layout

\begin_layout Standard
Even though we did not find any apparent heap-heap conflicts, fftw_malloc
 could help by ?
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
BLAS
\end_layout

\begin_layout Standard
Basic Linear Algebra Subroutines (BLAS), is the de-facto standard API for
 high performance linear algebra routines 
\begin_inset Foot
status open

\begin_layout Plain Layout
BLAS (Basic Linear Algebra Subprograms) 
\begin_inset CommandInset href
LatexCommand href
name "http://www.netlib.org/blas/"
target "http://www.netlib.org/blas/"

\end_inset


\end_layout

\end_inset

.
 The functionality is divided into three categories: 
\end_layout

\begin_layout Description
Level
\begin_inset space ~
\end_inset

1 Scalar and vector operations, such as dot product and vector addition.
\end_layout

\begin_layout Description
Level
\begin_inset space ~
\end_inset

2 Matrix-vector operations
\end_layout

\begin_layout Description
Level
\begin_inset space ~
\end_inset

3 Matrix-matrix operations, including the widely applied 
\family typewriter
gemm
\family default
 matrix multiplication.
 
\end_layout

\begin_layout Standard
Many highly optimized implementations of BLAS exists.
 We will look at ATLAS, which similar to FFTW uses automatic tuning to optimize
 for the underlying hardware 
\begin_inset CommandInset citation
LatexCommand cite
key "Whaley:2000:ATLAS"

\end_inset

.
 Specifically vendor tuned implementations also exists, such as MKL from
 Intel.
 
\end_layout

\begin_layout Subsection
Alias Effects in Matrix-Vector Multiplication
\end_layout

\begin_layout Standard
Consider matrix-vector multiplication of the form 
\begin_inset Formula $\boldsymbol{y}=A\boldsymbol{x}$
\end_inset

.
 Let 
\begin_inset Formula $A$
\end_inset

 be of size 
\begin_inset Formula $M\times N$
\end_inset

, where 
\begin_inset Formula $M$
\end_inset

 is the number of rows.
 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\left[\begin{array}{ccccc}
a_{0,0} & a_{0,1} &  &  & a_{0,N}\\
a_{1,0}\\
 &  &  & \ddots\\
a_{M,0} &  &  &  & a_{M,N}
\end{array}\right]\left[\begin{array}{c}
x_{0}\\
x_{1}\\
\vdots\\
\\
x_{N}
\end{array}\right]=\left[\begin{array}{c}
y_{0}\\
y_{1}\\
\vdots\\
y_{M}
\end{array}\right]
\]

\end_inset


\end_layout

\begin_layout Standard
The corresponding BLAS function is the level 2 
\family typewriter
gemv
\family default
 routine, computing the more general matrix-vector product given as 
\begin_inset Formula 
\[
\boldsymbol{y}=\alpha\text{op}\left(A\right)\boldsymbol{x}+\beta\boldsymbol{y}
\]

\end_inset

Here, 
\begin_inset Formula $\alpha$
\end_inset

 and 
\begin_inset Formula $\beta$
\end_inset

 are constants, and 
\begin_inset Formula $\text{op}\left(A\right)$
\end_inset

 is an optional transpose or complex conjugate of the matrix.
 A typical invocation of this routine is shown in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:blas-gemv"

\end_inset

.
 We set 
\begin_inset Formula $\alpha=1$
\end_inset

, 
\begin_inset Formula $\beta=0$
\end_inset

 and 
\begin_inset Formula $\text{op}\left(A\right)=A$
\end_inset

 to reduce the formula to 
\begin_inset Formula $\boldsymbol{y}=A\boldsymbol{x}$
\end_inset

.
 Note that 
\begin_inset Formula $A$
\end_inset

 is declared as 
\begin_inset Quotes eld
\end_inset

CblasColMajor
\begin_inset Quotes erd
\end_inset

, meaning we impose a column major ordering of the data.
 
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},language=C"
inline false
status open

\begin_layout Plain Layout

    const double alpha = 1.0, beta = 0.0;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    double *A = malloc(sizeof(double) * M * N);
\end_layout

\begin_layout Plain Layout

    double *x = malloc(sizeof(double) * N);
\end_layout

\begin_layout Plain Layout

    double *y = malloc(sizeof(double) * M);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    cblas_dgemv(CblasColMajor, 
\end_layout

\begin_layout Plain Layout

        CblasNoTrans,
\end_layout

\begin_layout Plain Layout

        M, N,
\end_layout

\begin_layout Plain Layout

        alpha, 
\end_layout

\begin_layout Plain Layout

        A, M,
\end_layout

\begin_layout Plain Layout

        x, 1, 
\end_layout

\begin_layout Plain Layout

        beta, 
\end_layout

\begin_layout Plain Layout

        y, 1
\end_layout

\begin_layout Plain Layout

    );
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:blas-gemv"

\end_inset

Computing double precision matrix-vector multiplication 
\begin_inset Formula $\boldsymbol{y}=A\boldsymbol{x}$
\end_inset

 using 
\family typewriter
dgemv
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Depending on the virtual heap addresses of 
\begin_inset Formula $A$
\end_inset

, 
\begin_inset Formula $\boldsymbol{x}$
\end_inset

 and 
\begin_inset Formula $\boldsymbol{y}$
\end_inset

, performance of a typical BLAS implementation can vary significantly.
 Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:blas-dgemv-perf"

\end_inset

 shows performance counter statistics for three independent executions with
 
\begin_inset Formula $N=M=8196$
\end_inset

, and varying memory addresses for each heap area.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="5">
<features booktabs="true" tabularvalignment="middle" tabularwidth="100text%">
<column alignment="right" valignment="top" width="20text%">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="15text%">
<column alignment="center" valignment="top" width="15text%">
<row>
<cell alignment="right" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Address of 
\begin_inset Formula $A$
\end_inset

, 
\begin_inset Formula $\boldsymbol{x}$
\end_inset

, 
\begin_inset Formula $\boldsymbol{y}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Cycles
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Address alias
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
L3 cache misses
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
L3 cache references
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x2aaaac292010 0x605010 0x615020
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
194,224,356
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
34,108,038
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6,633
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
15,267
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x2aaaac292010 0x605010 0x6150b0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
186,370,424
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5,723,056
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7,271
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
17,773
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x2aaaac292010 0x6053d0 0x6153e0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
180,791,072
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
37,079
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6,230
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
15,328
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:blas-dgemv-perf"

\end_inset

Performance counter statistics for automatically tuned ATLAS implementation
 of 
\family typewriter
dgemv
\family default
, calculating 
\begin_inset Formula $\boldsymbol{y}=A\boldsymbol{x}$
\end_inset

 with matrix size 
\begin_inset Formula $8192\times8192$
\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
As might be suspected, the worst case configuration is observed when all
 arrays align closely on the last 12 bits.
 Between the best and worst configuration, there is a potential for 1.074x
 speedup.
 We conclude that the most probable cause of bias must be falsely predicted
 dependencies due to address aliasing.
 For the worst case, the number of alias events is about 18 % of cycle count,
 indicating many missed opportunities for out of order execution.
 Supporting this hypothesis, we find no apparent correlation between cycle
 count and cache efficiency.
 The L3 performance counters shown in Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:blas-dgemv-perf"

\end_inset

 shows little variation, and does not explain the performance variations.
 
\end_layout

\begin_layout Standard
The bias effects can be amplified by calling dgemv multiple times in a loop,
 avoiding overhead from malloc.
 With repeated invocations on the same data, we are able to get more than
 1.30x speedup between the worst and best case.
 
\end_layout

\begin_layout Subsection
Dealing With Bias
\end_layout

\begin_layout Standard
Users of BLAS packages are probably more willing to invest in hand optimizing
 hot spots where bias might occur.
 It is not unlikely that one or more matrix-vector operations are part of
 a hot loop.
 Bias from address alias can heavily impact performance, and will probably
 be worth considering in some cases.
 
\end_layout

\begin_layout Standard
For the particular case we investigated, a good heuristic is to alignin
 heap segments 
\begin_inset Quotes eld
\end_inset

far apart
\begin_inset Quotes erd
\end_inset

 within the 4 KiB area of 12 bit suffixes.
 More specifically, it appears that address suffixes of 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $\boldsymbol{y}$
\end_inset

 are the most important to separate.
 A possible run time solution can be realized as follows:
\end_layout

\begin_layout Enumerate
Allocate some extra space for one of the vectors when calling malloc, for
 instance 
\family typewriter
sizeof(double) * (M + 0x100)
\family default
 for 
\begin_inset Formula $\boldsymbol{y}$
\end_inset

.
\end_layout

\begin_layout Enumerate
Check the returned pointers for potential alias, i.e.
 the difference between 
\family typewriter
&A
\family default
 and 
\family typewriter
&y
\family default
.
 Offset using pointer arithmetic into the array with extra padding at the
 end, i.e.
 
\family typewriter
y += 0x100
\family default
.
 
\end_layout

\begin_layout Standard
In many cases it will be possible to accurately predict the address of larger
 matrices such as 
\begin_inset Formula $A$
\end_inset

.
 For larger requests, malloc will call mmap and always align to page boundary.
 Perhaps this can simplify the calculations somewhat.
 
\end_layout

\begin_layout Chapter
Conclusions and Future Work
\end_layout

\begin_layout Standard
Sure this is an easy section.
\end_layout

\begin_layout Section
Contributions
\end_layout

\begin_layout Section
Challenges
\end_layout

\begin_layout Section
Future Work
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "references"
options "bibtotoc,acm"

\end_inset


\end_layout

\begin_layout Chapter
\start_of_appendix
List of Performance Counters
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "chap:list-of-performance-counters"

\end_inset


\end_layout

\begin_layout Standard
\noindent
\begin_inset Float table
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begingroup
\backslash
tabcolsep=3pt
\backslash
begin{small}
\end_layout

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="5">
<features booktabs="true" tabularvalignment="middle" tabularwidth="100text%">
<column alignment="center" valignment="top" width="8text%">
<column alignment="center" valignment="top" width="8text%">
<column alignment="left" valignment="top" width="34text%">
<column alignment="left" valignment="top" width="15text%">
<column alignment="left" valignment="top" width="25text%">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Event num.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Umask value
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Event Mask Mnemonic
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Perf mnemonic
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Description
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x3C
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x00
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
UnHalted Core Cycles
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
cycles
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
3C
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
01
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
UnHalted Reference Cycles
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
bus-cycles
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
C0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
00
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Instruction Retired
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
instructions
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
2E
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
4F
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
LLC Reference
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
cache-references
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Last level cache references
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
2E
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
41
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
LLC Misses
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
cache-misses
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Last level cache misses
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
C4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
00
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Branch Instruction Retired
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
branches
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Branch instruction at retirement
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
C5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
00
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Branch Misses Retired
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
branch-misses
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Mispredicted Branch Instruction at retirement
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{small}
\backslash
endgroup
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:architectural-counters"

\end_inset

Architectural performance counters
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
\begin_inset Float table
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begingroup
\backslash
tabcolsep=3pt
\backslash
begin{small}
\end_layout

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="18" columns="4">
<features booktabs="true" tabularvalignment="middle" tabularwidth="100text%">
<column alignment="center" valignment="top" width="8text%">
<column alignment="center" valignment="top" width="8text%">
<column alignment="left" valignment="top" width="38text%">
<column alignment="left" valignment="top" width="40text%">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Event num.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Umask value
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Event Mask Mnemonic
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Description
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x03
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x02
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
LD_BLOCKS.
 STORE_FORWARD
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Loads blocked by overlapping with store buffer that cannot be forwarded
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x07
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x01
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
LD_BLOCKS_PARTIAL.
 ADDRESS_ALIAS
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
False dependencies in MOB due to partial compare on address
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x20
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x01
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
LSD_OVERFLOW
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Counts number of loops that can't stream from the instruction queue
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
5C
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
01
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CPL_CYCLES.RING0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Unhalted core cycles when the thread is in ring 0
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
5C
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
02
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CPL_CYCLES.RING123
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Unhalted core cycles when the thread is not in ring 0
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
A1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
01
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
UOPS_DISPATCHED_PORT.
 PORT_0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Cycles which a uop is dispatched on port 0
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
A1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
02
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
UOPS_DISPATCHED_PORT.
 PORT_1
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Cycles which a uop is dispatched on port 1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
A1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
0C
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
UOPS_DISPATCHED_PORT.
 PORT_ 2
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Cycles which a uop is dispatched on port 2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
A1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
30
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
UOPS_DISPATCHED_PORT.
 PORT_ 3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Cycles which a uop is dispatched on port 3
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
A1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
40
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
UOPS_DISPATCHED_PORT.
 PORT_ 4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Cycles which a uop is dispatched on port 4
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
A1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
80
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
UOPS_DISPATCHED_PORT.
 PORT_ 5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Cycles which a uop is dispatched on port 5
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
A2 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
01
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
RESOURCE_STALLS.ANY
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Cycles Allocation is stalled due to Resource Related reason
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
A3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
01
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CYCLE_ACTIVITY.
 CYCLES_L2_PENDING
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Cycles with pending L2 miss loads
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
A3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
02
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CYCLE_ACTIVITY.
 CYCLES_LDM_PENDING
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Cycles with pending memory loads
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
A3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
08
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CYCLE_ACTIVITY.
 CYCLES_L1D_PENDING
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Cycles with pending L1 cache miss loads
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
A3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0x
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
04
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CYCLE_ACTIVITY.
 CYCLES_NO_EXECUTE
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Cycles of dispatch stalls
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0xA8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x01
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
LSD.UOPS
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Counts the number of micro-ops delivered by loop stream detector
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{small}
\backslash
endgroup
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:non-architectural-counters"

\end_inset

Interesting non-architectural performance counters
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_body
\end_document
