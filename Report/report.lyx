#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass report
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman lmodern
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 12
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 2
\paperpagestyle headings
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Analyzing Context Bias on Modern Architectures
\end_layout

\begin_layout Author
Lars Kirkholt Melhus
\end_layout

\begin_layout Date
Supervisor: Anne C.
 Elster
\begin_inset Newline newline
\end_inset

Co-supervisor: Rune E.
 Jensen
\end_layout

\begin_layout Quotation
\begin_inset Quotes eld
\end_inset

None really knows what is happening inside the CPU...
 It follows heisenburg uncertainity principle...
 lol..
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Quotation
k_sarnath - Intel forums.
\end_layout

\begin_layout Abstract
Carefully controlling observer effect and measurement bias when conducting
 experiments, is taken very seriously in other scientific fields such as
 medical research.
 These issues are also relevant when doing performance analysis, for instance
 when evaluating the efficiency of some new algorithm or compiler optimization.
 A computer program does not necessarily have the same performance across
 all machines.
 Running the same program multiple times does not always yield the same
 performance either.
 For accurate analysis of performance, it is important to sample a representativ
e set of tests -- this is true also in computer science.
 Seemingly trivial properties of the environment can bias programs towards
 certain configurations -- memory layout being the primary source of variation,
 but other sources such as room temperature and time of day could also be
 considered in the broadest sense.
\end_layout

\begin_layout Abstract
In this thesis we will study a small set of very distinct bias effects,
 that can be experienced by innocuous changes to the Unix environment, or
 changing the link order of a program.
 Through experimentation and careful measurement using hardware performance
 counters, we locate the source of what causes performance deviations.
 We show that environment bias is in fact not completely unpredictable,
 and discuss measures can be made to try to avoid problems caused by bias.
\end_layout

\begin_layout Abstract
Lastly we provide a brief case study on FFTW, and how exploiting knowledge
 of the i7 Ivy Bridge can help bias performance in our favor to yield an
 actual speedup for the oh so important fourier transform (hopefully :)
\end_layout

\begin_layout Section*
Problem Description
\end_layout

\begin_layout Standard
Variations in execution context has been shown to affect performance of
 programs on recent CPUs.
 Previous work has looked at offsetting the stack and changing link order
 -- biasing performance measurements towards certain configurations 
\begin_inset CommandInset citation
LatexCommand cite
key "Mytkowicz:2009:WrongData"

\end_inset

.
 Variables such as the placement of stack, heap and text segments in memory,
 combined with memory access instructions, can impact program performance
 quite significantly.
 
\end_layout

\begin_layout Standard
The goal of this project is to model some of these effects for common use
 cases, and methods for avoiding them, in order to avoiding bias and achieving
 peak performance.
 These effects might be highly platform dependent, so to limit the scope
 we will focus on a particular architecture, the Intel Core i7 "Ivy Bridge".
 Case studies will include small isolated programs, and ideally also "real"
 applications such as FFT algorithms.
\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Chapter
Introduction
\end_layout

\begin_layout Standard
Optimizing for performance generally consist of trying to strive for things
 like reduced cycle count, eliminate branch misses and reduce the number
 of cache misses.
 In disciplines other than computer science, such as medicine, the notions
 of measurement bias and observer effect is more often considered.
 The notions of observation effect and measurement bias can be described
 as follows.
\end_layout

\begin_layout Description
Observer
\begin_inset space ~
\end_inset

effect occurs when the phenomena being measured is changed by observing
 it.
\end_layout

\begin_layout Description
Measurement
\begin_inset space ~
\end_inset

bias refers to the potential for 
\emph on
external
\emph default
 variables to skew the measurements of some phenomena away from the 
\begin_inset Quotes eld
\end_inset

true
\begin_inset Quotes erd
\end_inset

 result.
 
\end_layout

\begin_layout Section
Observer Effect and Measurement Bias
\end_layout

\begin_layout Standard
In an analysis of 70? papers from X conference, almost none took into account
 the effects of observer effects or environment bias, which has been been
 shown to potentially skew the results of benchmarks by very significant
 amounts 
\begin_inset CommandInset citation
LatexCommand cite
key "Mytkowicz:2009:WrongData"

\end_inset

.
 
\end_layout

\begin_layout Standard
Seemingly innocious properties such as the length of your Unix user name
 can bias performance measurements.
 In the paper appropriately named 
\begin_inset Quotes eld
\end_inset

Producing the wrong data without doing anything obviously wrong
\begin_inset Quotes erd
\end_inset

, the authors show how simple changes to the execution environment can heavily
 impact performance of SPEC 2006 benchmark.
 There are many potential sources of bias that could come from the environment.
 In the widest sense, properties like the time of day, or temperature of
 the room should be considered relevant variables of the execution environment.
 This is actually not as far fetched as it may sound -- electronic circuits
 might very well operate more efficiently in lower temperatures, and programs
 we benchmark might use some API to ask for the time of day and execuet
 different code paths dependent on that information.
\end_layout

\begin_layout Standard
Other potential sources of bias include memory layout in virtual address
 space, and the link order of object files.
 These variables have been studied to some extent in previous work, which
 we will revisit in Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Background"

\end_inset

.
 
\end_layout

\begin_layout Standard
This thesis will focus on 
\end_layout

\begin_layout Standard
Producing bad data
\end_layout

\begin_layout Standard
Methodolology
\end_layout

\begin_layout Standard
Observer effect and measurement bias is known, but not handled in papers.
\end_layout

\begin_layout Standard
Papers exploring measurement bias.
 Fancy graphic of memory layout.
 Conclusion that this is an unsolved problem.
 
\end_layout

\begin_layout Standard
Execution environment
\end_layout

\begin_layout Itemize
Environment variables
\end_layout

\begin_layout Itemize
Link order (affecting static area layout and address of global variables)
\end_layout

\begin_layout Itemize
Page sizeof system
\end_layout

\begin_layout Section
Outline
\end_layout

\begin_layout Standard
The purpose of this report is to explore ways to tackle the effects of measureme
nt bias.
 Previous work has focused mostly on ways to eliminate the effects in order
 to produce reliable measurements -- working towards a more statistically
 valid methodology employed in the computer science community.
 Our approach is slightly different.
 If bias could be controlled in certain situations, we could change program
 or environment to enhance performance -- essentially control the bias to
 work in our favor.
 
\end_layout

\begin_layout Description
Chapter
\begin_inset space ~
\end_inset

2 begins by looking at some of the previous work done.
 Most of this is documenting measurement bias.
\end_layout

\begin_layout Description
Chapter
\begin_inset space ~
\end_inset

3 investigates various performance metrics acquired from micro-kernels with
 clear bias.
 We will concentrate on two different causes for effects.
 The first has to with memory address aliasing between variables, that can
 cause problems for the out-of-order scheduling.
 Next we will look at Loop Stream Detector, another hardware optimization
 that sometimes can give bad performance.
\end_layout

\begin_layout Description
Chapter
\begin_inset space ~
\end_inset

4 briefly looks at potential improvements in an actual software package
 where the effects pointed out in Chapter 3 might be a problem.
 
\end_layout

\begin_layout Description
Chapter
\begin_inset space ~
\end_inset

5 summarizes results from previous chapters, and provides directions for
 future work.
 
\end_layout

\begin_layout Chapter
Background and Related Work
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "chap:Background"

\end_inset

In this section we discuss previous work done on measurement bias in computer
 software.
 We will see that the current status for predicting and/or avoiding bias
 effects are to run multiple tests in many different configurations.
 Contributions from T.
 Mytkovicz et al.
 on bias effects for link order and stack address will be discussed, as
 well as other papers with similar observations.
 A paper from Google introduces a framework for assembly-level optimization,
 which tries to avoid some effects that might arise from link order variations.
\end_layout

\begin_layout Section
Measurement Bias in Performance Analysis
\end_layout

\begin_layout Standard
Many possible sources of bias.
 Some that have been studied to some extent are 
\emph on
link order of object files
\emph default
 and the 
\emph on
size of Unix environment
\emph default
.
 It is not entirely clear what variables should be cause of measurement
 bias.
 Bias occurs when some property of the 
\emph on
environment
\emph default
 can skew measurements away from the 
\begin_inset Quotes eld
\end_inset

true
\begin_inset Quotes erd
\end_inset

 result.
 What we are interested in measuring is typically performance of a computer
 program.
 Performance can be represented by various metrics, such as cycle count,
 cache misses or page faults.
 By environment we think of anything that is external to the program, things
 that can (and will) vary from each machine, or between each time measurements
 are made.
\end_layout

\begin_layout Standard
It is clear that the Unix environment should be considered part of the environme
nt for a measurement.
 This is a variable that will typically vary between measurements, at least
 between machine, independent of the program we benchmark.
\end_layout

\begin_layout Standard
Link order is more dubious.
 For the link order to be part of the environment, we might have a program
 that is distributed as object files, and a Makefile with unspecified link
 order, leaving it up to the particular linker implementation on the target
 machine to decide the order.
 
\end_layout

\begin_layout Standard
Definition:
\end_layout

\begin_layout Quote
Any variable that can be changed without changing the program can count
 as measurement bias.
\end_layout

\begin_layout Standard
The kind of variables we should include as possible sources for
\end_layout

\begin_layout Standard
Other, more esoteric variables, might include the time of day, room temperature,
 and 
\end_layout

\begin_layout Standard
Time of day
\end_layout

\begin_layout Standard
Room temperature
\end_layout

\begin_layout Standard
Introduce all papers from Mytkovitz et al.
 
\end_layout

\begin_layout Standard
Idea: Version of shell (bash or sh or tch etc) matters because of environment
 size variable etc)
\end_layout

\begin_layout Subsection
Blind Optimization
\end_layout

\begin_layout Standard
Giving up, treat everything as a black box.
 Use methods from AI to find local minima/maxima 
\begin_inset CommandInset citation
LatexCommand cite
key "Knights:2009:BlindOpt"

\end_inset

.
\end_layout

\begin_layout Section
Architectural Optimization
\end_layout

\begin_layout Standard
Bias effects are hardware dependent -- need to optimize for specific architectur
es.
\end_layout

\begin_layout Standard
Support in GCC and other compilers.
\end_layout

\begin_layout Subsection
Assembly-Level Optimizations
\end_layout

\begin_layout Standard
MAO, paper from Google.
 
\end_layout

\begin_layout Section
Hardware Performance Counters
\end_layout

\begin_layout Standard
To be able to tell anything about bias effects we need to have a reliable
 way to gather various metrics.
 There are many different approaches for measuring performance of software;
 debuggers, profilers and the likes are widely used in both industry and
 academia.
 Unfortunately, measurement techniques relying on intervention from software
 are prone to observer effect.
 In addition, any measurement instrumentation that alters the executed program
 per definition measures a 
\emph on
different
\emph default
 program -- making it difficult to accurately identify bias effects.
\end_layout

\begin_layout Standard
Luckily, modern processors have support in hardware for measuring a plethora
 of different metrics, called performance counters.
 
\end_layout

\begin_layout Subsection
Accuracy of Performance Counters
\end_layout

\begin_layout Standard
Unfortunately, performance counters are not necessarily accurate or predictable.
 Several papers have looked at the relationship between measured counts
 and the 
\begin_inset Quotes eld
\end_inset

right answer
\begin_inset Quotes erd
\end_inset

.
 For certain metrics it is quite easy to verify wether the reported counts
 are accurate.
 One example is the number of retired instructions, for the perf utility
 reported as instructions:u.
 At least for small programs, we can easily count the number of dynamic
 intructions and compare to reported counts.
 
\end_layout

\begin_layout Subsubsection*
Accuracy vs.
 Precision
\end_layout

\begin_layout Standard
For clarity, it is worth pointing out the difference between accuracy and
 precision.
 A series of measurements can be accurate, but not precise, and vice-versa.
 Consider a bow-and-arrow contest after a series of arrows are fired at
 the same target.
 The archer is 
\emph on
accurate
\emph default
 if the arrows land close to the target, and 
\emph on
precise
\emph default
 if the arrows lands close together.
 Note that accuracy does not entail precision, and vice-versa.
\end_layout

\begin_layout Standard
For performance measurements, these are properties of the performance counters.
 Ideally we want counters to be both precise and accurate.
 Many papers have looked at the properties of performance counters, and
 unfortunately very few seems to have the desired properties.
 A counter that appears to be both accurate and precise is INSTR_RETIRED
 -- which can be pretty easily verified by inspecting the source code.
 Measuring the number of cucles accurately seems to be more of a challenge.
 There will always be some overhead in setting up the counters and reading
 the values after the program has run.
 We can try to create an empty program -- but the cycle count reported by
 perf will not be anywhere near zero.
 Trying to measure the 
\begin_inset Quotes eld
\end_inset

empty
\begin_inset Quotes erd
\end_inset

 program yields about 2000 cycles in our setup.
\end_layout

\begin_layout Subsection
Performance Counters in Linux
\end_layout

\begin_layout Standard
The Linux kernel provides an interface to hardware performance counters
 through the perf utility, which we will be using for our measurements.
 
\end_layout

\begin_layout Subsection
Details from Intel Manual
\end_layout

\begin_layout Standard
The current generations of Intel microarchitectures are called, from earliest
 to newest, Sandy Bridge, Ivy Bridge and Haswell.
 In the official documentation on hardware performance monitoring, Ivy Bridge
 is 
\begin_inset Quotes eld
\end_inset

generally the same
\begin_inset Quotes erd
\end_inset

 as described for Sandy Bridge.
 Ref 18.9 in Part 3B.
 
\end_layout

\begin_layout Standard
Another note: Ivy Bridge is 
\begin_inset Quotes eld
\end_inset

3rd generation Core
\begin_inset Quotes erd
\end_inset

, while Haswell is 
\begin_inset Quotes eld
\end_inset

Next generation
\begin_inset Quotes erd
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sandy/Ivy Bridge
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Number of fixed counters per thread
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Number of general-purpose counters per core
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Number of programmable counters per thread
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4 (8 if a core is not shared by two threads)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
PMU (Performance Monitoring Unit) capabilities for 2nd and 3rd generation
 Intel Core microarchitectures (Sandy Bridge and Ivy Bridge).
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Quote from 18.11.5.2
\end_layout

\begin_layout Quote
The performance-monitoring events listed in Chapter 19, “Performance-Monitoring
 Events,” are intended to be used as guides for performance tuning.
 The counter values reported are not guaranteed to be absolutely accurate
 and should be used as a relative guide for tuning.
 Known discrepancies are documented where applicable.
 
\end_layout

\begin_layout Paragraph
Fixed counters
\end_layout

\begin_layout Standard
Can only count one event (?)
\end_layout

\begin_layout Paragraph*
Generic counters
\end_layout

\begin_layout Standard
Can count any event
\end_layout

\begin_layout Standard
In case there are more events than counters, OS will multiplex and perf
 do scaling (inaccurate).
\end_layout

\begin_layout Paragraph
Software events
\end_layout

\begin_layout Standard
Things like context switches.
 (How is this counted?)
\end_layout

\begin_layout Paragraph
Hardware events
\end_layout

\begin_layout Standard
Cycles
\end_layout

\begin_layout Paragraph
PMI
\end_layout

\begin_layout Standard
Performance Monitor Interrupt
\end_layout

\begin_layout Paragraph
At Retirement Events
\end_layout

\begin_layout Standard
At-retirement counting provides a means counting only events that represent
 work committed to architectural state and ignoring work that was performed
 speculatively and later discarded.
 (Quote from 18.11.6)
\end_layout

\begin_layout Standard
Tagging of micro-operations enables counting at retirement.
 Ex from manual: A micro-op can have several cache-misses during execution.
 Tag to get counted only once.
\end_layout

\begin_layout Subsection
Precise Event Based Sampling (PEBS) 
\end_layout

\begin_layout Standard
Same support as Sandy Bridge, with events listed in Table 18-21.
\end_layout

\begin_layout Standard
Allows PMU to collect architectural state and Instruction Pointer (IP) 
\emph on
after
\emph default
 instruction that caused event is completed.
 Only 
\begin_inset Quotes eld
\end_inset

at-retirement
\begin_inset Quotes erd
\end_inset

 events.
 PEBS buffer can contain all general purpose registers + IP for analyzing
 later.
 Used in V-tune.
\end_layout

\begin_layout Standard
Supported in perfmon2 for some version number > x.
 
\end_layout

\begin_layout Standard
Quote from forum post: http://software.intel.com/en-us/forums/topic/277553
\end_layout

\begin_layout Quote
PEBS (Precise Event Based Sampling) is a feature available to a subset of
 events which allows the hardware to collect additionalinformation very
 close to the exact time the configured event overflowed.
 This presents theanalysis tools whith susbstantially more accurate information
 since the alternative is to wait for a software interrupt to collect this
 information, typically hundreds of cycles later.The additional collected
 information are stored in a special PEBS buffer and retrieved by the tool
 (in this case perf_events) later.
\end_layout

\begin_layout Standard
For use in perf: append :pp to event.
 Needs to be used with perf record.
\end_layout

\begin_layout Section
Intel Microarchitecture
\end_layout

\begin_layout Standard
Information in Intel 64 and IA-32 Architectures Optimization Reference Manual.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
Image of memory system, showing MOB etc.
 Might be useful.
\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Intel Core Microarchitecture
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
MOB
\end_layout

\begin_layout Standard
The Intel architecure enables speculative loads and stores based on predictions.
 Separate buffers are used to provide speculative memory operations, and
 instructions are restarted if conflicts are discovered at retirement.
 
\end_layout

\begin_layout Standard
Memory disambiguation: Information in 2.2.4.5.
 Predicts conflict of loads, issue speculatively.
\end_layout

\begin_layout Subsection
Loop Stream Detecor
\end_layout

\begin_layout Standard
Front end optimization.
 Hinted to being a possible source of bias in Google tech talk (reference).
\end_layout

\begin_layout Section
Linux
\end_layout

\begin_layout Standard
The operating system might be cosidered a vital part of the execution environmen
t.
 Running tests on a particular operating system might very well result in
 big performance differences.
 Because of time limitations we have not considered bias effects due to
 specific variations in OS-es, but rather specific variations within the
 execution context provided by the operating system.
 For all our results, we have used the latest stable release of Ubuntu,
 version 12.04, updated with the latest kernel updates.
\end_layout

\begin_layout Standard
To understand why some of the bias effects occur, it is necessary to understand
 some of the low-level aspects of how processes and memory is managed by
 the operating system.
 In particular, we will see that changes to memory layout in virtual address
 space can lead to performance variations.
 
\end_layout

\begin_layout Subsection
Virtual Memory
\end_layout

\begin_layout Standard
Before a program can be run, it needs to be loaded into memory in some way.
 The ELF file includes the path to an interpreter, a program that is responsible
 for loading code and data, setting up a stack, and loading any dependencies.
 Files compiled for execution on a 64 bit Linux platform will point to a
 loader in 
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

/lib64/ld-linux-x86-64.so.2
\end_layout

\end_inset

.
 This file can be a symbolic link to the actual program.
 The loader then places each 
\emph on
allocable
\emph default
 section of the object file in virtual address space.
 The most important sections include the stack, heap, bss, data and text,
 as shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:virtual-address-space"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Img/unix-vm-all.eps

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:virtual-address-space"

\end_inset

Organization of virtual memory on a 64 bit Linux system.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Effectively, only 48 out of 64 available bits are used for addressing.
 The lower 
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

0x0
\end_layout

\end_inset

 through 
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

0x7fff'ffffffff
\end_layout

\end_inset

 is addressable to user programs, i.e.
 the virtual address space.
 The upper segment of addresses 
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

0xffff8000'00000000
\end_layout

\end_inset

 through 
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

0xffffffff'ffffffff
\end_layout

\end_inset

 is reserved for the operating system .
 Note that this leaves a large 
\begin_inset Quotes eld
\end_inset

hole
\begin_inset Quotes erd
\end_inset

 of unused addresses, as current hardware does not support addressing the
 whole 64 bit range 
\begin_inset CommandInset citation
LatexCommand cite
key "Lomont:2012:x64Assembly"

\end_inset

.
\end_layout

\begin_layout Standard
A running process is divided into several sections within the virtual address
 space:
\end_layout

\begin_layout Description
stack Stack frames with parameters and local variables for function calls.
 Allocated starting somewhere around the top address 
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

0x007fff'ffffffff
\end_layout

\end_inset

 and expanding downwards.
 
\end_layout

\begin_layout Description
heap Dynamically allocated memory, allocated above the text and data segments
 and growing upwards as programs request more memory.
 The start of heap is marked by 'brk'.
 A Linux system call to brk will request more memory, extending the current
 limit.
 
\end_layout

\begin_layout Description
bss Uninitialized data.
 This segment occupies no space in the object file, only the size is needed.
 Everything is initialized to zero.
 
\end_layout

\begin_layout Description
data Initialized data, variables that have some assigned value at compile
 time.
 
\end_layout

\begin_layout Description
text Executable binary code.
 This segment is placed at the lower end of virtual address space.
 
\end_layout

\begin_layout Standard
Dynamically loaded libraries are mapped into virtual memory as well.
 They typically end up with high addresses, located relatively close to
 the stack.
 
\end_layout

\begin_layout Subsubsection*
Address Space Layout Randomization (ASLR)
\end_layout

\begin_layout Standard
The process of loading segments to virtual memory is not necessarily determinist
ic.
 If virtual addresses can be known a priori, programs will be more vulnerable
 to buffer overflow attacks 
\begin_inset CommandInset citation
LatexCommand cite
key "Shackham:2004:ASLR"

\end_inset

.
 If an attacker manages to inject malicous code, he can use the known virtual
 addresses to access data or call any function.
 One technique known as 'return to libc' attacks uses this knowledge to
 call functions in the C standard library, which will be loaded in most
 scenarios.
\end_layout

\begin_layout Standard
Address space randomization is a technique employed by the operating system
 to make it more difficult to compromise programs.
 By default, the placement of stack, heap (initial position of brk) and
 location of dynamically linked libraries will vary between each run of
 a program.
 For a controlled execution environment we will need to manually disable
 address randomization in many cases.
 This is done by overwriting the randomize_va_space file.
 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=bash"
inline false
status open

\begin_layout Plain Layout

bash -c 'echo 0 > /proc/sys/kernel/randomize_va_space'
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The default value is 2, indicating full randomization.
 For randomizing only (??), a value of 1 can be written instead.
 We will use zero to disable all randomization, making virtual memory layout
 completely deterministic between each run.
\end_layout

\begin_layout Subsubsection*
Environment Variables
\end_layout

\begin_layout Standard
As pointed out in (??), the size of a user's Unix environment variable can
 affect the placement of stack.
 Environemtn variables are allocated above the stack, pushing the first
 possible stack starting address downwards.
 With ASLR disabled, the initial stack address can be manipulated by manually
 changing environment variables.
\end_layout

\begin_layout Subsection
Memory Context of C Programs
\end_layout

\begin_layout Standard
Recognizing that the location of variables in virtual memory is significant,
 it is useful to have an idea of where data might end up in actual programs.
 The program in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:c-context"

\end_inset

 contains four variables, utilizing both initialized and unitialized data,
 as well as dynamically allocated data on heap and automatic stack allocated
 variables.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},language=C,showstringspaces=false"
inline false
status open

\begin_layout Plain Layout

static int a;      // .bss
\end_layout

\begin_layout Plain Layout

static int b = 42; // .data
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main() {
\end_layout

\begin_layout Plain Layout

    int c = 0; // .stack
\end_layout

\begin_layout Plain Layout

    int *d = malloc(sizeof(int)); // .heap
\end_layout

\begin_layout Plain Layout

    printf("stack: %p
\backslash
nheap: %p
\backslash
nbss: %p
\backslash
ndata: %p
\backslash
n", &c, d, &a, &b);
\end_layout

\begin_layout Plain Layout

    return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:c-context"

\end_inset

Simple C program with data allocated in four different segments of virtual
 memory
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Variable c and d are 
\emph on
automatic
\emph default
 variables
\begin_inset CommandInset citation
LatexCommand cite
key "Kernighan:1988:CProgrammingLanguage"

\end_inset

, which are stack allocated.
 Their run-time address depends on where the stack segment is initialized
 in virtual memory, and can in general not be known ahead of time.
 The address returned by malloc and stored in variable d points to a location
 on the heap.
 The exact address depends on the implementation of malloc, as well as the
 initial position of the heap segment, and is also impossible to predict
 in general.
 Global variables a and b should be placed in bss and data segments respectively.
 Their virtual addresses are determined at compile time, and can be found
 in the ELF object file's symbol table 
\begin_inset CommandInset citation
LatexCommand cite
key "SystemVABI"

\end_inset

.
 
\end_layout

\begin_layout Standard
Executing the same program multiple times with ASLR enabled will yield different
 output for stack and heap addresses.
 Each variation constitutes a different execution context, with potentially
 different performance characteristics.
\end_layout

\begin_layout Standard
The actual memory map from running processes can be obtained by reading
 the file 
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

/proc/$id/maps
\end_layout

\end_inset

 for some process id.
 A sample output from a run of the previous hello world example is shown
 below.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\scriptsize\ttfamily}"
inline false
status open

\begin_layout Plain Layout

00400000-00401000 r-xp 00000000 08:01 161842             /home/lars/Master/Code/
Env/a.out
\end_layout

\begin_layout Plain Layout

00600000-00601000 r--p 00000000 08:01 161842             /home/lars/Master/Code/
Env/a.out
\end_layout

\begin_layout Plain Layout

00601000-00602000 rw-p 00001000 08:01 161842             /home/lars/Master/Code/
Env/a.out
\end_layout

\begin_layout Plain Layout

01027000-01048000 rw-p 00000000 00:00 0                  [heap]
\end_layout

\begin_layout Plain Layout

7f127e493000-7f127e646000 r-xp 00000000 08:01 266366     /lib/x86_64-linux-gnu/l
ibc-2.15.so
\end_layout

\begin_layout Plain Layout

7f127e646000-7f127e845000 ---p 001b3000 08:01 266366     /lib/x86_64-linux-gnu/l
ibc-2.15.so
\end_layout

\begin_layout Plain Layout

7f127e845000-7f127e849000 r--p 001b2000 08:01 266366     /lib/x86_64-linux-gnu/l
ibc-2.15.so
\end_layout

\begin_layout Plain Layout

7f127e849000-7f127e84b000 rw-p 001b6000 08:01 266366     /lib/x86_64-linux-gnu/l
ibc-2.15.so
\end_layout

\begin_layout Plain Layout

7f127e84b000-7f127e850000 rw-p 00000000 00:00 0 
\end_layout

\begin_layout Plain Layout

7f127e850000-7f127e872000 r-xp 00000000 08:01 266346     /lib/x86_64-linux-gnu/l
d-2.15.so
\end_layout

\begin_layout Plain Layout

7f127ea59000-7f127ea5c000 rw-p 00000000 00:00 0 
\end_layout

\begin_layout Plain Layout

7f127ea6f000-7f127ea72000 rw-p 00000000 00:00 0 
\end_layout

\begin_layout Plain Layout

7f127ea72000-7f127ea73000 r--p 00022000 08:01 266346     /lib/x86_64-linux-gnu/l
d-2.15.so
\end_layout

\begin_layout Plain Layout

7f127ea73000-7f127ea75000 rw-p 00023000 08:01 266346     /lib/x86_64-linux-gnu/l
d-2.15.so
\end_layout

\begin_layout Plain Layout

7fff47114000-7fff47135000 rw-p 00000000 00:00 0          [stack]
\end_layout

\begin_layout Plain Layout

7fff471ff000-7fff47200000 r-xp 00000000 00:00 0          [vdso]
\end_layout

\begin_layout Plain Layout

ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0  [vsyscall]
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Sources of Measurement Bias
\end_layout

\begin_layout Standard
Modern microprocessors are extremely complex in design and functionality.
 Some of the features on our Ivy Bridge includes; several layers of cache
 to camouflage slow memory, multiple prefetchers -- able to detect strided
 access patters[ref], 
\emph on
macro fusion[ref]
\emph default
 -- combining simple instructions to one, speculative out-of-order execution,
 complicated branch prediction, just to name a few.
 Optimizing for the common case, these hardware optimizations sometimes
 behaves badly.
 Dispite reasonably good documentation, only Intel knows all the details
 of the inner workings of the processor, leaving us with sort of a black
 box testing.
 In this chapter we will unveil characteristics about two architectural
 features in the Core i7; speculative out-of-order memory operations, and
 the Loop Stream Detector.
 
\end_layout

\begin_layout Section
Partial Address Alias Effects
\end_layout

\begin_layout Standard
In 
\begin_inset Quotes eld
\end_inset

Producing Wrong Data Without Doing Anything Obviously Wrong!
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "Mytkowicz:2009:WrongData"

\end_inset

, the authors present an intriguing little C program with extreme sensitivity
 to environment bias.
 They show that by adding bytes to the Unix environment, the cycle count
 periodically increases by about 33%, and some times by almost 300%.
 Their measurements are done on an older Intel Core 2 architecture, providing
 this an excellent example to start our investigation of the newer Core
 i7 architecture.
 
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily}"
inline false
status open

\begin_layout Plain Layout

static int i = 0, j = 0, k = 0;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main() {
\end_layout

\begin_layout Plain Layout

    int g = 0, inc = 1;
\end_layout

\begin_layout Plain Layout

    for (; g < 65536; g++) {
\end_layout

\begin_layout Plain Layout

        i += inc;
\end_layout

\begin_layout Plain Layout

        j += inc;
\end_layout

\begin_layout Plain Layout

        k += inc;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:loop-micro-kernel"

\end_inset

C code for micro-kernel
\end_layout

\end_inset


\end_layout

\end_inset

The micro-kernel from Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:loop-micro-kernel"

\end_inset

 does in fact show clear bias effects also on the newer architecture.
 We use perf and an automated script to run samples, with increasing environment
 size using a dummy variable.
 The program is compiled using cc and no optimization (-O0).
 The results are plotted for each environment size, incrementing by one
 between each run.
 A very distinct spike can be observed, starting at an offset of 3400? bytes.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Img/loop-alias-cycles.eps
	scale 70

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Cycle count from running the same program with different Unix environment
 size.
 Horizontal axis shows number of bytes added to an empty environment.
 Tests were run with an empty initial environment and address randomization
 disabled, for reproducible results.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Measurement Methodology
\end_layout

\begin_layout Standard
Before going ahead with all the details, it is important to describe the
 methodology used to aquire accurate measurements.
 For many of our examples, we are interested first and foremost in the number
 of cycles retured in user mode during execution.
 We use perf stat to aquire performance counter measurements.
 We make the following configuration to our experimental setup:
\end_layout

\begin_layout Itemize
Unless specified otherwise, address space layout randomization (ASLR) is
 kept disabled.
 This is necessary when testing effects from memory context, and often required
 to make results reproducible.
\end_layout

\begin_layout Itemize
Hyper threading is disabled, ennsuring that only one thread runs simultaneously
 on each core.
 Two threads competing on hardware resources is another potential source
 of bias, which we will not be studying.
 
\end_layout

\begin_layout Itemize
A minimal amount of system load.
\end_layout

\begin_layout Subsection
Analysis of Alias Effects
\end_layout

\begin_layout Standard
How we found out what caused the strange behaviour.
 Correlation for all counters (note, not really all, but should cover interestin
g cases).
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{scriptsize}
\end_layout

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="17" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Performance Counter
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Correlation
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
UnHalted Core Cycles
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
cycles:u
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
UnHalted Reference Cycles
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
bus-cycles:u
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0.9999993516
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
CYCLE_ACTIVITY.CYCLES_LDM_PENDING
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
r02a3:u
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0.9969137483
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
LD_BLOCKS_PARTIAL.ADDRESS_ALIAS
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
r0107:u
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0.9967140166
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
RESOURCE_STALLS.ANY
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
r01a2:u
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0.9965375371
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
task-clock:u
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0.9700350589
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
cpu-clock:u
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0.9699529964
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
CPU_CLK_THREAD_UNHALTED.REF_XCLK
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
r013c:u
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0.960707912
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
CPU_CLK_UNHALTED.THREAD_P
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
r003c:u
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0.960679448
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
CPL_CYCLES.RING123
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
r025c:u
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0.9605066987
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
CYCLE_ACTIVITY.CYCLES_NO_EXECUTE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
r04a3:u
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0.9595685545
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
CYCLE_ACTIVITY.STALLS_L2_PENDING
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
r05a3:u
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
0.9590751052
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
…
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
UOPS_DISPATCHED_PORT.PORT_1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
r02a1:u
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
-0.9590123729
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
UOPS_DISPATCHED_PORT.PORT_0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
r01a1:u
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
-0.9862913345
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
RESOURCE_STALLS.RS
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
r04a2:u
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
-0.9895979962
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{scriptsize}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Performance counters with more than 90% positive or negative correlation
 to cycle count
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Img/loop-alias.eps
	scale 80

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
wat.
 UnHalted Core Cycles.
\begin_inset Newline newline
\end_inset

CYCLE_ACTIVITY.CYCLES_LDM_PENDING
\begin_inset Newline newline
\end_inset

Note: Postscript files should be scaled by 75%.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Used already provided kernel from paper -- no detailed explanation provided,
 other than a reference to certain counters.
\end_layout

\begin_layout Itemize
Developed script to run a large numbe of performance counters on the same
 program under controlled environment.
 With varying stack offset.
\end_layout

\begin_layout Itemize
Calculated correlation between cycle count and all counters to find a subset
 that stood out.
 Observe that schedule pipe0-4 are utilized differently.
 Lots of interesting stuff.
 => Read various intel docs.
\end_layout

\begin_layout Itemize
Hypothesis: address alias is the cause.
 Test by observing address.
\end_layout

\begin_layout Standard
Detailed analysis with a clever drawing showing where the collision is.
 
\end_layout

\begin_layout Subsection
Run-time Solutions to Address Aliasing
\end_layout

\begin_layout Standard
In general, the address of stack variables cannot be determined statically.
 It seems like there are two ways to approack the problem of mitigating
 or avoiding aliasing in practice.
 One approach could be to amploy some clever compile-time heuristics to
 pad variables in some way -- hopefully reducing conflicts without hurting
 performance.
 Another approach would be to do some run-time analysis of the variables
 addresses, and execute alternative code paths once a conflict is found.
 This is in principle a feasible solution.
 In the previous example, we can 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Img/loop-alias-fixed.eps
	scale 80

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
No change to performance based on environment size.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Heap address conflicts
\end_layout

\begin_layout Standard
Dynamic memory allocation can also trigger alias effects.
 Observations:
\end_layout

\begin_layout Standard
Malloc appears to be deterministic, once the ASLR has placed heap start
 address somewhere.
 On x86_64, the heap is typically located around virtual address 0x600000,
 right above program text and data segments (see illustration).
 Some metadata for each allocated area is used to handle free requests etc.
 The pointer returned from malloc seems to be aligned to a single byte,
 meaning returned addresses always end with 0x0.
\end_layout

\begin_layout Standard
For slightly larger requests (how large?), malloc uses mmap, which aligns
 to page size; i.e.
 0x1000.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily}"
inline false
status open

\begin_layout Plain Layout

#define N 0x7ffa // 65536 = 0x10000
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

static int inc = 0;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main(int argc, char **argv)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    int offset  = atoi(argv[1]), i;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    float *a    = malloc(N*sizeof(float));
\end_layout

\begin_layout Plain Layout

    float *fill = malloc(offset*sizeof(float));
\end_layout

\begin_layout Plain Layout

    float *b    = malloc(N*sizeof(float));
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    for (i = 0; i < N; ++i)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        b[i] += inc;
\end_layout

\begin_layout Plain Layout

        b[i]++;
\end_layout

\begin_layout Plain Layout

        b[i]++;
\end_layout

\begin_layout Plain Layout

        b[i]++;
\end_layout

\begin_layout Plain Layout

        b[i]++;
\end_layout

\begin_layout Plain Layout

        a[i]++;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Micro-kernel with a simple loop reading and writing to arrays a and b.
 With the correct input argument, a and b will alias and the cycle count
 noticeably spikes.
 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Internals of malloc
\end_layout

\begin_layout Standard
For the previous example, adding a single byte to the b array, suddently
 malloc will begin using mmap instead of brk after some amount of offset
 (fill array).
 
\end_layout

\begin_layout Standard
brk is a strange system call: It increases the boundary of the data segment,
 by simply pushing the 
\begin_inset Quotes eld
\end_inset

break
\begin_inset Quotes erd
\end_inset

 address upwards.
 Break marks the end of the 
\begin_inset Quotes eld
\end_inset

bss
\begin_inset Quotes erd
\end_inset

 segment -- uninitialized data.
 See man page.
 Is it actually used in malloc? Called only once perhaps?
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Img/heap-step.svg
	scale 30

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Adding a single float causes mmap to be called after a certain amount of
 offset.
 Very weird.
 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
mmap is a posix system call for mapping a file to contiguous memory.
 Using the ANONYMOUS parameter, memory can be mapped without a backing file.
 malloc uses mmap instead of brk for large allocations -- although the rules
 seems kind of complicated.
\end_layout

\begin_layout Subsection
Malloc with Pthreads
\end_layout

\begin_layout Standard
Knowign about the possibility of aliasing with aligned array, we can try
 to come up with plausible scenarios where bias can occur.
 An idea for provoking malloc alignment could be to use threading.
\end_layout

\begin_layout Standard
Pthread malloc is probably another implementation, which does not use the
 low-address heap space.
 The high-addresses, apparantly up to 0x7fff'f0000000, are used in the pthread
 implementation.
 Two threads are allocated with heaps 0x7fff'
\series bold
e8
\series default
000000 and 0x7fff'
\series bold
f0
\series default
000000.
\end_layout

\begin_layout Standard
Plan 2: Allocate enough space on each thread-specific are to fill them,
 causing subsequent calls to allocate on shared area.
 Now, allocate (_, 1, 2) + (_, 3) arrays, with arrays 1 and 2 colliding
 if the allocations happen 1, 3, 2 -- alternatively 1, 2, 3.
 The _ allocation is for eating up 
\begin_inset Quotes eld
\end_inset

local
\begin_inset Quotes erd
\end_inset

 heap.
 The size of the local segment is ? 
\end_layout

\begin_layout Standard
Does not work.
 Multiple threads have their own 
\begin_inset Quotes eld
\end_inset

start
\begin_inset Quotes erd
\end_inset

 heap area -- when it overflows, mmap is used which aligns to 12 bit.
 Multiple threads do allocate different areas dependent on ordering, but
 with mmap alignment, there is not much to about it.
\end_layout

\begin_layout Subsection
Example: Convolution
\end_layout

\begin_layout Standard
To illustrate possible performance problems caused by address aliasing,
 consider the following simple 1D convolution function.
 This function computes the convolution between an input array and a fixed
 kernel, disregarding endpoints for simplicity.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},language=C"
inline false
status open

\begin_layout Plain Layout

static float kernel[5] = {0.1, 0.25, 0.3, 0.25, 0.1};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void convolve(int size, float *input, float *output)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    int i, j;
\end_layout

\begin_layout Plain Layout

    for (i = 2; i < size - 2; ++i)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        output[i] = 0;
\end_layout

\begin_layout Plain Layout

        for (j = 0; j < 5; ++j)
\end_layout

\begin_layout Plain Layout

            output[i] += input[i-2+j] * kernel[j];
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We use malloc to allocate two reasonably sized arrays (N = 0x100000), skipping
 initialization to save some cycles.
 Recall that for large allocation, mmap is likely used internally for malloc,
 meaning that input and output are most likely initialized to zero.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},language=C"
inline false
status open

\begin_layout Plain Layout

int main(void) {
\end_layout

\begin_layout Plain Layout

    float *input  = malloc(N*sizeof(float));
\end_layout

\begin_layout Plain Layout

    float *result = malloc(N*sizeof(float));
\end_layout

\begin_layout Plain Layout

    convolve(N, input, result);
\end_layout

\begin_layout Plain Layout

    return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We use the perf utility to measure number of cycles, PARTIAL_ADDRESS_ALIAS
 and RESOURCE_STALLS.ALL.
 The program was compiled with GCC and optimization O3.
 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\scriptsize}"
inline false
status open

\begin_layout Plain Layout

        12,391,475 cycles:u                  #    0.000 GHz             
         ( +-  1.06% )
\end_layout

\begin_layout Plain Layout

         9,039,041 r0107:u                                             
          ( +-  0.79% )
\end_layout

\begin_layout Plain Layout

         7,931,308 r01a2:u                                             
          ( +-  0.17% )
\end_layout

\begin_layout Plain Layout

        11,163,873 instructions:u            #    0.90  insns per cycle 
         ( +-  0.00% )
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

       0.004906424 seconds time elapsed                                 
         ( +-  1.33% )
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As suspected, the code generates a huge number of address alias conflicts
 and resource stalls.
 For moderately large allocations, the input and output arrays will 
\emph on
always
\emph default
 be aligned to 12 bits.
 The likely cause of alias problems here is a conflict between input[i]
 and output[i].
 Although distinct memory locations, the out of order memory system detects
 conflicts.
 The hypothesis can be tested by offseting one of the arrays before calling
 convolve.
 We allocate some extra space for output, and use pointer arithmetic to
 offset the buffer sent to convolve.
 Offset is defined using a compile directive, adding no overhead in the
 generated source.
 The impact of a constant addition of allocated space is neglegtible.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},language=C"
inline false
status open

\begin_layout Plain Layout

    float *result = malloc((N + 0x100)*sizeof(float));
\end_layout

\begin_layout Plain Layout

    convolve(N, input, (result + OFFSET));
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="8">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
x
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x01
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x04
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x08
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x0c
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x10
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x14
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-O0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Not very interesting, but some savings from offseting a little.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-O1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-O2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-O3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Performance statistics for 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=C"
inline true
status open

\begin_layout Plain Layout

convolve(input, (result + x), N)
\end_layout

\end_inset

, with varying offset x, and array size N of 0xffff.
 Measured using 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=C"
inline true
status open

\begin_layout Plain Layout

perf stat -e r0107:u -r 10
\end_layout

\end_inset

, counting number of partial address alias events averaged over 10 runs.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
TODO: Might want graph to visualize number of address alias per offset and/or
 cycles.
\end_layout

\begin_layout Standard
The best parameter is found to be at a 16 element difference in alignment
 between input and output.
 Adding 0x10 to the output pointer (allocating some extra space to compensate),
 we get much faster code.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small}"
inline false
status open

\begin_layout Plain Layout

         5,719,361 cycles:u                  #    0.000 GHz             
         ( +-  1.30% )
\end_layout

\begin_layout Plain Layout

             1,094 r0107:u                                             
          ( +-  2.19% )
\end_layout

\begin_layout Plain Layout

         1,351,256 r01a2:u                                             
          ( +-  1.43% )
\end_layout

\begin_layout Plain Layout

        11,163,873 instructions:u            #    1.95  insns per cycle 
         ( +-  0.00% )
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

       0.002919409 seconds time elapsed                                 
         ( +-  1.03% )
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that the number of alias conflicts reduces with increasing offset.
 This is likely because adjacent indeces are accessed in the loop.
 If output is offset by 0x01, then output[i] is aliased with input[i-1].
 Intuitively, one could suspect that an offset of 3 floats would be enough
 to eliminate alias, as the maximum difference is 2.
 (Is this true for low optimization?) We find that as many as 16 is needed
 on the highest level of optimization, illustrating the depth of speculative
 execution of memory operations.
 
\end_layout

\begin_layout Standard
Interestingly, neither O1, O2 or O3 was able to do anything about this --
 yet a very simple change with no obvious significance gave a speedup of
 over 1.4x.
 
\end_layout

\begin_layout Paragraph
Architectural Optimization Flags
\end_layout

\begin_layout Standard
Because address aliasing is an artifact of intricacies in the Intel Core
 architecture, we could hope that GCC will help when provided this information.
 In the documentation
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset CommandInset href
LatexCommand href
name "http://gcc.gnu.org/onlinedocs/gcc-4.6.3/gcc/i386-and-x86_002d64-Options.html"
target "http://gcc.gnu.org/onlinedocs/gcc-4.6.3/gcc/i386-and-x86_002d64-Options.html#i386-and-x86_002d64-Options"

\end_inset


\end_layout

\end_inset

 we find four possible architecture specifications; 
\emph on
native
\emph default
, 
\emph on
core2
\emph default
, 
\emph on
corei7
\emph default
 and 
\emph on
corei7-avx
\emph default
.
 Native seems to produce code equivalent to corei7-avx.
 Using the -march=native flag does indeed prodice better code, but not as
 efficient as offseting arrays manually and not specifying any particular
 architecture.
 Note that code compiled with these flags are not guaranteed to work on
 other architectures, reducing portability.
\end_layout

\begin_layout Paragraph
Use of restrict
\end_layout

\begin_layout Standard
We can provide additional information to the compiler's optimizer by using
 the restrict keyword for the input and output arrays.
 This keyword was added in the C99 standard.
 It functions as a type qualifier for pointers, specifying that no pointer
 aliases exists.
 By marking input and output as restrict, we guarantee they are the only
 pointers to their respective memory areas, and not accesses through any
 other (aliased) pointers.
 This results in much more efficient code.
 We find that the following compile parameters for cc provide the best code.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small}"
inline false
status open

\begin_layout Plain Layout

cc -O3 -std=c99 -march=native
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We see that the cycle count is drastically reduced, down to about 3.5 million.
 However, we still have over 1 million resource stalls, and 250 thousand
 alias events, which might indicate that even providing restrict is not
 enough.
 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small}"
inline false
status open

\begin_layout Plain Layout

         3,565,704 cycles:u                  #    0.000 GHz             
         ( +-  0.20% )
\end_layout

\begin_layout Plain Layout

           258,469 r0107:u                                             
          ( +-  0.05% )
\end_layout

\begin_layout Plain Layout

         1,065,207 r01a2:u                                             
          ( +-  0.59% )
\end_layout

\begin_layout Plain Layout

         3,299,634 instructions:u            #    0.93  insns per cycle 
         ( +-  0.00% )
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

       0.002281839 seconds time elapsed                                 
         ( +-  0.76% )
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Again, we test the hypothesis by incrementing an offset to the ouput pointer
 before calling convolve.
 At 0x30, we find the optimal configuration.
 We reduce the number of alias effects to a neglegtible amount, and numberof
 resource stalls is cut in half.
 Even with every opportunity for optimization given to the compiler, we
 are still able to squeeze out a speedup of 1.16x just by changing memory
 addresses.
 This speedup is consistent through input sizes, similar for 0x1000000.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small}"
inline false
status open

\begin_layout Plain Layout

         3,070,418 cycles:u                  #    0.000 GHz             
         ( +-  0.32% )
\end_layout

\begin_layout Plain Layout

               206 r0107:u                                             
          ( +- 27.26% )
\end_layout

\begin_layout Plain Layout

           580,203 r01a2:u                                             
          ( +-  1.82% )
\end_layout

\begin_layout Plain Layout

         3,299,634 instructions:u            #    1.07  insns per cycle 
         ( +-  0.00% )
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

       0.002118936 seconds time elapsed                                 
         ( +-  0.67% )
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that the resulting binaries, providing no offset and offset of 0x30,
 were checked with 'diff'.
 They only differ in two lines in main, where a leaq is used instead of
 move (for addition), and different register for another movq instruction.
\end_layout

\begin_layout Paragraph
Other Compilers
\end_layout

\begin_layout Standard
The alias effects on this particular example is most prominent on GNU's
 cc.
 We have tested on clang and icc as well -- with varying results.
 
\end_layout

\begin_layout Description
clang behaves similar to cc with respect to offsets to minimize alias.
 However, we only need to add 0x10 to get rid of aliasing.
 The change in cycle count is not as clear (Need more controlled benchmark).
 A lot less efficient code is generated, almost ten times as many dynamic
 instructions executed.
\end_layout

\begin_layout Description
icc produces code that performs reasonably well with respect to alias count
 on no additional offset.
 Interestingly, a very similar count of address alias events are recorded
 for code compiled with cc, about 260,000 for N = 0x100000.
 Alias can be eliminated almost completely, but that requires an offset
 of 0xa0.
 Performance actually worsenes with smaller offsets, increasing alias count
 significantly.
\end_layout

\begin_layout Subsection
Libraries as Environment Bias
\end_layout

\begin_layout Standard
The previous example does not show measurement bias per se, but rather an
 artifact of the particular implementation of malloc.
 A perfectly legal implementation of malloc could insert offsets on every
 other large request.
 Bottom line is: dynamically linked libraries are part of the execution
 environment.
 
\end_layout

\begin_layout Standard
In the case of memory allocators alone, there are several options: The one
 used in GNU's libc is 
\series bold
ptmalloc
\series default

\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset CommandInset href
LatexCommand href
name "http://www.malloc.de/en/"
target "http://www.malloc.de/en/"

\end_inset


\end_layout

\end_inset

, which is based on Doug Lea's malloc
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset CommandInset href
LatexCommand href
name "http://g.oswego.edu/dl/html/malloc.html"
target "http://g.oswego.edu/dl/html/malloc.html"

\end_inset


\end_layout

\end_inset

, Hoard
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset CommandInset href
LatexCommand href
name "http://www.hoard.org/"
target "http://www.hoard.org/"

\end_inset


\end_layout

\end_inset

, nedmalloc 
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset CommandInset href
LatexCommand href
name "http://www.nedprod.com/programs/portable/nedmalloc/"
target "http://www.nedprod.com/programs/portable/nedmalloc/"

\end_inset


\end_layout

\end_inset

 and tcmalloc
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset CommandInset href
LatexCommand href
name "http://google-perftools.googlecode.com/svn/trunk/doc/tcmalloc.html"
target "http://google-perftools.googlecode.com/svn/trunk/doc/tcmalloc.html"

\end_inset


\end_layout

\end_inset

.
 Many allocators try to battle lock contention for multithreaded programs,
 where each thread share a common heap space.
 Allocating and freeing dynamic memory from a shared pool must be synchronized
 in some way.
 Testing multiple allocators might be worthwile, particularly for multithreaded
 applications.
 A potential cause of producing 
\begin_inset Quotes eld
\end_inset

bad data
\begin_inset Quotes erd
\end_inset

 is optimizing around a bad allocator, or one that perform sub-optimally
 on a particular usage pattern.
\end_layout

\begin_layout Standard
Need some measurements to support this claim ...
 Pretty easy to test malloc replacements, just change LD_PRELOAD apparently.
 Question: Does any of the implementations of malloc optimize for parallell
 sequential array access, reducing alias effects? Probably not, which is
 cool! Could suggest fix.
 (Heuristic, or static analysis, etc).
\end_layout

\begin_layout Description
Hoard Same behaviour on large allocations.
 Returned addresses always ends in 0x070.
 Significantly larger cycle count, but same number of address alias events.
 Could not compile from source, linked with dynamic library.
\end_layout

\begin_layout Description
nedmalloc Did not compile -- no prebuilt binary.
\end_layout

\begin_layout Description
tcmalloc Aligns at page boundary, ending in 0x000.
 Uses low addresses, 0xa49000 etc.
 Returns page-aligned areas for smaller allocations as well -- possible
 environment bias.
\end_layout

\begin_layout Standard
We did some testing with three of the libraries, allocating two arrays of
 equal length for different sizes.
 The libraries produce very different results.
 The default implementation alternates between using the brk segment (low
 addresses and non-aligned, and mmap on higher segments.
 Tcmalloc tends to put variables on page boundaries, also for small sizes,
 returning addresses ending in 0x000.
 Hoard tends to align on page boundaries for larger requests, with addresses
 ending in 0x070.
 
\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="9" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Size
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Default (libc)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
tcmalloc
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Hoard
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="3" alignment="left" valignment="middle" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0xf00
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x603010
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x695
\series bold
000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x2aaaac000070
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x606c20
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x699
\series bold
000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x2aaaac004000
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="3" alignment="left" valignment="middle" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x1234
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x603010
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x69d
\series bold
000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x2aaaac010070
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x6078f0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x6a2
\series bold
000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x2aaaac014d38
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="3" alignment="left" valignment="middle" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0xffff
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x2aaaaaad1
\series bold
010
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x6a7
\series bold
000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x2aaaac020
\series bold
070
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x2aaaaab12
\series bold
010
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x6e7
\series bold
000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x2aaaac070
\series bold
070
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="3" alignment="left" valignment="middle" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x10000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x603010
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x6a7
\series bold
000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x2aaaac020
\series bold
070
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x643020
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x6e7
\series bold
000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x2aaaac070
\series bold
070
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:malloc-impl-tuples"

\end_inset

Addresses returned when allocating two float arrays of the same size, examples
 of possible sources for alias conflicts.
 Tests were run with ASLR disabled for reproducible results, but we get
 similar results with randomization enabled.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:malloc-impl-tuples"

\end_inset

 shows that potential for address alias conflicts depends on the particular
 implementation of malloc used.
 We see several examples of cases where switching library can eliminate
 alias by changing suffix on pointers.
 Note that tcmalloc aligns to page boundary in all cases.
 
\end_layout

\begin_layout Standard
Most allocators focus on efficiency in a multithreaded environment, and
 we find that none of the alternatives tested attempts to solve the aliasing
 problem for aligned arrays.
\end_layout

\begin_layout Section
Loop Stream Detector
\end_layout

\begin_layout Standard
The Loop Stream Detector (LSD) is a front-end hardware optimization introduced
 in the intel Core microarchitecture.
 Measuring the utilization of LSD is supported by the LSD.UOPS performance
 counter.
 Note that this counter is not listed in Table 19-5.
\end_layout

\begin_layout Standard
The requirements for a loop to fit into the LSD cache is stated in the manual
 as the following:
\end_layout

\begin_layout Itemize
Up to eight chunk fetches of 32 (0x20) instruction-bytes (0x100).
 Online docs for 32 nm i7 states four 16-byte fetches.
\end_layout

\begin_layout Itemize
Up to 28 micro-ops (~28 instructions).
 For Ivy Bridge with HT disabled, each core gets 56 entries in micro-op
 queue.
 
\end_layout

\begin_layout Itemize
All micro-ops are also resident in the Decoded ICache.
\end_layout

\begin_layout Itemize
Can contain no more than eight taken branches and none of them can be a
 CALL or RET.
 Online docs for 32 nm i7 states 4 branches.
\end_layout

\begin_layout Itemize
Cannot have mismatched stack operations.
 For example, more PUSH than POP instructions.
 
\end_layout

\begin_layout Itemize
Loops should have at least 64 iterations.
\end_layout

\begin_layout Subsection
Experiments
\end_layout

\begin_layout Standard
Creating simple loops and compiling with gcc.
 Binary is inspected to check what instructions are executed, and their
 address layout.
 
\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="left" valignment="top" width="50text%">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
HT off
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
HT on
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Comment
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Chunk fetches
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Executed chunks of instruction addresses must fit in at most 12 chunks aligned
 to 0x20 (32 byte).
 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Micro-ops
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
56
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
28
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Overflows after 52 addl 0x1 instructions.
 4 extra instructions for text/compare as well, before the jump instruction.
 56 entries seems to be correct for Ivy Bridge as well as Sandy Bridge.
\end_layout

\begin_layout Plain Layout
With HT on, the LSD_OVERFLOW counter becomes non-zero on 27 instructions,
 then zero on 28, and nonzero from there.
 28 is probably the right value -- half of 56.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Taken branches
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
17 (+1)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Handles up to 17 branches (+1 for loop) with a single statement 
\begin_inset Quotes eld
\end_inset

a++, b++
\begin_inset Quotes erd
\end_inset

.
 Triggers LSD_OVERFLOW event.
\end_layout

\begin_layout Plain Layout
Some weird things with HT on, but it seems like 12 is right.
 Might be too many instructions though..
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Experimental LSD properties of i7 Ivy Bridge
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Chunk Fetches
\end_layout

\begin_layout Standard
The stated limit of 8*32B of instructions is way too much for consecutive
 live loop statements.
 To test this limit we have to space out the executed instructions with
 lots of branches.
 In the following program, the macro expands to 9*3B of mov instructions.
 The cmp and jump instructions generated by the branch makes up another
 5 bytes, making every statement a total of 32B.
 Every branch is not taken -- thus the instructions actually executed in
 each iteration is just the compare and branch.
 
\end_layout

\begin_layout Standard
\noindent
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},showstringspaces=false"
inline false
status open

\begin_layout Plain Layout

#define B27 a=b,a=b,a=b,a=b,a=b,a=b,a=b,a=b,a=b
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int loop() {
\end_layout

\begin_layout Plain Layout

    register int i = 0, a = 1, b = 1;
\end_layout

\begin_layout Plain Layout

    while (i++ < 0x12345678) {
\end_layout

\begin_layout Plain Layout

        if (a != b) B27;
\end_layout

\begin_layout Plain Layout

        if (a != b) B27;
\end_layout

\begin_layout Plain Layout

        if (a != b) B27;
\end_layout

\begin_layout Plain Layout

        if (a != b) B27;
\end_layout

\begin_layout Plain Layout

        if (a != b) B27;
\end_layout

\begin_layout Plain Layout

        if (a != b) B27;
\end_layout

\begin_layout Plain Layout

        if (a != b) B27;
\end_layout

\begin_layout Plain Layout

        if (a != b) B27;
\end_layout

\begin_layout Plain Layout

        if (a != b) B27;
\end_layout

\begin_layout Plain Layout

        if (a != b) B27;
\end_layout

\begin_layout Plain Layout

        if (a != b) B27;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    return i;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main() {
\end_layout

\begin_layout Plain Layout

    loop();
\end_layout

\begin_layout Plain Layout

    return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Loop spanning up to 13 chunks of 32 bytes when compiled with gcc -O0.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Compiling this using gcc and no optimization, we see that the loop stream
 detector is not applied to this loop.
 The address of the first instruction is 0x4004d3, and the last 0x400643.
 If instructions are buffered in chunks of 32B, then chunks must be a multiple
 of 0x20.
 The first instruction is pretty far into the 0x4004
\series bold
c0
\series default
 chunk, while the last instruction is just inside the 0x4006
\series bold
40
\series default
 chunk.
 A total of 13 chunks of 32 bytes is executed -- apparently too much for
 the LSD.
 We use the perf utility to measure total number of un-halted cycles, as
 well as the LSD_OVERFLOW and LSD_UOPS events.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily}"
inline false
status open

\begin_layout Plain Layout

     7,640,342,761 cycles:u                  #    0.000 GHz             
       
\end_layout

\begin_layout Plain Layout

                 0 r0120:u                                             
        
\end_layout

\begin_layout Plain Layout

            10,974 r01a8:u                                             
        
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

       2.249628298 seconds time elapsed
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Observe that by carefully aligning the first instruction, we can fit the
 code into only 12 instruction chunks.
 By inserting 13 nop instruction in the assembly code before the loop, addresses
 of the first and last instructions are offset to, respectively, 0x4004e0
 and 0x400650.
 0xe0 is at the very beginning of a chunk, and 0x50 leaves room for another
 16 bytes (6 of which are occupied by the very last jump instruction).
 Running the same program with these 13 nop instructions results in a dramatic
 improvement in performance.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily}"
inline false
status open

\begin_layout Plain Layout

     3,669,478,538 cycles:u                  #    0.000 GHz             
       
\end_layout

\begin_layout Plain Layout

                 0 r0120:u                                             
        
\end_layout

\begin_layout Plain Layout

     4,579,426,057 r01a8:u                                             
        
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

       1.080381834 seconds time elapsed
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To further strengthen the hypothesis that twelve 32B chunks is the limit,
 we can add another 10 bytes at the very end of the loop and get similar
 results.
 With 11 extra bytes -- spilling instructions over to the next chunk --
 LSD_UOPS is back at 11k.
 
\end_layout

\begin_layout Paragraph
Hyper-threading
\end_layout

\begin_layout Standard
Experiments were repeated with hyperthreading turned on -- and we got the
 same results.
 It seems like HT does not affect the chunk fetch limit of the LSD.
\end_layout

\begin_layout Subsection
Optimization
\end_layout

\begin_layout Standard
\begin_inset Quotes eld
\end_inset

These results are irrelevant, any sensible compiler will fix it when using
 optimizations
\begin_inset Quotes erd
\end_inset

, you might say.
 Interestingly, this is not the case -- with a few modifications we can
 produce the exact same effects on gcc with -O3.
\end_layout

\begin_layout Standard
align-loops option in gcc (which is enabled by default in O2 and O3) does
 in fact align loops -- by inserting 
\begin_inset Quotes eld
\end_inset

.palign x,y,z
\begin_inset Quotes erd
\end_inset

 directives into the assembly.
 In front of the first loop instruction, the following assembly directives
 are printed.
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily}"
inline false
status open

\begin_layout Plain Layout

.p2align 4,,10
\end_layout

\begin_layout Plain Layout

.p2align 3
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The first directive tries to align to four bits, inserting at most 10 bytes
 for padding.
 If that does not work, the next directive forces loops to be aligned to
 three bytes -- meaning addresses ends in 0x0 or 0x8.
 Within a 32B instruction block, the first loop instruction can end up having
 one of the four suffixes 0x00, 0x08, 0x10 or 0x18.
 Using this knowledge, we can construct another example that overflows the
 12 blocks for certain alignment.
 
\end_layout

\begin_layout Standard
\noindent
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "49col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
fact.c
\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\scriptsize\ttfamily}"
inline false
status open

\begin_layout Plain Layout

int fact(int n)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    int a = 1;
\end_layout

\begin_layout Plain Layout

    return a;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
lsd.c
\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\scriptsize\ttfamily}"
inline false
status open

\begin_layout Plain Layout

#include <stdio.h>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    int i = loop(10);
\end_layout

\begin_layout Plain Layout

    int f = fact(10);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    printf("Loop: %d
\backslash
n", i);
\end_layout

\begin_layout Plain Layout

    printf("Fact: %d
\backslash
n", f);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "50col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
loop.c
\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\scriptsize\ttfamily}"
inline false
status open

\begin_layout Plain Layout

#define B22(n) b += i*i*a + 1
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

volatile int i = 42;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int loop(int a)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    register int b = i == 42 ? 1 : 0;
\end_layout

\begin_layout Plain Layout

    do {
\end_layout

\begin_layout Plain Layout

        if (!i) B22(1);
\end_layout

\begin_layout Plain Layout

        if (!i) B22(2);
\end_layout

\begin_layout Plain Layout

        if (!i) B22(3);
\end_layout

\begin_layout Plain Layout

        if (!i) B22(4);
\end_layout

\begin_layout Plain Layout

        if (!i) B22(5);
\end_layout

\begin_layout Plain Layout

        if (!i) B22(6);
\end_layout

\begin_layout Plain Layout

        if (!i) B22(7);
\end_layout

\begin_layout Plain Layout

        if (!i) B22(8);
\end_layout

\begin_layout Plain Layout

        if (!i) B22(9);
\end_layout

\begin_layout Plain Layout

        if (!i) B22(10);
\end_layout

\begin_layout Plain Layout

        if (!i) B22(11);
\end_layout

\begin_layout Plain Layout

   } while (i++ < 0x12345678);
\end_layout

\begin_layout Plain Layout

    return b;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Compiling these using two different link orders yields the same speedup
 of 2x for the one with fact.c linked before loop.c.
 
\end_layout

\begin_layout Subsection
Bias effects from trivial source code changes
\end_layout

\begin_layout Standard
If we consider link order to be a possible source of bias, then what about
 other seemingly trivial changes to the program source itself? Keeping in
 mind that alignment and memory address of instructions can have huge impacts
 on performance -- in what ways can this be altered?
\end_layout

\begin_layout Standard
Useful commands for analysing binary files: 
\end_layout

\begin_layout Standard
ldd a.out : Print shared library dependencies
\end_layout

\begin_layout Standard
nm (-u) a.out : List symbols
\end_layout

\begin_layout Standard
readelf -a a.out : List ELF info
\end_layout

\begin_layout Standard
objdump -D a.out : Disassemble
\end_layout

\begin_layout Standard
strip a.out : Removes .symtab and .strtab.
 See thread for more info: http://stackoverflow.com/questions/9401217/is-the-elf-
notes-section-really-needed
\end_layout

\begin_layout Standard
elfedit: GNU utility to edit some fields.
 Very limited properties, doesn't look like arbitrary big strings can be
 inserted.
\end_layout

\begin_layout Standard
ht: Downloaded and built from source.
 Too complex :p
\end_layout

\begin_layout Standard
patchelf: Works for changing dynamic linker.
 Nice explanation on homepage.
 
\end_layout

\begin_layout Subsubsection*
The order of functions within a source file
\end_layout

\begin_layout Standard
Given a program with functions foo and bar, listing foo before bar and vice
 versa generates two 
\begin_inset Quotes eld
\end_inset

different
\begin_inset Quotes erd
\end_inset

 programs given that equality is based on absolute memory layout.
 Gcc prints functions to the text segment in the order they appear in the
 source code.
\end_layout

\begin_layout Paragraph*
Long function names
\end_layout

\begin_layout Standard
Function names are placed in the .strtab section in the ELF file.
 When running readelf or objdump, the names are used to print nice output.
 However, function names of external symbols resolved at run-time does affect
 code layout.
 Longer function names (or more external dependencies) will offset the text
 segment because of allocable segments related to dynamic linking is placed
 before text.
 This includes dynsym, dynstr, gnu.version and rela sections in an executable
 made with GCC.
\end_layout

\begin_layout Paragraph
Using strip
\end_layout

\begin_layout Standard
Various sections of the ELF binary is not necessarily needed for normal
 execution.
 Quite a lot of extra information is included to aid in debugging etc.
 The strip command gets rid of symbol table and stringtable.
 These sections are non-allocable, so itdoes not affect code layout.
 Printing with objdump for example will not be as nice.
 Text segment is not marked with functions (internally resolved symbols).
 
\end_layout

\begin_layout Standard
It is possible to specify specific segments to remove using the -R parameter.
 Removing the .note sections for example, will probably not prevent the program
 from running correctly.
 Even though they are located (and allocated) before the .text segment, stripping
 them out will not offset code.
 This makes sense, as any reordering would require offseting every jump
 address accordingly.
\end_layout

\begin_layout Subsubsection*
Changing Interpreter
\end_layout

\begin_layout Standard
In principle, anything that can change the memory layout of the code or
 data in a program can cause bias.
 Looking at the ELF file generated with cc, we find several segments that
 preceeds .text, where code is.
 By altering the size of any of thezse increasing the size of 
\end_layout

\begin_layout Standard
Details for each of the ELF sections on GNU platform can be found in the
 man pages 
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset CommandInset href
LatexCommand href
name "http://linux.die.net/man/5/elf"
target "http://linux.die.net/man/5/elf"

\end_inset


\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
TODO: Create example with injecting loader triggers lsd.
\end_layout

\begin_layout Description
.interp ELF interpreter/linker to be loaded.
 Default on our system is 
\begin_inset Quotes eld
\end_inset

/lib64/ld-linux-x86-64.so.2
\begin_inset Quotes erd
\end_inset

.
 This can indeed vary, and there are tools for changing interpreter in compiled
 binaries (patchelf).
 It can be changed with a compile flag to the GCC linker with -Wl,-dynamic-linke
r,/home/lars/very/long/path/to/another/loader.symlink.so.2.
 This does indeed move everything, a plausible way to change code layout.
\end_layout

\begin_layout Description
.note.ABI-tag Formatted as comment section from ELF standard.
 Specifies OS (0 for Linux), and earliest compatible Linux kernel 
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset CommandInset href
LatexCommand href
name "http://refspecs.linuxfoundation.org/LSB_1.2.0/gLSB/noteabitag.html"
target "http://refspecs.linuxfoundation.org/LSB_1.2.0/gLSB/noteabitag.html"

\end_inset


\end_layout

\end_inset

.
 Example from ELF output.
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily}"
inline false
status open

\begin_layout Plain Layout

Notes at offset 0x00000254 with length 0x00000020:
\end_layout

\begin_layout Plain Layout

  Owner                 Data size	Description
\end_layout

\begin_layout Plain Layout

  GNU                  0x00000010	NT_GNU_ABI_TAG (ABI version tag)
\end_layout

\begin_layout Plain Layout

    OS: Linux, ABI: 2.6.24
\end_layout

\end_inset


\end_layout

\begin_layout Description
.note.gnu.build-id Bitstring with some kind of hash to identify the build.
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily}"
inline false
status open

\begin_layout Plain Layout

Notes at offset 0x00000274 with length 0x00000024:
\end_layout

\begin_layout Plain Layout

  Owner                 Data size	Description
\end_layout

\begin_layout Plain Layout

  GNU                  0x00000014	NT_GNU_BUILD_ID (unique build ID bitstring)
\end_layout

\begin_layout Plain Layout

    Build ID: a449e580b52059227cbefd8d4454a9c6f16b9cde
\end_layout

\end_inset


\end_layout

\begin_layout Description
.gnu.hash Some hash value.
 28 bytes on our machine.
 An 
\begin_inset Quotes eld
\end_inset

old
\begin_inset Quotes erd
\end_inset

 hash method can be used by providing linker options, but that might break
 libc compatibility.
\end_layout

\begin_layout Description
.dynsym As explained very well here 
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset CommandInset href
LatexCommand href
name "https://blogs.oracle.com/ali/entry/inside_elf_symbol_tables"
target "https://blogs.oracle.com/ali/entry/inside_elf_symbol_tables"

\end_inset


\end_layout

\end_inset

, there are two symbol tables in ELF files; 
\begin_inset Quotes eld
\end_inset

.dynsym
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

.symtab
\begin_inset Quotes erd
\end_inset

.
 Only dynsym is allocable (marked with 'A' in readelf) -- meaning it will
 occupy virtual address space in the running process.
 This is needed for global external symbols, references that needs to be
 resolved at runtime.
 References to library functions such as 
\begin_inset Quotes eld
\end_inset

printf
\begin_inset Quotes erd
\end_inset

 appears in dynsym, and is resolved at runtime after libc (or whatever standard
 library) is loaded.
 The symtab section is not allocable, and contains all symbols (including
 those in dynsym).
 
\end_layout

\begin_layout Description
.dynstr The string table associated with dynamically linked symbols.
 Probably indexed into by dynsym.
 
\end_layout

\begin_layout Description
.gnu.version A table of version numbers.
 Increasing with more external references to library functions.
\end_layout

\begin_layout Description
.gnu.version_r More version table stuff.
\end_layout

\begin_layout Description
.rela.dyn Relocation stuff, for 
\begin_inset Quotes eld
\end_inset

'dyn
\begin_inset Quotes erd
\end_inset

 section? These also change with more external references.
\end_layout

\begin_layout Description
.rela.plt Relocation stuff for plt section.
\end_layout

\begin_layout Description
.init Executable instructions that are done before main is called.
\end_layout

\begin_layout Description
.plt Procedure Linkage Table.
 Also changes with more external references.
 Manual says attributes are processor specific.
\end_layout

\begin_layout Description
.text Executable code.
 This is the interesting part -- if changes to any other section offsets
 this, we might experience bias effects.
\end_layout

\begin_layout Description
.fini
\end_layout

\begin_layout Description
.rodata Read-only data ?
\end_layout

\begin_layout Description
.eh_frame_hdr
\end_layout

\begin_layout Description
.eh_frame
\end_layout

\begin_layout Description
.ctors
\end_layout

\begin_layout Description
.dtors
\end_layout

\begin_layout Description
.jcr
\end_layout

\begin_layout Description
.dynamic
\end_layout

\begin_layout Description
.got
\end_layout

\begin_layout Description
.got.plt ?
\end_layout

\begin_layout Description
.data 
\end_layout

\begin_layout Description
.bss Uninitialized data.
 Will be initialized to zero once program is loaded.
 Occupies no space in ELF file.
\end_layout

\begin_layout Description
.comment 
\begin_inset Quotes eld
\end_inset

Version control information
\begin_inset Quotes erd
\end_inset

 from the documentation.
 Contains the compiler version used: 
\begin_inset Quotes eld
\end_inset

GCC: (Ubuntu Linaro 4.6.3-1ubuntu5) 4.6.3
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Description
.shstrtab Section names, such as 
\begin_inset Quotes eld
\end_inset

.text
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

.dtors
\begin_inset Quotes erd
\end_inset

 etc.
 Each section listed in the ELF file contains an index to its name in this
 section.
\end_layout

\begin_layout Description
.symtab Symbol table.
 Nice printout in readelf.
 Entries point to .strtab and .dynstr for names.
\end_layout

\begin_layout Description
.strtab Symbol names used in the source file.
 Function names are placed here.
\end_layout

\begin_layout Chapter
Case Studies
\end_layout

\begin_layout Standard
Graphs illustrating the effect in generated or constructed examples.
 Effects of applying heuristics.
 Ideally some results from applying this to FFT.
\end_layout

\begin_layout Standard
Idea: Try compiling fftw with align-loops=32 perhaps.
 Might not work on generated codelets.
\end_layout

\begin_layout Section
FFTW
\end_layout

\begin_layout Standard
Many modes, double or float.
 Using double, as that is the standard.
 Otherwise needs to link -lfftw3f.
 Indeed possible to observe bias from array alignment.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Img/fft/fft-float-alias.eps
	scale 70

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Offseting incrementally by 2.
 Double.
 n = 16, x = 200000
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Malloc alignment
\end_layout

\begin_layout Standard
Fftw provides a wrapper around the provided malloc to ensure alignment.
 Found in kernel/kalloc.c in the source code.
\end_layout

\begin_layout Chapter
Conclusions and Future Work
\end_layout

\begin_layout Standard
Sure this is an easy section.
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
btprint "btPrintAll"
bibfiles "references"
options "bibtotoc,acm"

\end_inset


\end_layout

\begin_layout Chapter
\start_of_appendix
List of Performance Counters
\end_layout

\begin_layout Standard
A collection of hardware performance counters is listed in Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:performance-counters"

\end_inset

.
 A complete reference
\begin_inset Foot
status open

\begin_layout Plain Layout
We suspect that the reference for Ivy Bridge provided by Intel (as of <date>)
 is in fact not complete.
 For instance, no counter concerning the loop stream detector is listed
 in 19-5, but events listed for previous generations seems to work anyway.
\end_layout

\end_inset

 can be found in Volume 3B of the Architectures Software Developer's Manual
 
\begin_inset CommandInset citation
LatexCommand cite
key "Intel:2013:Volume3B"

\end_inset

.
 A handy online reference is available at (insert url).
\end_layout

\begin_layout Standard
\noindent
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begingroup
\backslash
tabcolsep=3pt
\backslash
begin{small}
\end_layout

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="4">
<features tabularvalignment="middle" tabularwidth="100text%">
<column alignment="center" valignment="top" width="8text%">
<column alignment="center" valignment="top" width="8text%">
<column alignment="left" valignment="top" width="34text%">
<column alignment="left" valignment="top" width="44text%">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Event num.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Umask value
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Event Mask Mnemonic
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Description
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
03H
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
02H
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
LD_BLOCKS.
 STORE_FORWARD
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
07H
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
01H
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
LD_BLOCKS_PARTIAL.
 ADDRESS_ALIAS
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
20H
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
01H
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
LSD_OVERFLOW
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{small}
\backslash
endgroup
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:performance-counters"

\end_inset

Interesting hardware performance counters available on the Intel Core i7
 architecture.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Using perf
\end_layout

\begin_layout Standard
Perf only supports a small subset of counters by mnemonics, such as 
\emph on
cycles
\emph default
, instructions, and 
\emph on
branch-misses
\emph default
.
 To use counters from the manual, simply concatenate Umask value and Event
 num, using only the numeric value.
 To count cycles and LD_BLOCKS_PARTIAL.ADDRESS_ALIAS:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

perf stat -e cycles:u,r0203:u ./a.out
\end_layout

\end_inset


\end_layout

\end_body
\end_document
