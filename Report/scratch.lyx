#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass report
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman lmodern
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 90

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 12
\spacing single
\use_hyperref false
\papersize a4paper
\use_geometry true
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 2
\paperpagestyle headings
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Ideas and Leftovers from Thesis
\end_layout

\begin_layout Abstract
This is the abstract
\end_layout

\begin_layout Chapter
First Chapter
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
Optimizing for performance often consist of 
\begin_inset Quotes eld
\end_inset

high level
\begin_inset Quotes erd
\end_inset

 tasks such as reducing algorithmic complexity, change data structures and
 ..., but also trying to eliminate branch misses and reduce the number of cache
 misses.
 As programmers, we are usually content as soon as we are able to measure
 a speedup.
 We will often be using simple techniques for observing performance metrics,
 such as incrementing counter variables for each invocation of function
 X, or inserting printf's in strategic places.
 
\end_layout

\begin_layout Standard
In disciplines other than computer science, such as medicine and the social
 sciences, the notions of measurement bias and observer effect is more often
 considered.
 
\end_layout

\begin_layout Standard
Performance cliffs
\end_layout

\begin_layout Standard
Align to page, cache line, whatever.
 Hardware not uniform.
 Everything can happen.
\end_layout

\begin_layout Description
Observer
\begin_inset space ~
\end_inset

effect The phenomena is changed (or even disappears) merely by observing
 it.
\end_layout

\begin_layout Description
Measurement
\begin_inset space ~
\end_inset

bias Properties of the experimental setup or environment, external and independe
t of what is being measured, is affecting the outcome of the experiment.
 
\end_layout

\begin_layout Standard
Seemingly innocious properties properties of the experimental setup, external
 to the program being measured, can bias performance measurements.
 There are many potential sources of bias that could come from the environment.
 In the widest sense, properties like the time of day, or temperature of
 the room should be considered relevant variables of the execution environment.
 This is actually not as far fetched as it may sound -- electronic circuits
 might very well operate more efficiently in lower temperatures, and programs
 we benchmark might use some API to ask for the time of day and execute
 different code paths dependent on that information.
\end_layout

\begin_layout Section
Hardware Performance Counters
\end_layout

\begin_layout Standard
To be able to tell anything about bias effects we need to have a reliable
 way to gather various metrics.
 There are many different approaches for measuring performance of software;
 debuggers, profilers and the likes are widely used in both industry and
 academia.
 Unfortunately, measurement techniques relying on intervention from software
 are prone to observer effect.
 In addition, any measurement instrumentation that alters the executed program
 per definition measures a 
\emph on
different
\emph default
 program -- making it difficult to accurately identify bias effects.
\end_layout

\begin_layout Standard
Luckily, modern processors have support in hardware for measuring a plethora
 of different metrics, called performance counters.
 
\end_layout

\begin_layout Subsection
Accuracy of Performance Counters
\end_layout

\begin_layout Standard
Unfortunately, performance counters are not necessarily accurate or predictable.
 Several papers have looked at the relationship between measured counts
 and the 
\begin_inset Quotes eld
\end_inset

right answer
\begin_inset Quotes erd
\end_inset

.
 For certain metrics it is quite easy to verify wether the reported counts
 are accurate.
 One example is the number of retired instructions, for the perf utility
 reported as instructions:u.
 At least for small programs, we can easily count the number of dynamic
 intructions and compare to reported counts.
 
\end_layout

\begin_layout Subsubsection*
Accuracy vs.
 Precision
\end_layout

\begin_layout Standard
For clarity, it is worth pointing out the difference between accuracy and
 precision.
 A series of measurements can be accurate, but not precise, and vice-versa.
 Consider a bow-and-arrow contest after a series of arrows are fired at
 the same target.
 The archer is 
\emph on
accurate
\emph default
 if the arrows land close to the target, and 
\emph on
precise
\emph default
 if the arrows lands close together.
 Note that accuracy does not entail precision, and vice-versa.
\end_layout

\begin_layout Standard
For performance measurements, these are properties of the performance counters.
 Ideally we want counters to be both precise and accurate.
 Many papers have looked at the properties of performance counters, and
 unfortunately very few seems to have the desired properties.
 A counter that appears to be both accurate and precise is INSTR_RETIRED
 -- which can be pretty easily verified by inspecting the source code.
 Measuring the number of cucles accurately seems to be more of a challenge.
 There will always be some overhead in setting up the counters and reading
 the values after the program has run.
 We can try to create an empty program -- but the cycle count reported by
 perf will not be anywhere near zero.
 Trying to measure the 
\begin_inset Quotes eld
\end_inset

empty
\begin_inset Quotes erd
\end_inset

 program yields about 2000 cycles in our setup.
\end_layout

\begin_layout Subsection
Performance Counters in Linux
\end_layout

\begin_layout Standard
The Linux kernel provides an interface to hardware performance counters
 through the perf utility, which we will be using for our measurements.
 
\end_layout

\begin_layout Subsection
Details from Intel Manual
\end_layout

\begin_layout Standard
The current generations of Intel microarchitectures are called, from earliest
 to newest, Sandy Bridge, Ivy Bridge and Haswell.
 In the official documentation on hardware performance monitoring, Ivy Bridge
 is 
\begin_inset Quotes eld
\end_inset

generally the same
\begin_inset Quotes erd
\end_inset

 as described for Sandy Bridge.
 Ref 18.9 in Part 3B.
 
\end_layout

\begin_layout Standard
Another note: Ivy Bridge is 
\begin_inset Quotes eld
\end_inset

3rd generation Core
\begin_inset Quotes erd
\end_inset

, while Haswell is 
\begin_inset Quotes eld
\end_inset

Next generation
\begin_inset Quotes erd
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sandy/Ivy Bridge
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Number of fixed counters per thread
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Number of general-purpose counters per core
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Number of programmable counters per thread
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4 (8 if a core is not shared by two threads)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
PMU (Performance Monitoring Unit) capabilities for 2nd and 3rd generation
 Intel Core microarchitectures (Sandy Bridge and Ivy Bridge).
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Quote from 18.11.5.2
\end_layout

\begin_layout Quote
The performance-monitoring events listed in Chapter 19, “Performance-Monitoring
 Events,” are intended to be used as guides for performance tuning.
 The counter values reported are not guaranteed to be absolutely accurate
 and should be used as a relative guide for tuning.
 Known discrepancies are documented where applicable.
 
\end_layout

\begin_layout Paragraph
Fixed counters
\end_layout

\begin_layout Standard
Can only count one event (?)
\end_layout

\begin_layout Paragraph*
Generic counters
\end_layout

\begin_layout Standard
Can count any event
\end_layout

\begin_layout Standard
In case there are more events than counters, OS will multiplex and perf
 do scaling (inaccurate).
\end_layout

\begin_layout Paragraph
Software events
\end_layout

\begin_layout Standard
Things like context switches.
 (How is this counted?)
\end_layout

\begin_layout Paragraph
Hardware events
\end_layout

\begin_layout Standard
Cycles
\end_layout

\begin_layout Paragraph
PMI
\end_layout

\begin_layout Standard
Performance Monitor Interrupt
\end_layout

\begin_layout Paragraph
At Retirement Events
\end_layout

\begin_layout Standard
At-retirement counting provides a means counting only events that represent
 work committed to architectural state and ignoring work that was performed
 speculatively and later discarded.
 (Quote from 18.11.6)
\end_layout

\begin_layout Standard
Tagging of micro-operations enables counting at retirement.
 Ex from manual: A micro-op can have several cache-misses during execution.
 Tag to get counted only once.
\end_layout

\begin_layout Subsection
Precise Event Based Sampling (PEBS) 
\end_layout

\begin_layout Standard
Same support as Sandy Bridge, with events listed in Table 18-21.
\end_layout

\begin_layout Standard
Allows PMU to collect architectural state and Instruction Pointer (IP) 
\emph on
after
\emph default
 instruction that caused event is completed.
 Only 
\begin_inset Quotes eld
\end_inset

at-retirement
\begin_inset Quotes erd
\end_inset

 events.
 PEBS buffer can contain all general purpose registers + IP for analyzing
 later.
 Used in V-tune.
\end_layout

\begin_layout Standard
Supported in perfmon2 for some version number > x.
 
\end_layout

\begin_layout Standard
Quote from forum post: http://software.intel.com/en-us/forums/topic/277553
\end_layout

\begin_layout Quote
PEBS (Precise Event Based Sampling) is a feature available to a subset of
 events which allows the hardware to collect additionalinformation very
 close to the exact time the configured event overflowed.
 This presents theanalysis tools whith susbstantially more accurate information
 since the alternative is to wait for a software interrupt to collect this
 information, typically hundreds of cycles later.The additional collected
 information are stored in a special PEBS buffer and retrieved by the tool
 (in this case perf_events) later.
\end_layout

\begin_layout Standard
For use in perf: append :pp to event.
 Needs to be used with perf record.
\end_layout

\begin_layout Section
Measurement Bias Introduction
\end_layout

\begin_layout Standard
It is not entirely clear what variables should be cause of measurement bias.
 Bias occurs when some property of the 
\emph on
environment
\emph default
 can skew measurements away from the 
\begin_inset Quotes eld
\end_inset

true
\begin_inset Quotes erd
\end_inset

 result.
 What we are interested in measuring is typically performance of a computer
 program.
 Performance can be represented by various metrics, such as cycle count,
 cache misses or page faults.
 By environment we think of anything that is external to the program, things
 that can (and will) vary from each machine, or between each time measurements
 are made.
\end_layout

\begin_layout Standard
It is clear that the Unix environment should be considered part of the environme
nt for a measurement.
 This is a variable that will typically vary between measurements, at least
 between machine, independent of the program we benchmark.
\end_layout

\begin_layout Standard
Link order is more dubious.
 For the link order to be part of the environment, we might have a program
 that is distributed as object files, and a Makefile with unspecified link
 order, leaving it up to the particular linker implementation on the target
 machine to decide the order.
 
\end_layout

\begin_layout Standard
Definition:
\end_layout

\begin_layout Quote
Any variable that can be changed without changing the program can count
 as measurement bias.
\end_layout

\begin_layout Standard
The kind of variables we should include as possible sources for
\end_layout

\begin_layout Standard
Other, more esoteric variables, might include the time of day, room temperature,
 and 
\end_layout

\begin_layout Standard
Time of day
\end_layout

\begin_layout Standard
Room temperature
\end_layout

\begin_layout Standard
Introduce all papers from Mytkovitz et al.
 
\end_layout

\begin_layout Standard
Idea: Version of shell (bash or sh or tch etc) matters because of environment
 size variable etc)
\end_layout

\begin_layout Subsection
Heap conflicts
\end_layout

\begin_layout Standard
Dynamic memory allocation can also trigger alias effects.
 Observations:
\end_layout

\begin_layout Standard
Malloc appears to be deterministic, once the ASLR has placed heap start
 address somewhere.
 On x86_64, the heap is typically located around virtual address 0x600000,
 right above program text and data segments (see illustration).
 Some metadata for each allocated area is used to handle free requests etc.
 The pointer returned from malloc seems to be aligned to a single byte,
 meaning returned addresses always end with 0x0.
\end_layout

\begin_layout Standard
For slightly larger requests (how large?), malloc uses mmap, which aligns
 to page size; i.e.
 0x1000.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily}"
inline false
status open

\begin_layout Plain Layout

#define N 0x7ffa // 65536 = 0x10000
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

static int inc = 0;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main(int argc, char **argv)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    int offset  = atoi(argv[1]), i;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    float *a    = malloc(N*sizeof(float));
\end_layout

\begin_layout Plain Layout

    float *fill = malloc(offset*sizeof(float));
\end_layout

\begin_layout Plain Layout

    float *b    = malloc(N*sizeof(float));
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    for (i = 0; i < N; ++i)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        b[i] += inc;
\end_layout

\begin_layout Plain Layout

        b[i]++;
\end_layout

\begin_layout Plain Layout

        b[i]++;
\end_layout

\begin_layout Plain Layout

        b[i]++;
\end_layout

\begin_layout Plain Layout

        b[i]++;
\end_layout

\begin_layout Plain Layout

        a[i]++;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Micro-kernel with a simple loop reading and writing to arrays a and b.
 With the correct input argument, a and b will alias and the cycle count
 noticeably spikes.
 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Internals of malloc
\end_layout

\begin_layout Standard
For the previous example, adding a single byte to the b array, suddently
 malloc will begin using mmap instead of brk after some amount of offset
 (fill array).
 
\end_layout

\begin_layout Standard
brk is a strange system call: It increases the boundary of the data segment,
 by simply pushing the 
\begin_inset Quotes eld
\end_inset

break
\begin_inset Quotes erd
\end_inset

 address upwards.
 Break marks the end of the 
\begin_inset Quotes eld
\end_inset

bss
\begin_inset Quotes erd
\end_inset

 segment -- uninitialized data.
 See man page.
 Is it actually used in malloc? Called only once perhaps?
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Img/heap-step.svg
	scale 30

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Adding a single float causes mmap to be called after a certain amount of
 offset.
 Very weird.
 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
mmap is a posix system call for mapping a file to contiguous memory.
 Using the ANONYMOUS parameter, memory can be mapped without a backing file.
 malloc uses mmap instead of brk for large allocations -- although the rules
 seems kind of complicated.
\end_layout

\begin_layout Subsection
Malloc with Pthreads
\end_layout

\begin_layout Standard
Knowign about the possibility of aliasing with aligned array, we can try
 to come up with plausible scenarios where bias can occur.
 An idea for provoking malloc alignment could be to use threading.
\end_layout

\begin_layout Standard
Pthread malloc is probably another implementation, which does not use the
 low-address heap space.
 The high-addresses, apparantly up to 0x7fff'f0000000, are used in the pthread
 implementation.
 Two threads are allocated with heaps 0x7fff'
\series bold
e8
\series default
000000 and 0x7fff'
\series bold
f0
\series default
000000.
\end_layout

\begin_layout Standard
Plan 2: Allocate enough space on each thread-specific are to fill them,
 causing subsequent calls to allocate on shared area.
 Now, allocate (_, 1, 2) + (_, 3) arrays, with arrays 1 and 2 colliding
 if the allocations happen 1, 3, 2 -- alternatively 1, 2, 3.
 The _ allocation is for eating up 
\begin_inset Quotes eld
\end_inset

local
\begin_inset Quotes erd
\end_inset

 heap.
 The size of the local segment is ? 
\end_layout

\begin_layout Standard
Does not work.
 Multiple threads have their own 
\begin_inset Quotes eld
\end_inset

start
\begin_inset Quotes erd
\end_inset

 heap area -- when it overflows, mmap is used which aligns to 12 bit.
 Multiple threads do allocate different areas dependent on ordering, but
 with mmap alignment, there is not much to about it.
\end_layout

\begin_layout Section
FFTW
\end_layout

\begin_layout Standard
Many modes, double or float.
 Using double, as that is the standard.
 Otherwise needs to link -lfftw3f.
 Indeed possible to observe bias from array alignment.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Img/fft/fft-float-alias.eps
	scale 70

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Offseting incrementally by 2.
 Double.
 n = 16, x = 200000
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Malloc alignment
\end_layout

\begin_layout Standard
Fftw provides a wrapper around the provided malloc to ensure alignment.
 Found in kernel/kalloc.c in the source code.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},breaklines=true,language=C"
inline false
status open

\begin_layout Plain Layout

int main() 
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    fftw_complex *in  = fftw_malloc(sizeof(fftw_complex) * N);
\end_layout

\begin_layout Plain Layout

    fftw_complex *out = fftw_malloc(sizeof(fftw_complex) * N);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    for (int i = 0; i < N; ++i)
\end_layout

\begin_layout Plain Layout

        in[i][0] = i, in[i][1] = i;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    fftw_plan p = fftw_plan_dft_1d(N, in, out, FFTW_FORWARD, FFTW_ESTIMATE);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    for (int i = 0; i < X; ++i)
\end_layout

\begin_layout Plain Layout

        fftw_execute(p);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    fftw_destroy_plan(p);
\end_layout

\begin_layout Plain Layout

    fftw_free(in), fftw_free(out);
\end_layout

\begin_layout Plain Layout

    return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
C program snippet for computing the Fourier transform of N double precision
 complex numbers X times.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Stack Alignment
\end_layout

\begin_layout Standard
Figure shows cycles for incrementing environment by one byte.
 A clear bias towards environment sizes outside of the 2000--3000 area.
 Plotting over a wider area shows that the bias is periodic over 4096 bytes,
 showing that alias on the last 16 bits is probably the cause again.
 Testing typeriter (ctrl,shift+p).
 A hex digit; 
\family typewriter
0x100
\family default
, or registers 
\family typewriter
%rsp
\family default
, might come in handy.
\end_layout

\begin_layout Paragraph
Modifying Kernels to Avoid Bias
\end_layout

\begin_layout Standard
Variables affecting memory access:
\end_layout

\begin_layout Itemize
Position of input and output arrays; likely heap allocated, so 2 independent
 (maybe!) factors.
 A possible fix to fftw_malloc: add argument for input array when allocating
 output, like fftw_malloc_cobuffer(void* sibling, size_t n).
 
\end_layout

\begin_layout Itemize
Position of stack
\end_layout

\begin_layout Itemize
Position of text segment with constants.
 Seems like there are 3 or 4 accesses, happening at the start, where large
 floating point constants are read into stack-allocated variables.
\end_layout

\begin_layout Standard
Notes on creating assembly code
\end_layout

\begin_layout Itemize
The x86_64 ABI specifies 6 registers to be used for argument passing; %rdi
 %rsi %rdx %rcx %r8 %r9.
 
\end_layout

\begin_layout Itemize
The exact alignment of stack pointer is very sensitive.
 %rsp should be aligned with a trailing 0x1000.
 Formula: rsp -= 8 + 64*n.
 A clean example "andq $-4096, %%rsp; subq $8, %%rsp".
 This fixes case with heap=32, stack=0x800 -- removing the two areas assumed
 to be collision between stack and input/output respectively.
\end_layout

\begin_layout Itemize
Whith this fixed stack alignment, we can trigger bias across all environments
 by placing input/output close to 0x000.
 Ex.
 allocating 220-sized array before input will place arrays close to boundary,
 giving lots of alias all over.
 
\end_layout

\begin_layout Itemize
Unknown spike depending on environment.
 Position varies depending on heap addresses, but shape remains mostly the
 same.
 Not sure how this can be mitigated -- need to know cause.
\end_layout

\begin_layout Itemize
Can be quite certain it is not the size or content of the environment that
 is the cause.
 Using input argument to manually subtract froms tack pointer inside main
 gives exactly the same results as incrementing environment.
\end_layout

\begin_layout Itemize
Offseting stack before caling the kernel can fix all bias.
 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

asm volatile (
\end_layout

\begin_layout Plain Layout

        "movq  %%rsp, %0;"
\end_layout

\begin_layout Plain Layout

        "andq  $-1024, %%rsp;"
\end_layout

\begin_layout Plain Layout

        : "=r"(offset)
\end_layout

\begin_layout Plain Layout

        : 
\end_layout

\begin_layout Plain Layout

        :
\end_layout

\begin_layout Plain Layout

        );
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    for (i = 0; i < x; ++i)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        fftw_execute(p);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    asm volatile (
\end_layout

\begin_layout Plain Layout

        "movq   %0, %%rsp;"
\end_layout

\begin_layout Plain Layout

        :  
\end_layout

\begin_layout Plain Layout

        : "r"(offset)
\end_layout

\begin_layout Plain Layout

        :
\end_layout

\begin_layout Plain Layout

        );
\end_layout

\end_inset

Measuring over 500 runs with increasing stack offset (sampling over ca two
 intervals).
 Maximum speedup = 31112710 / 30461410 = 1.0213x on average.
 More interesting; removes outliers.
 Max with fix is 30578830, without fix 37828250.
\end_layout

\begin_layout Paragraph
Residual Alias
\end_layout

\begin_layout Standard
Investigated the 
\begin_inset Quotes eld
\end_inset

residual
\begin_inset Quotes erd
\end_inset

 alias effects using perf record.
 Found that beginning of stack frame uses some reads on stack allocated
 parameters, namely 
\begin_inset Quotes eld
\end_inset

is
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

os
\begin_inset Quotes erd
\end_inset

 (possibly others as well).
 Using valgrind and kcachegrind to analyze callgraph to find out where arguments
 are pushed.
 The most recent version (3.8.1) of Valgrind 
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset CommandInset href
LatexCommand href
name "http://valgrind.org/"
target "http://valgrind.org/"

\end_inset


\end_layout

\end_inset

 was downloaded and compiled from source to enable support for AVX instructions.
\end_layout

\begin_layout Standard
Call graph is main -> fftw_execute -> fftw_dft_solve -> apply_extra_iter
 -> n1fv_16.
\end_layout

\begin_layout Description
apply_extra_iter Located in /dft/direct.c.
 Trying to insert stack fix here works similar to inserting directly to
 kernel.
 A bit better, but still some bias not removed.
 This is the most logical and probable place to insert stack fix I think.
 The other functions are too high-level for it to make much sense.
 
\end_layout

\begin_layout Description
fftw_dft_solve Located in /dft/solve.c.
 Inserting fix here fixes almost everything, small noise left.
 Everything is removed when aligning main though, so need to try execute
 as well.
\end_layout

\begin_layout Description
fftw_execute Located in /api/execute.c.
 Same result as for dft_solve.
 
\end_layout

\begin_layout Standard
The most logical place to apply alignment fixes would probably be close
 to the kernel invocation.
 Properties of the kernel itself decides most of the alias effects, thus
 only the kernel, or the function calling the kernel, would know how the
 stack should be aligned.
 We insert some assembly to apply_extra_iter, aligning stack before the
 kernel is called twice.
\end_layout

\begin_layout Standard
Our example is very hard to achieve a speedup for because whatever we do
 the dynamic instruction count will increase significantly, adding a constant
 overhead whose cost is very hard to equalize on average over all environment
 sizes.
\end_layout

\begin_layout Paragraph
Heap collisions
\end_layout

\begin_layout Standard
Consider cases where heap addresses can collide.
 Here it is possible to apply a fix during the fftw_allocate phase, guaranteed
 speedup.
 Definitely possible to do something here.
 Implement fftw_malloc(size_t n, void* pair), or even keep a history of
 previously allocated sizes, and try to return addresses with no conflicts
 for small allocations.
 That way no modifications to the interface is needed either.
\end_layout

\begin_layout Subsubsection*
Heap-Heap Conflicts
\end_layout

\begin_layout Standard
In addition to heap addresses overlaping with stack, there is also a possibility
 of input and output arrays overlapping themselves.
 We suspected that additional address conflicts would be generated when
 the last 12 bits of 
\begin_inset Quotes eld
\end_inset


\family typewriter
ri
\family default

\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset


\family typewriter
ro
\family default

\begin_inset Quotes erd
\end_inset

 were close.
 However, we found that aligning input and output buffers did not cause
 any conflicts in itself for the 
\family typewriter
n1fv_16
\family default
 kernel.
 All alias seems to come from conflicting accesses between input/output
 and stack.
 
\end_layout

\begin_layout Section
Old LSD C Micro Kernels
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},language=C"
inline false
status open

\begin_layout Plain Layout

volatile int i = 42;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int loop(int a) {
\end_layout

\begin_layout Plain Layout

    register int b = i == 42 ? 1 : 0;
\end_layout

\begin_layout Plain Layout

    do {
\end_layout

\begin_layout Plain Layout

        if (!i) b += i*i*a + 1;
\end_layout

\begin_layout Plain Layout

        if (!i) b += i*i*a + 1;
\end_layout

\begin_layout Plain Layout

        (...)
\end_layout

\begin_layout Plain Layout

    } while (i++ < 0x1234567);
\end_layout

\begin_layout Plain Layout

    return b;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main() {
\end_layout

\begin_layout Plain Layout

    i = loop(10);
\end_layout

\begin_layout Plain Layout

    return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:lsd-chunks"

\end_inset

Micro kernel for testing LSD chunk fetch limit.
 Additional if statements are inserted until LSD.UOPS shows the LSD is inactive.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The documentation states that a maximum number of eight 32 byte 
\begin_inset Quotes eld
\end_inset

chunks
\begin_inset Quotes erd
\end_inset

 of instruction data can be fetched in each loop.
 Our interpretation of this is that instructions are read from instruction
 cache in blocks of 32 bytes at a time, and each chunk is aligned to multiples
 of 0x20 in virtual address space.
 
\end_layout

\begin_layout Standard
To test this limit, we need loops that execute instructions spanning a variable
 amount of chunks.
 The micro kernel we used is shown in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:lsd-chunks"

\end_inset

; multiple identical conditional statements are executed, but always evaluated
 to false to skip through to the next chunk.
 The example code is tuned such that each of the if statements occupy exactly
 32 instruction bytes when compiled with 
\family typewriter
gcc -O3
\family default
.
 Additionally, the compiler flag 
\family typewriter
-falign-loops
\family default
 is set to 32, explicitly forcing the first loop instruction to a multiple
 of 0x20.
 Notice in the generated assembly below
\begin_inset Foot
status open

\begin_layout Plain Layout
Output shows disassembly generated by the objdump utility, part of GNU Binutils
\end_layout

\end_inset

, the first instruction starts on address 
\family typewriter
0x400500
\family default
.
 The first 10 bytes of the generated assembly consist of three instructions;
 a 
\family typewriter
mov
\family default
, loading variable 
\family typewriter
i
\family default
 to a register, a 
\family typewriter
test
\family default
, and a conditional jump.
 The conditional will always evaluate to false, thus the remaining 22 bytes
 is dead code.
 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily}"
inline false
status open

\begin_layout Plain Layout

400500: 8b 15 12 0b 20 00    mov    0x200b12(%rip),%edx
\end_layout

\begin_layout Plain Layout

400506: 85 d2                test   %edx,%edx
\end_layout

\begin_layout Plain Layout

400508: 75 16                jne    400520 <loop+0x40>
\end_layout

\begin_layout Plain Layout

40050a: 8b 15 08 0b 20 00    mov    0x200b08(%rip),%edx
\end_layout

\begin_layout Plain Layout

400510: 8b 0d 02 0b 20 00    mov    0x200b02(%rip),%ecx
\end_layout

\begin_layout Plain Layout

400516: 0f af d1             imul   %ecx,%edx
\end_layout

\begin_layout Plain Layout

400519: 0f af d7             imul   %edi,%edx
\end_layout

\begin_layout Plain Layout

40051c: 8d 44 10 01          lea    0x1(%rax,%rdx,1),%eax
\end_layout

\end_inset


\end_layout

\begin_layout Standard
After some number of repeated if statements, the increment, test and jump
 occupies another 27 bytes.
 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily}"
inline false
status open

\begin_layout Plain Layout

400680: 8b 15 92 09 20 00    mov    0x200992(%rip),%edx
\end_layout

\begin_layout Plain Layout

400686: 8d 4a 01             lea    0x1(%rdx),%ecx
\end_layout

\begin_layout Plain Layout

400689: 81 fa 66 45 23 01    cmp    $0x1234566,%edx
\end_layout

\begin_layout Plain Layout

40068f: 89 0d 83 09 20 00    mov    %ecx,0x200983(%rip)
\end_layout

\begin_layout Plain Layout

400695: 0f 8e 65 fe ff ff    jle    400500 <loop+0x20>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
For every loop iteration, a total of 
\begin_inset Formula $3N+5$
\end_inset

 instructions are executed, spanning 
\begin_inset Formula $N+1$
\end_inset

 chunks of 32 bytes.
 We find that the LSD.UOPS counter reports high values through 
\begin_inset Formula $N=11$
\end_inset

, meaning the loop stream detector on Ivy Bridge actually supports up to
 12 chunk fetches.
 
\end_layout

\begin_layout Subsubsection*
Micro-operations
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},language=C"
inline false
status open

\begin_layout Plain Layout

volatile static int i;
\end_layout

\begin_layout Plain Layout

int main() {
\end_layout

\begin_layout Plain Layout

    register int b = 0;
\end_layout

\begin_layout Plain Layout

    do {
\end_layout

\begin_layout Plain Layout

        b++;
\end_layout

\begin_layout Plain Layout

        b++;
\end_layout

\begin_layout Plain Layout

        (...)
\end_layout

\begin_layout Plain Layout

    } while (i++ < 0x1234567);
\end_layout

\begin_layout Plain Layout

    return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:lsd-micro-ops"

\end_inset

Micro kernel for testing LSD micro-instruction limit.
 Additional 
\family typewriter
b++
\family default
 statements are inserted until LSD.UOPS shows the LSD becomes inactive.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The second requirement states that each loop can only contain a maximum
 of 28 micro-operations.
 This is no longer true for Ivy Bridge, because of changes to the Micro-op
 Queue.
 In previous generation(s), the micro-op queue was statically partitioned
 with 28 entries for each logical core.
 One of the Front-end enhancement in Ivy Bridge is that all 56 entries in
 the queue can be used when only a single logical core is active, i.e.
 hyperthreading is disabled 
\begin_inset CommandInset citation
LatexCommand cite
key "Intel:2012:OptimizationManual"

\end_inset

.
 We verify this restriction by measuring LSD_OVERFLOW and LSD.UOPS for loops
 of increasing size, adding instructions one by one until the performance
 counter statistics report the LSD is inactive.
 Our micro-kernel is shown in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:lsd-micro-ops"

\end_inset

.
 Compiling with 
\family typewriter
gcc -O3 -falign-loops=32
\family default
 generates a long list of three byte 
\family typewriter
addl
\family default
 instructions:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily}"
inline false
status open

\begin_layout Plain Layout

4003e0: 83 c3 01             add    $0x1,%ebx
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The loop at the end contributes to five more instructions
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily}"
inline false
status open

\begin_layout Plain Layout

400485: 8b 05 9d 0b 20 00    mov    0x200b9d(%rip),%eax
\end_layout

\begin_layout Plain Layout

40048b: 8d 50 01             lea    0x1(%rax),%edx
\end_layout

\begin_layout Plain Layout

40048e: 3d 66 45 23 01       cmp    $0x1234566,%eax
\end_layout

\begin_layout Plain Layout

400493: 89 15 8f 0b 20 00    mov    %edx,0x200b8f(%rip)
\end_layout

\begin_layout Plain Layout

400499: 0f 8e 41 ff ff ff    jle    4003e0 <main>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We find that the LSD is active with as many as 52 
\family typewriter
add
\family default
 instructions.
 With the additional four instructions and a jump, the correct answer is
 likely 56 micro-operations per loop.
 With hyperthreading enabled, the number is cut in half to 28, as expected.
\end_layout

\begin_layout Section
Old LSD examples
\end_layout

\begin_layout Standard
Compiling this using gcc and no optimization, we see that the loop stream
 detector is not applied to this loop.
 The address of the first instruction is 0x4004d3, and the last 0x400643.
 If instructions are buffered in chunks of 32B, then chunks must be a multiple
 of 0x20.
 The first instruction is pretty far into the 0x4004
\series bold
c0
\series default
 chunk, while the last instruction is just inside the 0x4006
\series bold
40
\series default
 chunk.
 A total of 13 chunks of 32 bytes is executed -- apparently too much for
 the LSD.
 We use the perf utility to measure total number of un-halted cycles, as
 well as the LSD_OVERFLOW and LSD_UOPS events.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily}"
inline false
status open

\begin_layout Plain Layout

     7,640,342,761 cycles:u                  #    0.000 GHz             
       
\end_layout

\begin_layout Plain Layout

                 0 r0120:u                                             
        
\end_layout

\begin_layout Plain Layout

            10,974 r01a8:u                                             
        
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

       2.249628298 seconds time elapsed
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Observe that by carefully aligning the first instruction, we can fit the
 code into only 12 instruction chunks.
 By inserting 13 nop instruction in the assembly code before the loop, addresses
 of the first and last instructions are offset to, respectively, 0x4004e0
 and 0x400650.
 0xe0 is at the very beginning of a chunk, and 0x50 leaves room for another
 16 bytes (6 of which are occupied by the very last jump instruction).
 Running the same program with these 13 nop instructions results in a dramatic
 improvement in performance.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily}"
inline false
status open

\begin_layout Plain Layout

     3,669,478,538 cycles:u                  #    0.000 GHz             
       
\end_layout

\begin_layout Plain Layout

                 0 r0120:u                                             
        
\end_layout

\begin_layout Plain Layout

     4,579,426,057 r01a8:u                                             
        
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

       1.080381834 seconds time elapsed
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To further strengthen the hypothesis that twelve 32B chunks is the limit,
 we can add another 10 bytes at the very end of the loop and get similar
 results.
 With 11 extra bytes -- spilling instructions over to the next chunk --
 LSD_UOPS is back at 11k.
 
\end_layout

\begin_layout Paragraph
Hyper-threading
\end_layout

\begin_layout Standard
Experiments were repeated with hyperthreading turned on -- and we got the
 same results.
 It seems like HT does not affect the chunk fetch limit of the LSD.
\end_layout

\end_body
\end_document
