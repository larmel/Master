#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass report
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman lmodern
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 90

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 12
\spacing single
\use_hyperref false
\papersize a4paper
\use_geometry true
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 2
\paperpagestyle headings
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Ideas and Leftovers from Thesis
\end_layout

\begin_layout Abstract
This is the abstract
\end_layout

\begin_layout Chapter
First Chapter
\end_layout

\begin_layout Section
Measurement Bias Introduction
\end_layout

\begin_layout Standard
It is not entirely clear what variables should be cause of measurement bias.
 Bias occurs when some property of the 
\emph on
environment
\emph default
 can skew measurements away from the 
\begin_inset Quotes eld
\end_inset

true
\begin_inset Quotes erd
\end_inset

 result.
 What we are interested in measuring is typically performance of a computer
 program.
 Performance can be represented by various metrics, such as cycle count,
 cache misses or page faults.
 By environment we think of anything that is external to the program, things
 that can (and will) vary from each machine, or between each time measurements
 are made.
\end_layout

\begin_layout Standard
It is clear that the Unix environment should be considered part of the environme
nt for a measurement.
 This is a variable that will typically vary between measurements, at least
 between machine, independent of the program we benchmark.
\end_layout

\begin_layout Standard
Link order is more dubious.
 For the link order to be part of the environment, we might have a program
 that is distributed as object files, and a Makefile with unspecified link
 order, leaving it up to the particular linker implementation on the target
 machine to decide the order.
 
\end_layout

\begin_layout Standard
Definition:
\end_layout

\begin_layout Quote
Any variable that can be changed without changing the program can count
 as measurement bias.
\end_layout

\begin_layout Standard
The kind of variables we should include as possible sources for
\end_layout

\begin_layout Standard
Other, more esoteric variables, might include the time of day, room temperature,
 and 
\end_layout

\begin_layout Standard
Time of day
\end_layout

\begin_layout Standard
Room temperature
\end_layout

\begin_layout Standard
Introduce all papers from Mytkovitz et al.
 
\end_layout

\begin_layout Standard
Idea: Version of shell (bash or sh or tch etc) matters because of environment
 size variable etc)
\end_layout

\begin_layout Section
FFTW
\end_layout

\begin_layout Standard
Many modes, double or float.
 Using double, as that is the standard.
 Otherwise needs to link -lfftw3f.
 Indeed possible to observe bias from array alignment.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Img/fft/fft-float-alias.eps
	scale 70

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Offseting incrementally by 2.
 Double.
 n = 16, x = 200000
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Malloc alignment
\end_layout

\begin_layout Standard
Fftw provides a wrapper around the provided malloc to ensure alignment.
 Found in kernel/kalloc.c in the source code.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},breaklines=true,language=C"
inline false
status open

\begin_layout Plain Layout

int main() 
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    fftw_complex *in  = fftw_malloc(sizeof(fftw_complex) * N);
\end_layout

\begin_layout Plain Layout

    fftw_complex *out = fftw_malloc(sizeof(fftw_complex) * N);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    for (int i = 0; i < N; ++i)
\end_layout

\begin_layout Plain Layout

        in[i][0] = i, in[i][1] = i;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    fftw_plan p = fftw_plan_dft_1d(N, in, out, FFTW_FORWARD, FFTW_ESTIMATE);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    for (int i = 0; i < X; ++i)
\end_layout

\begin_layout Plain Layout

        fftw_execute(p);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    fftw_destroy_plan(p);
\end_layout

\begin_layout Plain Layout

    fftw_free(in), fftw_free(out);
\end_layout

\begin_layout Plain Layout

    return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
C program snippet for computing the Fourier transform of N double precision
 complex numbers X times.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Stack Alignment
\end_layout

\begin_layout Standard
Figure shows cycles for incrementing environment by one byte.
 A clear bias towards environment sizes outside of the 2000--3000 area.
 Plotting over a wider area shows that the bias is periodic over 4096 bytes,
 showing that alias on the last 16 bits is probably the cause again.
 Testing typeriter (ctrl,shift+p).
 A hex digit; 
\family typewriter
0x100
\family default
, or registers 
\family typewriter
%rsp
\family default
, might come in handy.
\end_layout

\begin_layout Paragraph
Modifying Kernels to Avoid Bias
\end_layout

\begin_layout Standard
Variables affecting memory access:
\end_layout

\begin_layout Itemize
Position of input and output arrays; likely heap allocated, so 2 independent
 (maybe!) factors.
 A possible fix to fftw_malloc: add argument for input array when allocating
 output, like fftw_malloc_cobuffer(void* sibling, size_t n).
 
\end_layout

\begin_layout Itemize
Position of stack
\end_layout

\begin_layout Itemize
Position of text segment with constants.
 Seems like there are 3 or 4 accesses, happening at the start, where large
 floating point constants are read into stack-allocated variables.
\end_layout

\begin_layout Standard
Notes on creating assembly code
\end_layout

\begin_layout Itemize
The x86_64 ABI specifies 6 registers to be used for argument passing; %rdi
 %rsi %rdx %rcx %r8 %r9.
 
\end_layout

\begin_layout Itemize
The exact alignment of stack pointer is very sensitive.
 %rsp should be aligned with a trailing 0x1000.
 Formula: rsp -= 8 + 64*n.
 A clean example "andq $-4096, %%rsp; subq $8, %%rsp".
 This fixes case with heap=32, stack=0x800 -- removing the two areas assumed
 to be collision between stack and input/output respectively.
\end_layout

\begin_layout Itemize
Whith this fixed stack alignment, we can trigger bias across all environments
 by placing input/output close to 0x000.
 Ex.
 allocating 220-sized array before input will place arrays close to boundary,
 giving lots of alias all over.
 
\end_layout

\begin_layout Itemize
Unknown spike depending on environment.
 Position varies depending on heap addresses, but shape remains mostly the
 same.
 Not sure how this can be mitigated -- need to know cause.
\end_layout

\begin_layout Itemize
Can be quite certain it is not the size or content of the environment that
 is the cause.
 Using input argument to manually subtract froms tack pointer inside main
 gives exactly the same results as incrementing environment.
\end_layout

\begin_layout Itemize
Offseting stack before caling the kernel can fix all bias.
 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

asm volatile (
\end_layout

\begin_layout Plain Layout

        "movq  %%rsp, %0;"
\end_layout

\begin_layout Plain Layout

        "andq  $-1024, %%rsp;"
\end_layout

\begin_layout Plain Layout

        : "=r"(offset)
\end_layout

\begin_layout Plain Layout

        : 
\end_layout

\begin_layout Plain Layout

        :
\end_layout

\begin_layout Plain Layout

        );
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    for (i = 0; i < x; ++i)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        fftw_execute(p);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    asm volatile (
\end_layout

\begin_layout Plain Layout

        "movq   %0, %%rsp;"
\end_layout

\begin_layout Plain Layout

        :  
\end_layout

\begin_layout Plain Layout

        : "r"(offset)
\end_layout

\begin_layout Plain Layout

        :
\end_layout

\begin_layout Plain Layout

        );
\end_layout

\end_inset

Measuring over 500 runs with increasing stack offset (sampling over ca two
 intervals).
 Maximum speedup = 31112710 / 30461410 = 1.0213x on average.
 More interesting; removes outliers.
 Max with fix is 30578830, without fix 37828250.
\end_layout

\begin_layout Paragraph
Residual Alias
\end_layout

\begin_layout Standard
Investigated the 
\begin_inset Quotes eld
\end_inset

residual
\begin_inset Quotes erd
\end_inset

 alias effects using perf record.
 Found that beginning of stack frame uses some reads on stack allocated
 parameters, namely 
\begin_inset Quotes eld
\end_inset

is
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

os
\begin_inset Quotes erd
\end_inset

 (possibly others as well).
 Using valgrind and kcachegrind to analyze callgraph to find out where arguments
 are pushed.
 The most recent version (3.8.1) of Valgrind 
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset CommandInset href
LatexCommand href
name "http://valgrind.org/"
target "http://valgrind.org/"

\end_inset


\end_layout

\end_inset

 was downloaded and compiled from source to enable support for AVX instructions.
\end_layout

\begin_layout Standard
Call graph is main -> fftw_execute -> fftw_dft_solve -> apply_extra_iter
 -> n1fv_16.
\end_layout

\begin_layout Description
apply_extra_iter Located in /dft/direct.c.
 Trying to insert stack fix here works similar to inserting directly to
 kernel.
 A bit better, but still some bias not removed.
 This is the most logical and probable place to insert stack fix I think.
 The other functions are too high-level for it to make much sense.
 
\end_layout

\begin_layout Description
fftw_dft_solve Located in /dft/solve.c.
 Inserting fix here fixes almost everything, small noise left.
 Everything is removed when aligning main though, so need to try execute
 as well.
\end_layout

\begin_layout Description
fftw_execute Located in /api/execute.c.
 Same result as for dft_solve.
 
\end_layout

\begin_layout Standard
The most logical place to apply alignment fixes would probably be close
 to the kernel invocation.
 Properties of the kernel itself decides most of the alias effects, thus
 only the kernel, or the function calling the kernel, would know how the
 stack should be aligned.
 We insert some assembly to apply_extra_iter, aligning stack before the
 kernel is called twice.
\end_layout

\begin_layout Standard
Our example is very hard to achieve a speedup for because whatever we do
 the dynamic instruction count will increase significantly, adding a constant
 overhead whose cost is very hard to equalize on average over all environment
 sizes.
\end_layout

\begin_layout Paragraph
Heap collisions
\end_layout

\begin_layout Standard
Consider cases where heap addresses can collide.
 Here it is possible to apply a fix during the fftw_allocate phase, guaranteed
 speedup.
 Definitely possible to do something here.
 Implement fftw_malloc(size_t n, void* pair), or even keep a history of
 previously allocated sizes, and try to return addresses with no conflicts
 for small allocations.
 That way no modifications to the interface is needed either.
\end_layout

\end_body
\end_document
